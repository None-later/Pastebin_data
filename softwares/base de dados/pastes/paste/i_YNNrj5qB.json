{
 "espireDate": "N",
 "format": "python",
 "jSonReasons": [
  "kw_bot",
  "kw_bots",
  "kw_error",
  "kw_pass",
  "lg_en",
  "kw_illegal"
 ],
 "key": "YNNrj5qB",
 "pasteDate": "Feb 18, 2018, 4:42:17 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "#-NOTE: every cell is just a list.  When empty, that cell-list is [None] (not []).  This way we can pass a reference to a cell around and change the cell-list without having to remember co-ordinates, or have a dedicated cell datastructure.\n\ndef _fix_overfull_cell(self, cell_list):\n    #-TODO: Docstrings?  How are they supposed to be written?\n    # takes a reference to a cell's contents list -- so we can change it in this function and grid's referenced version will be changed too\n\n    if length(cell_list) > 1:\n        #make a list that contains all bots in cell that moved there this turn\n        bots_to_move_back = filter(lambda bot:(bot.has_moved == 1), cell) #-TODO:will throw a AttributeError if there's food/wall in this cell.  Might want to raise our own error, and catch the AttributeError if only to have informative crash messages.\n\n        for bot in bots_to_move_back:\n            self.grid.move(bot, bot.last_position)\n            bot.has_moved = -1\n            #-TODO replace with setter, raise actionfailed error with bot when set to -1\n\n        for bot in bots_to_move_back:\n            self._fix_overfull_cell(bot.position) #check the cell into which we just moved them\n\ndef _is_stationary(self, cell_element):\n    if cell_element == 'WALL':\n        return True\n    elif cell_element == None:\n        return False\n    elif cell_element.__class__ == #-TODO fill in ref to Food class\n        return True\n    elif cell_element.__class__ == #-TODO fill in ref to Bot class\n        return (not cell_element.get_action_type() == 'move') or (cell_element.has_moved == -1)\n        #other team bots will count as stationary; their action is None\n        #truth table -- bots that have been unmoved are stationary (has_moved == -1)\n        #has_moved == -1 | action == 'move' | not action == 'move' | desired return value\n        #    1           |        1         |           0          |     1\n        #    0           |        1         |           0          |     0\n        #    0           |        0         |           1          |     1\n\n    else:\n        assert False, \"World._is_stationary doesn't recognize cell_element: \", cell_element\n\n\n#-TODO make this a public method of grid\ndef grid.move(self, bot, destination_cell_list):\n    bot.last_position = bot.position\n    bot.position = destination_cell_list\n\n    self.add_to_cell(destination_cell_list, bot) #-TODO implement this, remove None when filling empty cell.\n    self.remove_from_cell(bot.last_position, bot) #-TODO implement this, add None to empty cells\n\n# world logic\n# Apply and check action loop\nfor bot in self._current_team:\n    #-TODO we should do this in start-turn or end-turn cleanup.  Just putting it here so we don't forget.\n    bot.has_moved = None\n\n    if bot.get_action_type() == 'move':\n        dest_cell_list = bot.get_action_params()\n        if filter(self._is_stationary(), dest_cell_list).length > 0: #if any objects in dest didn't plan to move this turn\n        #-NOTE: Moving into same cell as a bot that has moved or is going to move MUST be allowed, because that bot might have to move forward or backwards.  And we don't want the first bot we iterate over to get precedence.  We want to disallow either one from moving.\n            bot.has_moved = -1\n        else:\n            self.grid.move(bot, dest_cell_list)\n            bot.has_moved = 1\n    else:\n        #-TODO: check non-move actions for legality\n        #-TODO: apply non-move actions; none of the others actions are affected by position of teammate bots\n\n# Undo illegal moves\nfor cell in self.grid:\n    self._fix_overfull_cell(cell)\n\n#-TODO: Cleanup loop.  Set lots of bot properties to None.  action, has_moved, last_position, any others?\n\n#-TODO: new public methods/fields:\n#BOT\n    #bot.position -- is a reference to bot's current cell-list\n    #bot.last_position -- basically, should just be set to None.  We only use it in the apply/check action loop and the undo illegal move loop\n    #bot.has_moved --   None if action isn't move\n    #                   -1 if bot has been moved back or had move fail\n    #                   0 if bot hasn't tried to move yet, but intends to\n    #                   1 if bot has moved, and hasn't been moved back yet\n    #mechanism for sending failed action notifications\n    # Should maybe replace with getter and setter methods.\n#WORLD\n    #world.kill_bot(bot), removes bot from player botlist and grid (using grid.remove_from_cell(cellentity))\n#GRID\n    #grid.add_to_cell(cellentity)\n    #grid.remove_from_cell(cellentity)\n    #make grid an iterable object, returning each cell in no particular order.\n    #make each cell a list of its contents.  If empty, it should be [None] not []",
 "title": ""
}