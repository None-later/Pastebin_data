{
 "espireDate": "N",
 "format": "python",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "T1bXxeVb",
 "pasteDate": "Feb 21, 2018, 9:21:36 AM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "class CPU(object):\n\tregisters = {\n\t\t'0':'',\n\t\t'1':'',\n\t\t'2':'',\n\t\t'3':'',\n\t\t'4':'',\n\t\t'5':'',\n\t\t'6':'',\n\t\t'7':'',\n\t\t'8':'',\n\t\t'9':'',\n\t}\n\tIRQs = {\n\t\t'key_press': None,\n\t\t'key_release': None,\n\t}\n\tflags = {\n\t\t'reset':False,\n\t\t'waiting_for_input':False,\n\t}\n\tstack = []\n\taddr_stack = []\n\tdef __init__(self, ram, text_display, graphics_display, filesystem):\n\t\tself.ram = ram\n\t\tself.text_display = text_display\n\t\tself.graphics_display = graphics_display\n\t\t# We don't need this\n\t\t# self.text_display.graphics_display = graphics_display\n\t\t# self.graphics_display.text_display = text_display\n\t\tself.filesystem = filesystem\n\n\t\tself.graphics_display.keyPress.connect(self.keyPressEvent)\n\t\tself.graphics_display.keyRelease.connect(self.keyReleaseEvent)\n\t\tself.text_display.keyPress.connect(self.keyPressEvent)\n\t\tself.text_display.keyRelease.connect(self.keyReleaseEvent)\n\n\tdef keyPressEvent(self, key):\n\t\tif not self.IRQs['key_press']:\n\t\t\treturn\n\t\tself.registers['8'] = str(key)\n\t\tself.jumpWithStack(self.IRQs['key_press'])\n\t\n\tdef keyReleaseEvent(self, key):\n\t\tif not self.IRQs['key_release']:\n\t\t\treturn\n\t\tself.registers['8'] = str(key)\n\t\tself.jumpWithStack(self.IRQs['key_release'])\n\n\tdef jumpTo(self, i):\n\t\tself.position = int(i) - 1\n\n\tdef jumpWithStack(self, i):\n\t\tself.addr_stack.append(self.position)\n\t\tself.position = int(i) - 1\n\n\tdef init_reset(self):\n\t\tself.text_display.printLazy('\\n\\nCPU: Going to reset')\n\t\tself.flags['reset'] = True\n\t\t#self.position = len(self.data) + 1\n\t\tQTimer.singleShot(2000, self.reset)\n\n\tdef reset(self):\n\t\tself.ram = RAM()\n\t\tself.flags['reset'] = False\n\t\tself.text_display.setDisplay('')\n\t\tself.graphics_display.clear()\n\t\tself.start()\n\n\tdef readRegister(self, r):\n\t\tdata = str(self.registers[str(r)])\n\t\tif not data:\n\t\t\treturn ''\n\t\telif data[0] == '!':\n\t\t\treturn self.ram.getObject(int(data[1:]))\n\t\treturn str(data)\n\n\tdef processCommand(self, command, args):\n\t\tprint self.readRegister('1'), self.text_display.buffer2\n\t\tif self.flags['reset']:\n\t\t\treturn\n\t\tif not command:\n\t\t\treturn\n\t\tcommand = int(command)\n\t\tif command == commands_str['reset']:\n\t\t\tself.init_reset()\n\t\telif command == commands_str['input']:\n\t\t\treg = str(args[0])\n\t\t\tl = QEventLoop()\n\t\t\tdef gotString(s):\n\t\t\t\tif not self.flags['waiting_for_input']:\n\t\t\t\t\treturn\n\t\t\t\tself.registers[reg] = self.ram.storeObject(s)\n\t\t\t\tself.flags['waiting_for_input'] = False\n\t\t\t\tself.text_display.command_accepted.disconnect(gotString)\n\t\t\tself.flags['waiting_for_input'] = True\n\t\t\tself.text_display.command_accepted2.connect(l.exit)\n\t\t\tself.text_display.command_accepted.connect(gotString)\n\t\t\tl.exec_()\n\t\t\tself.text_display.command_accepted2.disconnect(l.exit)\n# -------- Should I delete this? ----------------------------\n\t\telif command == commands_str['str_to_int']:\n\t\t\treg = str(args[0])\n\t\t\tself.registers[reg] = int(self.registers[reg])\n\t\telif command == commands_str['int_to_str']:\n\t\t\treg = str(args[0])\n\t\t\tself.registers[reg] = str(self.registers[reg])\n# -----------------------------------------------------------\n\t\telif command == commands_str['jmp']:\n\t\t\tpos = int(args[0])\n\t\t\tself.jumpTo(pos)\n\t\telif command == commands_str['jmp_if']:\n\t\t\tpos, reg = args\n\t\t\tif self.registers[str(reg)]:\n\t\t\t\tself.jumpTo(pos)\n\t\telif command == commands_str['jmp_if_not']:\n\t\t\tpos, reg = args\n\t\t\tif not self.registers[str(reg)]:\n\t\t\t\tself.jumpTo(pos)\n\t\telif command == commands_str['store_data']:\n\t\t\to = args[0]\n\t\t\ta = self.ram.storeObject(o)\n\t\t\tself.registers['2'] = a\n\t\telif command == commands_str['copy']:\n\t\t\tr1, r2 = args\n\t\t\tself.registers[str(r1)] = self.registers[str(r2)]\n\t\telif command == commands_str['free_data']:\n\t\t\tself.ram.removeObjectAt(int(self.registers['2'][1:]))\n\t\telif command == commands_str['add']:\n\t\t\tr1, r2 = args\n\t\t\td1 = int(self.readRegister(r1))\n\t\t\td2 = int(self.readRegister(r2))\n\t\t\tself.registers[str(r1)] = d1 + d2\n\t\telif command == commands_str['write']:\n\t\t\tr, data = args\n\t\t\tself.registers[str(r)] = data\n\t\telif command == commands_str['print']:\n\t\t\tr = args[0]\n\t\t\tdata = self.readRegister(r)\n\t\t\tself.text_display.printLazy(str(data))\n\t\telif command == commands_str['==']:\n\t\t\tr1, r2, j = args\n\t\t\tif self.readRegister(r1) == self.readRegister(r2):\n\t\t\t\tself.jumpTo(j)\n\t\telif command == commands_str['!=']:\n\t\t\tr1, r2, j = args\n\t\t\tif self.readRegister(r1) != self.readRegister(r2):\n\t\t\t\tself.jumpTo(j)\n\t\telif command == commands_str['<']:\n\t\t\tr1, r2, j = args\n\t\t\tif int(self.readRegister(r1)) < int(self.readRegister(r2)):\n\t\t\t\tself.jumpTo(j)\n\t\telif command == commands_str['<=']:\n\t\t\tr1, r2, j = args\n\t\t\tif int(self.readRegister(r1)) <= int(self.readRegister(r2)):\n\t\t\t\tself.jumpTo(j)\n\t\telif command == commands_str['>']:\n\t\t\tr1, r2, j = args\n\t\t\tif int(self.readRegister(r1)) > int(self.readRegister(r2)):\n\t\t\t\tself.jumpTo(j)\n\t\telif command == commands_str['>=']:\n\t\t\tr1, r2, j = args\n\t\t\tif int(self.readRegister(r1)) >= int(self.readRegister(r2)):\n\t\t\t\tself.jumpTo(j)\n# -------- Should I delete this? ----------------------------\n\t\telif command == commands_str['pow']:\n\t\t\tr1, r2 = args\n\t\t\tself.registers[str(r1)] = int(self.registers[str(r1)]) ** int(self.registers[str(r2)])\n# -----------------------------------------------------------\n\t\telif command == commands_str['sign']:\n\t\t\tr1 = str(args[0])\n\t\t\tself.registers[str(r1)] = -int(self.registers[str(r1)])\n\t\telif command == commands_str['sleep']:\n\t\t\tsecs = int(args[0])\n\t\t\tl = QEventLoop()\n\t\t\tQTimer.singleShot(secs * 1000, l.exit)\n\t\t\tl.exec_()\n\t\t\tdel l\n\t\telif command == commands_str['msleep']:\n\t\t\tmsecs = int(args[0])\n\t\t\tl = QEventLoop()\n\t\t\tQTimer.singleShot(msecs, l.exit)\n\t\t\tl.exec_()\n\t\t\tdel l\n\t\telif command == commands_str['create_array']:\n\t\t\treg = str(args[0])\n\t\t\tself.registers[str(reg)] = self.ram.storeObject([])\n\t\telif command == commands_str['get_element']:\n\t\t\tr1, r2 = args\n\t\t\tindex = int(self.readRegister(r1))\n\t\t\tarr = self.readRegister(r2)\n\t\t\tprint index, arr\n\t\t\tself.registers['4'] = self.ram.storeObject(arr[index])\n\t\telif command == commands_str['append_element']:\n\t\t\tr1, r2 = args\n\t\t\tdata = self.readRegister(r1)\n\t\t\tarr = self.readRegister(r2)\n\t\t\tarr.append(data)\n\t\telif command == commands_str['set_element']:\n\t\t\tr1, r2, r3 = args\n\t\t\te = self.readRegister(r1)\n\t\t\ti = self.readRegister(r2)\n\t\t\tself.readRegister(r3)[i] = e\n\t\telif command == commands_str['del_element']:\n\t\t\tr1, r2 = args\n\t\t\tself.readRegister(r2).pop(int(self.readRegister(r1)))\n\t\telif command == commands_str['len']:\n\t\t\tr1, r2 = args\n\t\t\tarr = self.readRegister(r1)\n\t\t\tself.registers[str(r2)] = len(arr)\n\t\telif command == commands_str['push']:\n\t\t\t#print self.registers\n\t\t\tself.stack.append(self.registers.copy())\n\t\telif command == commands_str['pop']:\n\t\t\t#print self.registers\n\t\t\tself.registers = self.stack.pop()\n\t\telif command == commands_str['print_line']:\n\t\t\tr = args[0]\n\t\t\tdata = self.readRegister(r)\n\t\t\tself.text_display.printLine(str(data))\n\t\telif command == commands_str['print_raw']:\n\t\t\tr = args[0]\n\t\t\tdata = self.readRegister(r)\n\t\t\tself.text_display.printLine(str(data))\n\t\telif command == commands_str['execute']:\n\t\t\tr = args[0]\n\t\t\tfilename = self.readRegister(r)\n\t\t\ttry:\n\t\t\t\tdata = self.filesystem.getFile(filename).data\n\t\t\texcept:\n\t\t\t\tself.text_display.printLine('MetaFile not found')\n\t\t\t\tself.init_reset()\n\t\t\t\treturn\n\t\t\tself.stack = []\n\t\t\tself.addr_stack = []\n\t\t\tfor i in self.IRQs:\n\t\t\t\tself.IRQs[i] = None\n\t\t\tself.data = data.split(chr(30))\n\t\t\tself.position = -1\n\t\telif command == commands_str['switch_display']:\n\t\t\td = args[0]\n\t\t\tif d == '0':\n\t\t\t\tself.graphics_display.hide()\n\t\t\t\tself.text_display.show()\n\t\t\t\tself.graphics_display.clear()\n\t\t\telif d=='1':\n\t\t\t\tself.text_display.hide()\n\t\t\t\tself.graphics_display.show()\n\t\telif command == commands_str['ret']:\n\t\t\tself.position = self.addr_stack.pop()\n\t\telif command == commands_str['create_rect']:\n\t\t\tname, x, y, w, h = args\n\t\t\tself.graphics_display.createRect(name, int(x), int(y), int(w), int(h))\n\t\telif command == commands_str['create_ellipse']:\n\t\t\tname, x, y, w, h = args\n\t\t\tself.graphics_display.createEllipse(name, int(x), int(y), int(w), int(h))\n\t\telif command == commands_str['move_item']:\n\t\t\tname, r1, r2 = args\n\t\t\tdx = self.readRegister(r1)\n\t\t\tdy = self.readRegister(r2)\n\t\t\t#print dx, dy\n\t\t\tself.graphics_display.moveItem(name, int(dx), int(dy))\n\t\telif command == commands_str['call']:\n\t\t\taddr = args[0]\n\t\t\tself.jumpWithStack(addr)\n\t\telif command == commands_str['check_for_object_collisions']:\n\t\t\tname = args[0]\n\t\t\tc = self.graphics_display.checkCollisionsFor(name)\n\t\t\tif c:\n\t\t\t\tself.registers['5'] = self.ram.storeObject(c)\n\t\telif command == commands_str['catch_irq']:\n\t\t\tirq, addr = args\n\t\t\tself.IRQs[irq] = int(addr)\n\t\telif command == commands_str['abandon_irq']:\n\t\t\tirq = args[0]\n\t\t\tself.IRQs[irq] = None\n\t\telif command == commands_str['inc']:\n\t\t\treg = args[0]\n\t\t\ti = int(self.readRegister(reg))\n\t\t\tself.registers[reg] = str(i + 1)\n\t\telif command == commands_str['dec']:\n\t\t\treg = args[0]\n\t\t\ti = int(self.readRegister(reg))\n\t\t\tself.registers[reg] = str(i - 1)\n\t\telif command == commands_str['load_file_list']:\n\t\t\tr1, r2 = args\n\t\t\tname = self.readRegister(r2)\n\t\t\tarr = []\n\t\t\tprint self.filesystem.getFile(name)\n\t\t\tfor i in self.filesystem.getFile(name).list:\n\t\t\t\tarr.append(i.fullPath())\n\t\t\tself.registers[str(r1)] = self.ram.storeObject(arr)\n\t\telif command == commands_str['delete_file']:\n\t\t\treg = args[0]\n\t\t\tname = self.readRegister(reg)\n\t\t\tf = self.filesystem.getFile(name)\n\t\t\tf.delete()\n\t\telif command == commands_str['load_file_data']:\n\t\t\tr1, r2 = args\n\t\t\tname = self.readRegister(r1)\n\t\t\tf = self.filesystem.read(name)\n\t\t\tself.registers[str(r2)] = self.ram.storeObject(f)\n\t\telif command == commands_str['save_file_data']:\n\t\t\tr1, r2 = args\n\t\t\tdata = str(self.readRegister(r1))\n\t\t\tname = str(self.readRegister(r2))\n\t\t\tf = self.filesystem.getFile(name)\n\t\t\tf.data = data\n\t\telif command == commands_str['switch_console_mode']:\n\t\t\treg = args[0]\n\t\t\tval = bool(int(reg))\n\t\t\tif val:\n\t\t\t\tself.text_display.console_mode = True\n\t\t\telse:\n\t\t\t\tself.text_display.console_mode = False\n\t\telif command == commands_str['connect_with_buffer']:\n\t\t\tprint 'Connecting'\n\t\t\treg = args[0]\n\t\t\ttext = str(self.readRegister(reg))\n\t\t\tself.text_display.buffer2.setText(text)\n\t\t\tself.registers[reg] = self.ram.storeObject(self.text_display.buffer2)\n\t\telse:\n\t\t\tprint 'Invalid command:', command\n\n\tdef execute(self):\n\t\twhile self.position < len(self.data):\n\t\t\tcommand = self.data[self.position]\n\t\t\tprint commands_id[int(self.data[self.position])]\n\t\t\tif not command:\n\t\t\t\tself.position += 1\n\t\t\t\tcontinue\n\t\t\targs = []\n\t\t\tif commands_id_args[int(self.data[self.position])] > 0:\n\t\t\t\targs = self.getAdditionalArgs(commands_id_args[int(self.data[self.position])])\n\t\t\tif commands_id_args[int(self.data[self.position])] == 1:\n\t\t\t\targs = list(args)\n\t\t\t#print self.registers\n\t\t\t\n\t\t\t#print 'in', len(self.data), self.position\n\t\t\tself.processCommand(command, args)\n\t\t\t#print 'out', len(self.data), self.position\n\t\t\tself.position += 1\n\n\tdef start(self):\n\t\tdata = self.filesystem.read('/boot')\n\t\tself.data = data.split(chr(30))\n\t\tself.position = 0\n\t\tself.execute()\n\n\tdef getAdditionalArgs(self, n):\n\t\tfor i in xrange(n):\n\t\t\tself.position += 1\n\t\t\tyield self.data[self.position]",
 "title": ""
}