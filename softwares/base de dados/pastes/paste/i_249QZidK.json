{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "249QZidK",
 "pasteDate": "Feb 12, 2018, 5:23:55 PM",
 "relevancy": 2.0,
 "relevant": false,
 "text": "#include \"Game.h\"\n//#include \"Segment.h\"\n\nnamespace GameDev2D\n{\n    Game::Game()\n    {\n        LoadTexture(\"RedSegment\");\n        m_Head = new Segment(Vector2(8.0f, 8.0f), \"RedSegment\");\n\t\tAddSegmentRed(Vector2(8.0f, 8.0f));\n        m_Velocity = Vector2::Zero;\n        \n        LoadTexture(\"BlueSegment\");\n        m_Head2 = new Segment(Vector2(1012.f, 760.0f), \"BlueSegment\");\n        AddSegmentBlue(Vector2(1012.f, 760.0f));\n\t\tm_Velocity2 = Vector2::Zero;\n\n\t\tPixelFormat pixelFormat(PixelFormat::RGBA, PixelFormat::UnsignedByte);\n\t\tImageData imageData(pixelFormat, GetScreenWidth(), GetScreenHeight());\n\n\t\tm_Canvas = new Texture(imageData);\n\t\tm_RenderTarget = new RenderTarget(m_Canvas);\n    }\n\n    Game::~Game()\n    {\n        UnloadTexture(\"RedSegment\");   \n        UnloadTexture(\"BlueSegment\");\n\n        //red\n\t\tSegment* segment = m_Head;\n\t\twhile (segment != nullptr)\n\t\t{\n\t\t\tSegment* next = segment->GetNext();\n\t\t\tdelete segment;\n\t\t\tsegment = next;\n\t\t}\n\t\tm_Head = nullptr;\n        \n\t\tif (m_Canvas != nullptr)\n\t\t{\n\t\t\tdelete m_Canvas;\n\t\t\tm_Canvas = nullptr;\n\t\t}\n\t\tif (m_RenderTarget != nullptr)\n\t\t{\n\t\t\tdelete m_RenderTarget;\n\t\t\tm_RenderTarget = nullptr;\n\t\t}\n\t\t\n\t\t//blue\n        Segment* segment2 = m_Head2;\n        while (segment2 != nullptr)\n        {\n            Segment* next2 = segment2->GetNext();\n            delete segment2;\n            segment2 = next2;\n        }\n        m_Head2 = nullptr;\n\n\n    }\n\n\n    void Game::Update(double delta)\n    {\n        /*GamePad* gamepad = Services::GetInputManager()->GetGamePad(GamePad::Port_1);\n        if (gamepad->IsConnected() == true)\n        {\n            float x = gamepad->GetLeftThumbStick().x;\n            float y = gamepad->GetLeftThumbStick().y;\n            if (Math::IsClose(x, 1, 0.1f) == true)\n            {\n                Turn(Vector2(1.0f, 0.0f));\n            }\n            else if (Math::IsClose(x, -1, 0.1f) == true)\n            {\n                Turn(Vector2(-1.0f, 0.0f));\n            }\n            else if (Math::IsClose(y, 1, 0.1f) == true)\n            {\n                Turn(Vector2(0.0f, 1.0f));\n            }\n            else if (Math::IsClose(y, -1, 0.1f) == true)\n            {\n                Turn(Vector2(0.0f, -1.0f));\n            }\n\n            if (gamepad->IsButtonPressed(GamePad::A) == true)\n            {\n                if (m_Velocity != Vector2::Zero)\n                {\n                    m_Velocity = Vector2::Zero;\n                    gamepad->Vibrate(1.0f, 1.0f, 0.2);\n                }\n            }\n        }*/\n\n        if (m_Velocity != Vector2::Zero)\n        {\n            //increments position\n            //red\n            Vector2 position = m_Head->GetPosition();\n            position.x += m_Velocity.x * delta;\n            position.y += m_Velocity.y * delta;            \n\n            //sets heads position\n            //red\n            m_Head->SetPosition(position);           \n\n            //gets next segmetn after head\n            //red\n            Segment* next = m_Head->GetNext();\n\n            Vector2 direction = m_Velocity.Normalized();\n            Vector2 difference = Vector2(fabsf(position.x - next->GetPosition().x), fabsf(position.y - next->GetPosition().y));\n            Vector2 magnitude = Vector2(direction.x * 16.0f, direction.y * 16.0f);\n\n        \n            //checks if difference is big enough to draw next segment\n            //red\n            if (difference >= Vector2(fabsf(magnitude.x), fabsf(magnitude.y)))\n            {\n                AddSegmentRed(Vector2(next->GetPosition().x + magnitude.x, next->GetPosition().y + magnitude.y));\n            }\n            \n\n        }\n\t\tif (m_Velocity2 != Vector2::Zero)\n\t\t{\n\t\t\tVector2 position2 = m_Head2->GetPosition();\n\t\t\tposition2.x += m_Velocity.x * delta;\n\t\t\tposition2.y += m_Velocity.y * delta;\n\n\t\t\tm_Head2->SetPosition(position2);\n\n\t\t\tSegment* next2 = m_Head2->GetNext();\n\n\t\t\tVector2 direction2 = m_Velocity2.Normalized();\n\t\t\tVector2 difference2 = Vector2(fabsf(position2.x - next2->GetPosition().x), fabsf(position2.y - next2->GetPosition().y));\n\t\t\tVector2 magnitude2 = Vector2(direction2.x * 16.0f, direction2.y * 16.0f);\n\n\t\t\tif (difference2 >= Vector2(fabsf(magnitude2.x), fabsf(magnitude2.y)))\n\t\t\t{\n\t\t\t\tAddSegmentBlue(Vector2(next2->GetPosition().x + magnitude2.x, next2->GetPosition().y + magnitude2.y));\n\t\t\t}\n\t\t}\n    }\n\n    void Game::Draw()\n    {\n\t\tm_RenderTarget->Begin(false);\n\n\t\tm_Head->Draw();\n\n        m_Head2->Draw();\n\t\t\n\t\tm_RenderTarget->End();\n\n\t\tServices::GetGraphics()->DrawTexture(m_Canvas, Vector2::Zero, Rotation::Radians(0.0f), 1.0f);\n\n      /*  Segment* segment = m_Head;\n        while (segment != nullptr) \n        {\n            segment->Draw();\n            segment = segment->GetNext();\n        }*/\n    }\n\n    void Game::HandleLeftMouseClick(float mouseX, float mouseY)\n    {\n\n    }\n\n    void Game::HandleRightMouseClick(float mouseX, float mouseY)\n    {\n\n    }\n\n    void Game::HandleMouseMoved(float mouseX, float mouseY, float previousX, float previousY)\n    {\n\n    }\n\n    void Game::HandleKeyPress(Keyboard::Key key)\n    {\n        //red\n        if (key == Keyboard::Left)\n        {\n            TurnRed(Vector2(-1.0f, 0.0f));\n        }\n        else if (key == Keyboard::Right)\n        {\n            TurnRed(Vector2(1.0f, 0.0f));\n        }\n        else if (key == Keyboard::Up )\n        {\n            TurnRed(Vector2(0.0f, 1.0f));\n        }\n        else if (key == Keyboard::Down )\n        {\n            TurnRed(Vector2(0.0f, -1.0f));\n        }\n        //blue\n        if (key == Keyboard::A)\n        {\n            TurnBlue(Vector2(-1.0f, 0.0f));\n        }\n        else if (key == Keyboard::D)\n        {\n            TurnBlue(Vector2(1.0f, 0.0f));\n        }\n        else if (key == Keyboard::W)\n        {\n            TurnBlue(Vector2(0.0f, 1.0f));\n        }\n        else if (key == Keyboard::S)\n        {\n            TurnBlue(Vector2(0.0f, -1.0f));\n        }\n    }\n\n    void Game::TurnRed(const Vector2& direction)\n    {\n        if (m_Velocity.DotProduct(direction) == 0.0f)\n        {\n            //Set the velocity\n            //red\n            m_Velocity = direction * SPEED;\n\n            if (m_Velocity.y == 0.0f)\n            {\n                AddSegmentRed(Vector2(m_Head->GetNext()->GetPosition().x, m_Head->GetPosition().y));\n            }\n            else if (m_Velocity.x == 0.0f)\n            {\n                AddSegmentRed(Vector2(m_Head->GetPosition().x, m_Head->GetNext()->GetPosition().y));\n            }\n        }\n    }\n\n    void Game::TurnBlue(const Vector2& direction2)\n    {\n        if (m_Velocity2.DotProduct(direction2) == 0.0f)\n        {\n            //Set the velocity\n\t\t\t//blue\n\t\t\tm_Velocity2 = direction2 * SPEED;\n            \n            if (m_Velocity2.y == 0.0f)\n            {\n                AddSegmentBlue(Vector2(m_Head2->GetNext()->GetPosition().x, m_Head2->GetPosition().y));\n            }\n            else if (m_Velocity2.x == 0.0f)\n            {\n                AddSegmentBlue(Vector2(m_Head2->GetPosition().x, m_Head2->GetNext()->GetPosition().y));\n            }\n        }\n\n    }\n\n\tvoid Game::AddSegmentRed(const Vector2& position)\n\t{\n        //red\n\t\t//Create the segment object\n\t\tSegment* segment = new Segment(position, \"RedSegment\");\n\n\t\t//If the Head's next pointer isn't null\n\t\tif (m_Head->GetNext() != nullptr)\n\t\t{\n\t\t\t//Set it as the segment's next pointer\n\t\t\tsegment->SetNext(m_Head->GetNext());\n\t\t}\n\n\t\t//Then set the new segment as the head's next segment\n\t\tm_Head->SetNext(segment);        \n\t}\n\n    void Game::AddSegmentBlue(const Vector2& position2)\n    {\n        //blue\n        //Create the segment object\n        Segment* segment2 = new Segment(position2, \"BlueSegment\");\n\n        //If the Head's next pointer isn't null\n        if (m_Head2->GetNext() != nullptr)\n        {\n            //Set it as the segment's next pointer\n            segment2->SetNext(m_Head2->GetNext());\n        }\n\n        //Then set the new segment as the head's next segment\n        m_Head2->SetNext(segment2);\n    }\n}",
 "title": ""
}