{
 "espireDate": "N",
 "format": "csharp",
 "jSonReasons": [
  "kw_down",
  "lg_en"
 ],
 "key": "VFgnYQgD",
 "pasteDate": "Feb 17, 2018, 12:53:11 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "/// <summary>\n/// Processes this branch to completion\n/// </summary>\n/// <param name=\"totalSp\"></param>\npublic void ComputeBranch(int totalSp)\n{\n    int totalCost = 0;\n    double totalEffect = 1;\n    bool hasSpeculativePotential = true;\n\n    while (true)\n    {\n        IList<SkillInfo> nextUpdates = GetAllowedUpgrades(totalCost, totalSp - totalCost);\n\n        //first of all, we need to select the best immediate upgrade\n        //this is necessary to provide a baseline for speculative analysis \n        SkillInfo best = nextUpdates[0];\n        if (nextUpdates.Count == 0) break;\n        {\n            for (int i = 1; i < nextUpdates.Count; i++)\n            {\n                if (nextUpdates[i].efficiency[nextUpdates[i].CurLevel + 1] > best.efficiency[best.CurLevel + 1])\n                {\n                    best = nextUpdates[i];\n                }\n            }\n\n            double bestEfficiency = best.efficiency[best.CurLevel + 1];\n\n            //Now we're going to perform a speculative walk deeper into the tree\n            //We are searching for skills that are potentially good.\n            //It is possible to capture and learn from the results of these walks,\n            //But with this degree of complexity, this optimization is not necessary.\n            if (hasSpeculativePotential) //flag this check\n            {\n                IEnumerable<SkillInfo> speculativeOptions = nextUpdates.Where((SkillInfo x) => x != best && x.CurLevel == 0);\n                bool flag = (speculativeOptions.Count() > 0) ? false : true;\n                foreach (SkillInfo skill in speculativeOptions)\n                {\n                    //walk down the tree and examine cumulative efficiency based on the cost\n                    //of upgrading this skill and each subsequent skill\n                    IList<SkillInfo> children = new List<SkillInfo>();\n                    foreach (SkillInfo k in skill.nextSkills) children.Add(k);\n\n                    //take each child skill which does not have a child skill\n                    while (true)\n                    {\n                        //gather all of the children's children which are not listed as children\n                        IList<SkillInfo> validChildren = new List<SkillInfo>();\n                        foreach (SkillInfo child in children)\n                        {\n                            foreach (SkillInfo _child in child.nextSkills)\n                            {\n                                if (_child.CurLevel == 0 && !children.Contains(_child)) validChildren.Add(_child);\n                            }\n                        }\n\n                        //if there are no children's children which are not children then we found all the children\n                        if (validChildren.Count() == 0) break;\n                        //otherwise add the children's children to the children so that we know they are children\n                        foreach (SkillInfo k in validChildren)\n                        {\n                            children.Add(k);\n                        }\n                    }\n\n                    //We now have an enumeration of every descendent in the tree\n                    //We must now examine every descendent, to test whether it's\n                    //speculative value exceeds the value of the best immediate option.\n                    foreach (SkillInfo k in children)\n                    {\n                        //flag if there are locked skills with potential\n                        if (k.CurLevel == 0 && k.totalEffect[k.MaxLevel] > 1) flag = true;\n\n                        int specLevel = k.CurLevel; //??? Just in case lol\n                        double specEffect = 1;\n                        int specBudget = totalSp - totalCost;\n\n                        //Find the cost required to unlock up to this skill\n                        int costToUnlock = 0;\n                        SkillInfo parent = k.prerequisite;\n                        //move up the tree unlocking everything as needed\n                        while (parent.CurLevel == 0 && parent.prerequisite != null)\n                        {\n                            costToUnlock += (int)parent.cost[1];\n                            specEffect *= parent.effect[1]; //capture any advantage of this skill\n                            parent = parent.prerequisite;\n                        }\n\n                        //adjust our budget\n                        specBudget -= costToUnlock;\n                        if (specBudget <= 0) continue;\n\n                        //Speculatively upgrade the skill continually\n                        while (specLevel < k.MaxLevel\n                            && k.totalCost[specLevel] < specBudget\n                            //We are only interested in skills which could increase the efficiency\n                            && k.efficiency[specLevel + 1] > bestEfficiency)\n                        {\n                            //This upgrade is guaranteed to increase the speculative path value\n                            //relative to the value of the best upgrade that we can find.\n                            specLevel += 1;\n                            specEffect *= k.effect[specLevel];\n                            double SpecCost = k.totalCost[specLevel] - k.totalCost[k.CurLevel];\n                            //As this value increases - and the value of the immediate options decreases\n                            //The speculative path may become optimal.\n                            if (Math.Pow(specEffect, 1 / SpecCost) > bestEfficiency)\n                            {\n                                //select the best descendent. We can add a simple\n                                //optimization, walking down the tree to unlock\n                                //every required skill in one go.\n                                best = k;\n                                bestEfficiency = Math.Pow(specEffect, 1 / SpecCost);\n                            }\n                        }\n                    }\n                }\n                //there's no potential, so we can stop looking for it.\n                if (!flag) hasSpeculativePotential = false;\n            }\n        }\n\n        //As above, we do not guarantee that the best skill has all prerequisites unlocked.\n        //So, we're going to walk up the tree and make sure everything is upgraded\n        Stack<SkillInfo> path = new Stack<SkillInfo>();\n        path.Push(best);\n        //upgrade every necessary parent until the best skill is unlocked\n        while (path.Peek().prerequisite != null && path.Peek().prerequisite.CurLevel == 0)\n        {\n            path.Push(path.Peek().prerequisite); //we need to upgrade this one\n        }\n\n        //Perform every upgrade\n        while (path.Count > 0)\n        {\n            //grab the next skill\n            best = path.Pop();\n                    \n            //this can't happen...\n            if (totalCost + best.cost[best.CurLevel + 1] > totalSp)\n            {\n                Console.WriteLine(\"==========WTF?!?!?!?!==========\");\n            }\n\n            //upgrade the skill and list the upgrade off\n            best.CurLevel += 1;\n            Upgrades.Add(Talents.IndexOf(best));\n\n            //tally the running cost\n            totalCost += (int)best.cost[best.CurLevel];\n            Costs.Add(totalCost);\n\n            //tally the current effect\n            totalEffect *= best.effect[best.CurLevel];\n            Effects.Add(totalEffect);\n        }\n    }\n}",
 "title": "Speculative TT2 Skill Upgrader"
}