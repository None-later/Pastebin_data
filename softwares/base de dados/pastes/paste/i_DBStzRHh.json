{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "DBStzRHh",
 "pasteDate": "Feb 18, 2018, 6:36:36 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "#include <string.h>\n#include <stdlib.h>\n#include \"array.h\"\n\ntypedef struct array array;\ntypedef struct map map;\n\n/** @brief Allocates and initializes a new array */\narray *array_new(void) {\n    array *tmp = malloc(sizeof(array));\n    tmp->size = 0;\n    tmp->items = malloc(sizeof(void*) * ARRAY_EXPAND_SIZE);\n    tmp->_num_allocated = ARRAY_EXPAND_SIZE;\n    return tmp;\n}\n\n/** @brief Sets the value of an index.\n * \n * Takes an array, index, and pointer to an item and adds it to the array.\n * If index is higher than the size of the array, it appends to the end of the array.\n * If index is negative, index from the end instead (i.e. array_set(arr, -1, item) sets the last element)\n * item can be anything, EXCEPT null.\n * \n * @param arr The array to operate upon.\n * @param index The index to access. If index is negative, index from the end instead.\n * @param item The item to set at index.\n * @return 1 if the operation succeeded, or 0 if it failed.\n */\nint array_set(array *arr, int index, void *item) {\n    void *_tmp;\n    int tmp_ind;\n    \n    if (item == NULL)\n        return 0;\n    \n    if (index >= arr->_num_elements) {\n        if (arr->_num_elements == arr->_num_allocated) {\n            _tmp = realloc(arr->items, sizeof(void*) * (arr->_num_elements + ARRAY_EXPAND_SIZE));\n            if (!_tmp)\n                return 0;\n            arr->items = (void**)_tmp;\n        }\n        arr->items[arr->_num_elements] = item;\n        arr->_num_elements += 1;\n        arr->size += 1;\n    } else if (index < 0) {\n        tmp_ind = arr->_num_elements + index;\n        return array_set(arr, tmp_ind, item);\n    } else {\n        arr->items[index] = item;\n    }\n    return 1;\n}\n\n/** @brief Convenience function to append to an array. */\nint array_append(array *arr, void *item) {\n    return array_set(arr, arr->_num_elements, item);\n}\n\n/** @brief Retrieves a value from the array. Returns null if the index is out of range. \n * \n * @param arr The array to operate upon.\n * @param index The index of the specified item you wish to retrieve.\n * @return The element at index, or NULL if the index is out of range.\n */\nvoid *array_get(array *arr, int index) {\n    int tmp_ind;\n    if (arr->_num_elements == 0)\n        return NULL;\n    if (index >= arr->_num_elements)\n        return NULL;\n    else if (index < 0) {\n        tmp_ind = arr->_num_elements + index;\n        return array_get(arr, tmp_ind);\n    } else {\n        return arr->items[index];\n    }\n}\n\n/** @brief Removes a value from arr, shifting the items over and returning the removed value. \n * \n * @param arr The array to operate upon.\n * @param index The index of the element to remove.\n * @return The element removed, or NULL if the index is out of range.\n */\nvoid *array_remove(array *arr, int index) {\n    int tmp_ind;\n    int i;\n    void *tmp = array_get(arr, index);\n    if (tmp == NULL)\n        return NULL;\n    \n    if (arr->_num_elements == 0)\n        return NULL;\n    \n    if (index >= arr->_num_elements) \n        return NULL;\n\n    if (index < 0) {\n        tmp_ind = arr->_num_elements + index;\n        if (tmp_ind < 0) return NULL;\n        return array_remove(arr, tmp_ind);\n    }\n    \n    if (arr->_num_elements > 1)\n        for (i = index; i < (arr->_num_elements-1); i++)\n            array_set(arr, i, array_get(arr, i+1));\n    \n    arr->size -= 1;\n    arr->_num_elements -= 1;\n    return tmp;\n}\n\n/** @brief Convenience function to remove the last element in the array. */\nvoid *array_pop(array *arr) {\n    return array_remove(arr, arr->_num_elements-1);\n}\n\n/** @brief Deletes the array. \n * \n * BEWARE: In addition to freeing all the elements in the array, it also frees the array itself.\n * Do not call free() on the array* after this function, it does it for you!!\n * \n * If you do not wish for all the elements in the array to be freed, call array_remove on the elements you do not wish to be freed before calling this function.\n */\nvoid array_free(array *arr) {\n    if (arr != NULL) {\n        if (arr->items != NULL)\n            free(arr->items);\n        \n        free(arr);\n    }\n}\n\n\n\n\n/** @brief Allocates and initializes a new map */\nmap *map_new(void) {\n    map *tmp = malloc(sizeof(map));\n    tmp->keys = array_new();\n    tmp->values = array_new();\n    return tmp;\n}\n\n/** @brief Retrieves a value from the map. Returns null if the key is not valid. \n * \n * @param m The map to operate upon.\n * @param key The key of the specified item you wish to retrieve.\n * @return The element at key, or NULL if the key is not valid.\n */\nvoid *map_get(map *m, void *key) {\n    int i;\n    \n    if (key == NULL)\n        return NULL;\n    \n    for (i = 0; i < m->keys->size; i++) {\n        if (array_get(m->keys, i) == key) {\n            return array_get(m->values, i);\n        }\n    }\n    \n    return NULL;\n}\n\n/** @brief Sets the value of a key.\n * \n * Takes a map, key, and pointer to an item and adds it to the map.\n * \n * @param m The map to operate upon.\n * @param key The key to access.\n * @param item The value to set for key.\n * @return 1 if the operation succeeded, or 0 if it failed.\n */\nint map_set(map *m, void *key, void *value) {\n    int i;\n    int ind = m->keys->size;\n    \n    if (key == NULL || value == NULL)\n        return 0;\n    \n    for (i = 0; i < m->keys->size; i++) {\n        if (array_get(m->keys, i) == key) {\n            ind = i;\n            break;\n        }\n    }\n    \n    array_set(m->keys, ind, key);\n    array_set(m->values, ind, value);\n    \n    return 1;\n}\n\n/** @brief Removes the value associated with key, returning the removed value. \n * \n * @param m The map to operate upon.\n * @param key The key of the element to remove.\n * @return The element removed, or NULL if the key is not valid.\n */\nvoid *map_remove(map *m, void *key) {\n    int i;\n    \n    if (key == NULL)\n        return NULL;\n    \n    for (i = 0; i < m->keys->size; i++) {\n        if (array_get(m->keys, i) == key) {\n            array_remove(m->keys, i);\n            return array_remove(m->values, i);\n        }\n    }\n    \n    return NULL;\n}\n\n/** @brief Deletes the map. \n * \n * BEWARE: In addition to freeing all the elements in the map, it also frees the map itself.\n * Do not call free() on the map* after this function, it does it for you!!\n * \n * If you do not wish for all the elements in the map to be freed, call map_remove on the elements you do not wish to be freed before calling this function.\n */\nvoid map_free(map *m) {\n    if (m != NULL) {\n        array_free(m->keys);\n        array_free(m->values);\n        free(m);\n    }\n}",
 "title": ""
}