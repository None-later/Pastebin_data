{
 "espireDate": "N",
 "format": "csharp",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "KQbqAkUt",
 "pasteDate": "Feb 18, 2018, 11:51:03 AM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "public class Complex : ICloneable\n    {\n        private double m_real = 0.0;\n        private double m_imag = 0.0;\n \n        #region \n        public Complex()\n        {\n        }\n \n        public Complex (double re)\n        {\n            m_real = re;\n        }\n \n        public Complex (double re, double im)\n        {\n            m_real = re;\n            m_imag = im;\n        }\n \n        public Complex (Complex x)\n        {\n            m_real = x.Real;\n            m_imag = x.Imag;\n        }\n        #endregion\n \n        public double Real\n        {\n            get { return m_real; }\n            set { m_real = value; }\n        }\n \n        public double Imag\n        {\n            get { return m_imag; }\n            set {m_imag = value; }\n        }\n \n        public double Abs\n        {\n            get { return Math.Sqrt(m_imag * m_imag + m_real * m_real); }\n        }\n \n        public double Arg\n        {\n            get { return Math.Atan(m_imag / m_real); }\n        }\n \n        /// <summary>\n        ///  - \n        /// </summary>\n        public Complex GetConjugate()\n        {\n            return new Complex (m_real, -m_imag);\n        }\n \n        public override string ToString()\n        {\n            string res = \"\";\n \n            if (m_real != 0.0)\n            {\n                res = m_real.ToString();\n            }\n \n            if (m_imag != 0.0)\n            {\n                if (m_imag > 0)\n                {\n                    res += \"+\";\n                }\n \n                res += m_imag.ToString() + \"i\";\n            }\n \n            return res;\n        }\n \n        #region   \n        public static Complex operator + (Complex c1, Complex c2)\n        {\n            return new Complex (c1.Real + c2.Real, c1.Imag + c2.Imag);\n        }\n \n        public static Complex operator + (Complex c1, double c2)\n        {\n            return new Complex (c1.Real + c2, c1.Imag);\n        }\n \n        public static Complex operator + (double  c1, Complex c2)\n        {\n            return new Complex (c1 + c2.Real, c2.Imag);\n        }\n        #endregion\n \n \n        #region   \n        public static Complex operator - (Complex c1, Complex c2)\n        {\n            return new Complex (c1.Real - c2.Real, c1.Imag - c2.Imag);\n        }\n \n        public static Complex operator - (Complex c1, double c2)\n        {\n            return new Complex (c1.Real - c2, c1.Imag);\n        }\n \n        public static Complex operator - (double  c1, Complex c2)\n        {\n            return new Complex (c1 - c2.Real, -c2.Imag);\n        }\n        #endregion\n \n \n        #region   \n        public static Complex operator * (Complex c1, Complex c2)\n        {\n            return new Complex (c1.Real * c2.Real - c1.Imag * c2.Imag,\n                c1.Real * c2.Imag + c1.Imag * c2.Real);\n        }\n \n        public static Complex operator * (Complex c1, double c2)\n        {\n            return new Complex (c1.Real * c2, c1.Imag * c2);\n        }\n \n        public static Complex operator * (double c1, Complex c2)\n        {\n            return new Complex (c1 * c2.Real, c1 * c2.Imag);\n        }\n        #endregion\n \n \n        #region   \n        public static Complex operator / (Complex c1, Complex c2)\n        {\n            double Denominator = c2.Real * c2.Real + c2.Imag * c2.Imag;\n            return new Complex ((c1.Real * c2.Real + c1.Imag * c2.Imag) / Denominator,\n                (c2.Real * c1.Imag - c2.Imag * c1.Real) / Denominator);\n        }\n \n        public static Complex operator / (Complex c1, double c2)\n        {\n            return new Complex (c1.Real / c2, c1.Imag / c2);\n        }\n \n        public static Complex operator / (double c1, Complex c2)\n        {\n            double Denominator = c2.Real * c2.Real + c2.Imag * c2.Imag;\n            return new Complex ((c1 * c2.Real) / Denominator, (-c2.Imag * c1) / Denominator);\n        }\n        #endregion\n \n        public static bool operator == (Complex c1, Complex c2)\n        {\n            return c1.Real == c2.Real && c1.Imag == c2.Imag;\n        }\n \n        public static bool operator != (Complex c1, Complex c2)\n        {\n            return c1.Real != c2.Real || c1.Imag != c2.Imag;\n        }\n \n        public override bool Equals(object obj)\n        {\n            return this == (Complex)obj;\n        }\n \n        public override int GetHashCode()\n        {\n            return m_real.GetHashCode() + m_imag.GetHashCode();\n        }\n \n \n        #region ICloneable Members\n \n        public object Clone()\n        {\n            return new Complex (this.m_real, this.m_imag);\n        }\n \n        #endregion\n    }",
 "title": "Dmitriy Sitnikov"
}