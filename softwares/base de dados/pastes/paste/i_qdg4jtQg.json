{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en",
  "kw_pass"
 ],
 "key": "qdg4jtQg",
 "pasteDate": "Feb 25, 2018, 11:35:13 PM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "tinymembench v0.4.9 (simple benchmark for memory throughput and latency)\n\n==========================================================================\n== Memory bandwidth tests                                               ==\n==                                                                      ==\n== Note 1: 1MB = 1000000 bytes                                          ==\n== Note 2: Results for 'copy' tests show how many bytes can be          ==\n==         copied per second (adding together read and writen           ==\n==         bytes would have provided twice higher numbers)              ==\n== Note 3: 2-pass copy means that we are using a small temporary buffer ==\n==         to first fetch data into it, and only then write it to the   ==\n==         destination (source -> L1 cache, L1 cache -> destination)    ==\n== Note 4: If sample standard deviation exceeds 0.1%, it is shown in    ==\n==         brackets                                                     ==\n==========================================================================\n\n C copy backwards                                     :   1626.6 MB/s (2.6%)\n C copy backwards (32 byte blocks)                    :   1619.8 MB/s (2.1%)\n C copy backwards (64 byte blocks)                    :   1623.2 MB/s (2.4%)\n C copy                                               :   1634.7 MB/s (1.4%)\n C copy prefetched (32 bytes step)                    :   1142.4 MB/s (3.3%)\n C copy prefetched (64 bytes step)                    :   1076.1 MB/s (0.1%)\n C 2-pass copy                                        :   1289.4 MB/s\n C 2-pass copy prefetched (32 bytes step)             :    928.6 MB/s\n C 2-pass copy prefetched (64 bytes step)             :   1044.8 MB/s (0.2%)\n C fill                                               :   5389.0 MB/s\n C fill (shuffle within 16 byte blocks)               :   5391.8 MB/s\n C fill (shuffle within 32 byte blocks)               :   5391.1 MB/s\n C fill (shuffle within 64 byte blocks)               :   5391.7 MB/s\n ---\n standard memcpy                                      :   1718.7 MB/s (0.3%)\n standard memset                                      :   5406.8 MB/s\n ---\n NEON LDP/STP copy                                    :   1734.8 MB/s (0.5%)\n NEON LDP/STP copy pldl2strm (32 bytes step)          :   1055.0 MB/s (0.8%)\n NEON LDP/STP copy pldl2strm (64 bytes step)          :   1313.6 MB/s (0.4%)\n NEON LDP/STP copy pldl1keep (32 bytes step)          :   1866.2 MB/s\n NEON LDP/STP copy pldl1keep (64 bytes step)          :   1868.8 MB/s\n NEON LD1/ST1 copy                                    :   1681.0 MB/s (0.7%)\n NEON STP fill                                        :   5405.0 MB/s\n NEON STNP fill                                       :   5296.7 MB/s (0.1%)\n ARM LDP/STP copy                                     :   1717.2 MB/s (0.3%)\n ARM STP fill                                         :   5407.0 MB/s\n ARM STNP fill                                        :   5294.4 MB/s (0.3%)\n\n==========================================================================\n== Memory latency test                                                  ==\n==                                                                      ==\n== Average time is measured for random memory accesses in the buffers   ==\n== of different sizes. The larger is the buffer, the more significant   ==\n== are relative contributions of TLB, L1/L2 cache misses and SDRAM      ==\n== accesses. For extremely large buffer sizes we are expecting to see   ==\n== page table walk with several requests to SDRAM for almost every      ==\n== memory access (though 64MiB is not nearly large enough to experience ==\n== this effect to its fullest).                                         ==\n==                                                                      ==\n== Note 1: All the numbers are representing extra time, which needs to  ==\n==         be added to L1 cache latency. The cycle timings for L1 cache ==\n==         latency can be usually found in the processor documentation. ==\n== Note 2: Dual random read means that we are simultaneously performing ==\n==         two independent memory accesses at a time. In the case if    ==\n==         the memory subsystem can't handle multiple outstanding       ==\n==         requests, dual random read has the same timings as two       ==\n==         single reads performed one after another.                    ==\n==========================================================================\n\nblock size : single random read / dual random read, [MADV_NOHUGEPAGE]\n      1024 :    0.0 ns          /     0.0 ns \n      2048 :    0.0 ns          /     0.0 ns \n      4096 :    0.0 ns          /     0.0 ns \n      8192 :    0.0 ns          /     0.0 ns \n     16384 :    0.0 ns          /     0.0 ns \n     32768 :    0.0 ns          /     0.1 ns \n     65536 :    6.8 ns          /    11.5 ns \n    131072 :   10.4 ns          /    15.9 ns \n    262144 :   12.3 ns          /    17.7 ns \n    524288 :   14.2 ns          /    19.9 ns \n   1048576 :   83.9 ns          /   127.2 ns \n   2097152 :  121.5 ns          /   162.2 ns \n   4194304 :  148.8 ns          /   185.5 ns \n   8388608 :  163.7 ns          /   197.5 ns \n  16777216 :  173.0 ns          /   206.5 ns \n  33554432 :  177.5 ns          /   212.7 ns \n  67108864 :  181.1 ns          /   217.3 ns \n\nblock size : single random read / dual random read, [MADV_HUGEPAGE]\n      1024 :    0.0 ns          /     0.0 ns \n      2048 :    0.0 ns          /     0.0 ns \n      4096 :    0.0 ns          /     0.0 ns \n      8192 :    0.0 ns          /     0.0 ns \n     16384 :    0.0 ns          /     0.0 ns \n     32768 :    0.0 ns          /     0.1 ns \n     65536 :    6.8 ns          /    11.6 ns \n    131072 :   10.4 ns          /    16.2 ns \n    262144 :   12.2 ns          /    18.2 ns \n    524288 :   14.2 ns          /    19.9 ns \n   1048576 :   83.8 ns          /   127.2 ns \n   2097152 :  121.0 ns          /   161.6 ns \n   4194304 :  139.5 ns          /   173.0 ns \n   8388608 :  149.4 ns          /   177.3 ns \n  16777216 :  154.7 ns          /   179.1 ns \n  33554432 :  157.2 ns          /   179.8 ns \n  67108864 :  158.5 ns          /   180.2 ns",
 "title": ""
}