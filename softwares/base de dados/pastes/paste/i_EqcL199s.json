{
 "espireDate": "N",
 "format": "cpp",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "EqcL199s",
 "pasteDate": "Feb 8, 2018, 3:17:07 AM",
 "relevancy": 2.0,
 "relevant": false,
 "text": "/******************************************************************************/\n/*!\n\\file   List.cpp\n\\author Jake Ryan\n\\par    email: jake.ryan\\@digipen.edu\n\\par    DigiPen login: jake.ryan\n\\par    Course: CS170\n\\par    Section B\n\\par    Lab #4\n\\date   2/07/2018\n\\brief  \n  This is the interface file that allows the user to manipulate\n  linked lists in various ways.\n  \n*/\n/******************************************************************************/\n\n#include <iostream> // cout, endl\n#include \"List.h\"\n\nnamespace CS170\n{\n  namespace ListLab\n  {\n    namespace \n    {\n      struct Node* MakeNode(int value)\n      {\n        struct Node *pNode = new Node; // Allocate memory\n        pNode->number = value;         // Set number\n        pNode->next = 0;               // Set next (no next yet)\n\n        return pNode;\n      }\n    }\n\n/******************************************************************************/\n    /*!\n      \\brief\n        Prints all of the nodes' values in a list.\n      \n      \\param list\n        Pointer to the first node in a list.\n    */\n/******************************************************************************/\n    void PrintList(struct Node *list)\n    {\n      while (list)\n      {\n        std::cout << list->number << \"   \";\n        list = list->next;\n      }\n      std::cout << std::endl;\n    }\n\n/******************************************************************************/\n    /*!\n      \\brief\n        Prints all of the nodes' values in a list.\n      \n      \\param list\n        Pointer to the first node in a list.\n    */\n/******************************************************************************/\n    int Count(struct Node *list)\n    {\n      int count = 0; // Number of nodes in the list\n      \n      while (list)\n      {\n        count++;\n        list = list->next;\n      }\n      \n      return count;\n    }\n    \n      // Adds a node to the end of the list\n    void AddToEnd(Node **pList, int value)\n    {\n      if (pList && *pList) //verify both pointers\n      {\n        struct Node * pNode = *pList; \n        struct Node * backNode = MakeNode(value);\n\n        while (pNode->next) //as long as the list continues, set each next node\n        {\n          pNode = pNode->next;\n        }\n\n        backNode->number = value;\n        backNode->next = NULL;\n        pNode->next = backNode;\n      } \n      else\n      {\n        AddToFront(pList, value);\n      }\n    }\n    \n      // Adds a node to the front of the list\n    void AddToFront(Node **pList, int value)\n    {\n      struct Node * frontNode = MakeNode(value);\n      frontNode->next = *pList;\n      *pList = frontNode;\n    }\n    \n      // Finds an item and returns the node that contains it\n    Node *FindItem(Node *list, int value)\n    {\n      \n      while(list)\n      {\n        if (list->number == value)\n        {\n          return list; //returns the node with the correct value\n        }\n          list = list->next;\n      }\n      \n      return NULL; //if the item could not be found, return null pointer\n    }\n    \n      // Frees (deletes) all of the nodes in the list\n    void FreeList(Node *pList)\n    {\n      struct Node * newPList = pList;\n\n      while (newPList)\n      {\n        struct Node *temp = newPList->next;\n        delete newPList;\n        newPList = temp;\n      }\n    }\n    \n/******************************************************************************/\n    /*!\n      \\brief\n        Inserts a new node at the specified position.\n      \n      \\param pList\n        Pointer to a list.\n        \n      \\param value\n        \n    */\n/******************************************************************************/\n    void Insert(Node **pList, int value, int position)\n    {\n      struct Node *newNode = MakeNode(value);\n      struct Node **temp = pList;\n      \n      if (position == 0) //call AddToFront if position = 0\n      {\n        AddToFront(pList, value);\n      }\n      \n      for (int i = 0; i < position; i++)\n      {\n        if ((*temp)->next) //ensure that a node exists to move to\n        {\n          if (!(*temp)->next)\n          {\n            return;\n          }\n          *temp = (*temp)->next;\n        }\n      }\n      \n        newNode->next = (*temp)->next; //set where newNode points first\n        (*temp)->next = newNode; //then set where pList is pointing\n      \n      \n    }\n\n\n  } // namespace ListLab\n} // namespace CS170",
 "title": ""
}