{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_fr"
 ],
 "key": "WhCVaeRp",
 "pasteDate": "Feb 11, 2018, 10:22:41 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "/**\n * Un encodeur selon le principe du dcalage circulaire (aussi appel technique\n *  de \"Csar\").\n * La mthode <code>getEncryptedText</code> permet d'encoder un message\n *  (dcalage  droite) ou de le dcoder (dcalage  gauche) selon la valeur\n *  actuelle du dcalage.\n * @inv\n *     -ALPHABET_SIZE < getShift() < ALPHABET_SIZE\n *     forall m:String :\n *         getEncryptedText(m) != null\n *         getEncryptedText(m).length() == message.length()\n *         forall i:[0..m.length()[ :\n *             Soit ci ::= m.charAt(i)\n *                  xi ::= getEncryptedText(m).charAt(i)\n *             ci est une lettre non accentue, minuscule ou majuscule\n *                 ==> xi == ci dcal de getShift()\n *             ci est une lettre accentue ou n'est pas une lettre\n *                 ==> xi == ci\n */\npublic class SubstCipher {\n    \n    // CONSTANTES\n    \n    /**\n     * Taille de l'alphabet.\n     */\n    public static final int ALPHABET_SIZE = 26;\n    \n    /**\n     * Caractre (minuscule) le plus frquent en franais (et en anglais).\n     */\n    public static final char MOST_FREQUENT_CHAR = 'e';\n    \n    // ATTRIBUTS\n    \n    private int currentShift;\n    \n    // CONSTRUCTEURS\n    \n    /**\n     * Un encodeur de dcalage 0 (ie. l'identit).\n     * @post\n     *     getShift() == 0\n     */\n    public SubstCipher() {\n        currentShift = 0;\n    }\n    \n    /**\n     * Un encodeur de dcalage <code>shift</code>.\n     * @pre\n     *     -ALPHABET_SIZE < shift < ALPHABET_SIZE\n     * @post\n     *     getShift() == shift\n     */\n    public SubstCipher(int shift) {\n        currentShift = shift;\n    }\n    \n    /**\n     * Un encodeur avec un dcalage tel que la lettre la plus frquente de la\n     *  langue est dcale vers la lettre la plus frquente du message\n     *  <code>cipherText</code>.\n     * Si <code>cipherText</code> est la chane vide retourne un dcodeur\n     *  de dcalage 0.\n     * Sinon :\n     * <ul>\n     *   <li>calcule la lettre la plus frquente de\n     *       <code>cipherText</code> ;</li>\n     *   <li>adapte le dcalage de cet encodeur de sorte que MOST_FREQUENT_CHAR\n     *       soit encod par cette lettre.</li>\n     * </ul>\n     * @pre\n     *     cipherText != null\n     * @post\n     *     cipherText.equals(\"\") ==> getShift() == 0\n     *     !cipherText.equals(\"\")\n     *         ==> getShift() est tel que\n     *             getEncryptedText(String.valueOf(MOST_FREQUENT_CHAR))\n     *             retourne la chane constitue de la lettre la plus frquente\n     *             dans <code>cipherText</code>\n     */\n    public SubstCipher(String cipherText) {\n        currentShift = guessShiftFrom(cipherText);\n    }\n\n    // REQUETES\n    \n    /**\n     * Construit une chane  partir de celle fournie en paramtre en dcalant\n     *  circulairement les caractres alphabtiques selon le dcalage donn par\n     *  <code>getShift()</code>.\n     * Le dcalage se fait  droite si <code>getShift() &geq; 0</code>, ou\n     *   gauche si <code>getShift() &lt; 0</code>.\n     * @pre\n     *     text != null\n     */\n    public String getEncryptedText(String text) {\n        char[] textChar = text.toCharArray();\n        if (getShift() >= 0) {\n            for(int k = 0; k < text.length(); k++) {\n                if (textChar[k] >= 'a' && textChar[k] <= 'z') {\n                    textChar[k] = (char) (textChar[k] + getShift());\n                    if (textChar[k] > 'z') {\n                        textChar[k] = (char) (textChar[k] - 'z' + 'a' - 1);   \n                    }\n                } else if (textChar[k] >= 'A' && textChar[k] <= 'Z') {\n                    textChar[k] = (char) (textChar[k] + getShift());\n                    if (textChar[k] > 'Z') {\n                        textChar[k] = (char) (textChar[k] - 'Z' + 'A' - 1);   \n                    }\n                }\n            }\n        } else {\n            for(int k = 0; k < text.length(); k++) {\n                if (textChar[k] >= 'a' && textChar[k] <= 'z') {\n                    textChar[k] = (char) (textChar[k] - getShift());\n                    if (textChar[k] < 'a') {\n                        textChar[k] = (char) (textChar[k] + 'z' - 'a');   \n                    }\n                } else if (textChar[k] >= 'A' && textChar[k] <= 'Z') {\n                    textChar[k] = (char) (textChar[k] - getShift());\n                    if (textChar[k] < 'A') {\n                        textChar[k] = (char) (textChar[k] + 'Z' - 'A');   \n                    }\n                }\n            }\n        }\n        return String.valueOf(textChar);\n    }\n    \n    /**\n     * Le dcalage courant de cet encodeur.\n     */\n    public int getShift() {\n        return currentShift;\n    }\n    \n    // COMMANDES\n    \n    /**\n     * Affecte un nouveau dcalage  l'encodeur.\n     * @pre\n     *     -ALPHABET_SIZE < shift < ALPHABET_SIZE\n     * @post\n     *     getShift() == shift\n     */\n    public void setShift(int shift) {\n        currentShift = shift;\n    }\n    \n    /**\n     * Configure cet encodeur pour un encodage.\n     * @post\n     *     getShift() == +abs(old getShift())\n     */\n    public void ensurePositiveShift() {\n       if (getShift() < 0) {\n           currentShift = - currentShift;\n       }\n    }\n    \n    /**\n     * Configure cet encodeur pour un dcodage.\n     * @post\n     *     getShift() == -abs(old getShift())\n     */\n    public void ensureNegativeShift() {\n        if (getShift() > 0) {\n           currentShift = - currentShift;\n       }\n    }\n    \n    // OUTILS\n    \n    /**\n     * Une reprsentation sous forme de chane de cet encodeur.\n     * La valeur retourne est de la forme :\n     *     <code>\"SubstCipher[shift:\" + getShift() + \"]\"</code>.\n     */\n    public String toString() {\n        return \"SubstCipher[shift:\" + getShift() + \"]\";\n    }\n    \n    /**\n     * Indique si c est une lettre minuscule ou majuscule non accentue.\n     * @post\n     *     result <==> c est une lettre non accentue.\n     */\n    private static boolean isNonAccentedLetter(char c) {\n        return (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z'));\n    }\n    \n    /**\n     * Calcule un dcalage  partir du message donn en paramtre selon\n     *  l'algorithme qui suit.\n     * <ul>\n     *   <li>compter l'occurrence de chaque lettre non accentue (minuscule ou\n     *       majuscule) du message ;</li>\n     *   <li>dterminer un dcalage pour encoder MOST_FREQUENT_CHAR par la\n     *       lettre apparaissant le plus souvent dans le message.</li>\n     * </ul>\n     * En cas d'galit de frquence de plusieurs lettres du message, la plus\n     *  petite parmi ces lettres (pour l'ordre alphabtique) est retourne.\n     * Pour un message chiffr gal  la chane vide, la valeur retourne est 0.\n     * @pre\n     *     text != null\n     * @post\n     *     text.equals(\"\") ==> result == 0\n     *     !text.equals(\"\")\n     *         ==> Soit f ::= la lettre la plus frquente du message\n     *             result ==\n     *                     ((f - MOST_FREQUENT_CHAR) + ALPHABET_SIZE)\n     *                     % ALPHABET_SIZE\n     */\n    private int guessShiftFrom(String text) {\n        if (text == null) {\n            throw new AssertionError();\n        }\n        \n        if (text.equals(\"\")) {\n            return 0;\n        }\n        return guessShiftFromNonEmptyMessage(text);\n    }\n    \n    private int guessShiftFromNonEmptyMessage(String text) {\n        assert text != null && !text.equals(\"\");\n        int[] occurence = new int[26];\n        char[] cipherTextChar = text.toCharArray();\n        for(int k = 0; k < text.length(); k++) {\n             if (cipherTextChar[k] >= 'a' && cipherTextChar[k] <= 'z') {\n                 occurence[cipherTextChar[k] - 'a'] += 1 ;\n             } else if (cipherTextChar[k] >= 'A' \n             && cipherTextChar[k] <= 'Z') {\n                 occurence[cipherTextChar[k] - 'A'] += 1 ;\n             }\n        }\n        char encryptedMFC = (char)(getIndexOfLargest(occurence) + 'a');\n        return MOST_FREQUENT_CHAR - encryptedMFC;\n    }\n    \n    /**\n     * Le caractre c encod (dcalage  droite si shift positif) ou dcod\n     *  (dcalage  gauche si shift ngatif).\n     * @pre\n     *     isNonAccentedLetter(c)\n     * @post\n     *     currentShift >= 0\n     *         ==> result == encod de c\n     *     currentShift < 0\n     *         ==> result == dcod de c\n     */\n    private char encryptChar(char c) {\n        return (char) (c + currentShift);\n    }\n    \n    /**\n     * Retourne l'indice de la valeur max d'un tableau de int\n     */\n    private int getIndexOfLargest(int[] array){\n        int largest = 0;\n        for (int i = 1; i < array.length; i++){\n           if (array[i] > array[largest]) {\n               largest = i;\n           }\n        }\n        return largest; // position of the first largest found\n    }\n}",
 "title": ""
}