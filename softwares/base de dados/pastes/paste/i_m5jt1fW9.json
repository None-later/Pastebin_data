{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "m5jt1fW9",
 "pasteDate": "Feb 20, 2018, 1:32:17 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "func update(buffer:CVPixelBuffer, timestamp:Double, scene:SCNScene) {\n        \n        if (timestamp == self.lastTimestamp) { return }\n        self.lastTimestamp = timestamp\n        \n        // Wait to ensure only kMaxBuffersInFlight are getting proccessed by any stage in the Metal\n        //   pipeline (App, Metal, Drivers, GPU, etc)\n        let _ = inFlightSemaphore.wait(timeout: DispatchTime.distantFuture)\n        \n        // Create a new command buffer for each renderpass to the current drawable\n        if let commandBuffer = commandQueue.makeCommandBuffer() {\n            commandBuffer.label = \"MyCommand\"\n            \n            // Add completion hander which signal _inFlightSemaphore when Metal and the GPU has fully\n            //   finished proccssing the commands we're encoding this frame.  This indicates when the\n            //   dynamic buffers, that we're writing to this frame, will no longer be needed by Metal\n            //   and the GPU.\n            // Retain our CVMetalTextures for the duration of the rendering cycle. The MTLTextures\n            //   we use from the CVMetalTextures are not valid unless their parent CVMetalTextures\n            //   are retained. Since we may release our CVMetalTexture ivars during the rendering\n            //   cycle, we must retain them separately here.\n            var textures = [capturedImageTextureY, capturedImageTextureCbCr]\n            commandBuffer.addCompletedHandler{ [weak self] commandBuffer in\n                \n                \n                if let texture = self?.renderPassDescriptor.colorAttachments[0].texture {\n                    scene.background.contents = texture\n                }\n                \n                if let strongSelf = self {\n                    strongSelf.inFlightSemaphore.signal()\n                }\n                textures.removeAll()\n            }\n            \n            // Update the location(s) to which we'll write to in our dynamically changing Metal buffers for\n            //   the current frame (i.e. update our slot in the ring buffer used for the current frame)\n            uniformBufferIndex = (uniformBufferIndex + 1) % kMaxBuffersInFlight\n            sharedUniformBufferOffset = kAlignedSharedUniformsSize * uniformBufferIndex\n            sharedUniformBufferAddress = sharedUniformBuffer.contents().advanced(by: sharedUniformBufferOffset)\n            \n            \n            // Update any game state\n            updateSharedUniforms()\n            updateCapturedImageTextures(pixelBuffer:buffer)\n            \n            var rawData0 = [UInt8](repeating: 0, count: Int(resX) * Int(resY) * 4)\n            \n            let bytesPerRow = 4 * Int(resX)\n            let textureDescriptor = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: MTLPixelFormat.bgra8Unorm, width: Int(resX), height: Int(resY), mipmapped: true)\n            \n            textureDescriptor.usage = .renderTarget\n            textureDescriptor.storageMode = .private\n            \n            let textureA = device.makeTexture(descriptor: textureDescriptor)\n            \n            let region = MTLRegionMake2D(0, 0, Int(resX), Int(resY))\n            textureA?.replace(region: region, mipmapLevel: 0, withBytes: &rawData0, bytesPerRow: Int(bytesPerRow))\n            \n            \n            renderPassDescriptor.colorAttachments[0].texture = textureA \n            renderPassDescriptor.colorAttachments[0].loadAction = .clear\n            renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.0)\n            renderPassDescriptor.colorAttachments[0].storeAction = .store\n            \n            \n            \n            \n            \n            \n           \n             if let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor)\n             {\n                  renderEncoder.label = \"MyRenderEncoder\"\n                  drawCapturedImage(renderEncoder: renderEncoder)\n                  renderEncoder.endEncoding()\n             }\n                    \n                \n                // We're done encoding commands\n                \n                \n                \n             \n            // Finalize rendering here & push the command buffer to the GPU\n            commandBuffer.commit()\n            \n        }\n    }",
 "title": ""
}