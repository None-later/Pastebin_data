{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "VYe70N0v",
 "pasteDate": "Feb 11, 2018, 5:58:39 PM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "    private void move() {\n        Trajectory<? super PacketEntity> traj = this.trajectory.get();\n        Object ent = this.mounted.get();\n        Vector raw = this.velocity.clone();\n        boolean flying = this.flying.get();\n        double drag = 1D - this.drag.get();\n        if (drag != 1D) {\n            //apply drag\n            raw.multiply(drag);\n        }\n        if (!flying) {\n            //add gravity\n            raw.setY(raw.getY() - this.gravity.get());\n        }\n        if (traj != null) {\n            Vector back = traj.next(this, 0, raw);\n            if (Thread.currentThread().isInterrupted()) {\n                return;\n            }\n            if (back != null) {\n                raw = back;\n                this.velocity.setX(raw.getX());\n                this.velocity.setY(raw.getY());\n                this.velocity.setZ(raw.getZ());\n            }\n        }\n        if (ent instanceof Player && this.data().local().isSteerable((Player) ent)) {\n            //account for passenger input\n            double forward = this.passengerForwardMove.get();\n            double left = this.passengerLeftMove.get();\n            double vert = !flying ? 0D : this.passengerVertMove.get();\n            if (forward != 0D || left != 0D || vert != 0D) {\n                Vector movement = new Vector(left, vert, forward); //normally this'd be -left, but NOTCH\n                Vectors.rotateY(movement, (float) Math.toRadians(((Player) ent).getLocation().getYaw()));\n                movement.normalize().multiply(flying ? this.flySpeed.get() : this.walkSpeed.get());\n                if (this.passengerJump.getAndSet(false)) { //TODO: onground and flying check\n                    if (!Vectors.isOnGround(this.getLocation())) {\n                        System.err.println(\"Entity jump called for \" + this.getEntityID() + \" while midair\");\n                    } else {\n                        movement.setY(JUMP_HEIGHT);\n                    }\n                }\n                raw.add(movement);\n                //changeVel = true;\n            }\n        }\n        if (this.doesBlockCollide.get()) {\n            if (this.world == null) {\n                System.err.println(\"Null world in block collision check for entity \" + this.entityID + \"!\");\n            } else {\n                //TODO: do lookahead for block collision\n                //BlockIterator itr = new BlockIterator(this.world, this.position.clone(), raw.clone().normalize(), 0, raw.length());\n            }\n        }\n        this.move(raw, ent);\n    }",
 "title": ""
}