{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "kw_error",
  "lg_en"
 ],
 "key": "7YSym4jx",
 "pasteDate": "Feb 8, 2018, 3:56:38 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "% Dead Reckoning with Khepera Mini Robot\n%\n% Ola Bengtsson, 2004.02.06\n%\n\nclear all;\nclose all;\nclc;\n\n% %%% Khepera settings \nWHEEL_BASE = 45;                % [mm]\nWHEEL_DIAMETER = 14;          % [mm]\nPULSES_PER_REVOLUTION = 600;    %\nMM_PER_PULSE = 0;               % [mm / pulse]\n\ncircumference = pi * WHEEL_DIAMETER; % circumference in [mm]\n\nMM_PER_PULSE = circumference/PULSES_PER_REVOLUTION; % You should write the correct one, which replaces the one above!\n\n\n% %%% Uncertainty settings, which are be the same for the left and right encoders\nSIGMA_WHEEL_ENCODER = 0.5/12;   % The error in the encoder is 0.5mm / 12mm travelled\n% Use the same uncertainty in both of the wheel encoders\nSIGMAl = SIGMA_WHEEL_ENCODER;\nSIGMAr = SIGMA_WHEEL_ENCODER;\n\n\n% Load encoder values\nENC = load('khepera_circle.dat');\n\n\n% Transform encoder values (pulses) into distance travelled by the wheels (mm)\nDr = ENC(1:1:end,2) * MM_PER_PULSE;\nDl = ENC(1:1:end,1) * MM_PER_PULSE;\nN = max(size(Dr));\n\n% Init Robot Position, i.e. (0, 0, 90*pi/180) and the Robots Uncertainty\nX(1) = 0;\nY(1) = 0;\nA(1) = 90*pi/180;\nP(1,1:9) = [1 0 0 0 1 0 0 0 (1*pi/180)^2];\n\n% Run until no more encoder values are available\ndisp('Calculating ...');\nfor kk=2:N\n    % Change of wheel displacements, i.e displacement of left and right wheels\n    dDr = Dr(kk) - Dr(kk-1);\n    dDl = Dl(kk) - Dl(kk-1);\n\n    % Change of relative movements dD = displacements in distans, %dA\n    % vinkeln som roboten har vinklat sig\n    \n    %dD = 0;\n    %dA = 0.017;\n    dD =  (dDr + dDl)/2;   % You should write the correct one, which replaces the one above!\n    dA = (dDr - dDl)/WHEEL_BASE;   % You should write the correct one, which replaces the one above!\n    \n    %compT = 1\n    compT = (sin(dA/2)/(dA/2));\n    % Calculate the change in X and Y (World co-ordinates)\n    dX = compT*dD*cos(A(kk-1)+(dA/2));\n    dY = compT*dD*sin(A(kk-1)+(dA/2));\n    % Predict the new state variables (World co-ordinates)\n    X(kk) = X(kk-1) + dX;\n    Y(kk) = Y(kk-1) + dY;\n    A(kk) = mod(A(kk-1) + dA, 2*pi);\n    \n    % Predict the new uncertainty in the state variables (Error prediction)\n    Cxya_old = [P(kk-1,1:3);P(kk-1,4:6);P(kk-1,7:9)];   % Uncertainty in state variables at time k-1 [3x3]    \n\n    sigmaD = (SIGMAr^2+SIGMAl^2)/4;\n    sigmaA = (SIGMAr^2+SIGMAl^2)/(WHEEL_BASE^2);\n    Cu =   [sigmaD 0;0 sigmaA];               % Uncertainty in the input variables [2x2]\n    \n    xyaS = dD*sin(A(kk-1) + (dA/2));\n    xyaC = dD*cos(A(kk-1) + (dA/2));\n    Axya = [1 0 -xyaS;0 1 xyaC;0 0 1];     % Jacobian matrix w.r.t. X, Y and A [3x3]\n    \n    AuW = (dD/(2*WHEEL_BASE));\n    AuC = cos(A(kk-1) + (dA/2));\n    AuS = sin(A(kk-1) + (dA/2));\n        \n    Au =   [(1/2)*AuC-AuW*AuS (1/2)*AuC+AuW*AuS;\n            (1/2)*AuS+AuW*AuC (1/2)*AuS-AuW*AuC;\n            (1/WHEEL_BASE) -(1/WHEEL_BASE)];           % Jacobian matrix w.r.t. dD and dA [3x2]    \n    % Use the law of error predictions, which gives the new uncertainty\n    jxS = ((dDr + dDl)/2)*sin(A(kk-1) + ((dDr - dDl)/(2*WHEEL_BASE)));\n    jxC = ((dDr + dDl)/2)*cos(A(kk-1) + ((dDr - dDl)/(2*WHEEL_BASE)));\n\n    Jx = [1 0 -jxS;\n          0 1 JxC;\n          0 0 1];\n      \n    jb = [ dot(((dDr + dDl)/2), ((dDr + dDl)/(2*WHEEL_BASE^2))*sin(A(kk-1) + ((dDr - dDl)/(2*WHEEL_BASE))));\n           dot(-((dDr + dDl)/2), ((dDr + dDl)/(2*WHEEL_BASE^2))*cos(A(kk-1) + ((dDr - dDl)/(2*WHEEL_BASE))));\n           -(dDr-dDl)/WHEEL_BASE^2\n        ];\n    \n    Cxya_new = Axya*Cxya_old*Axya' + Au*Cu*Au' + Jb*Jx*Jb';\n    \n    % Store the new co-variance matrix\n    P(kk,1:9) = [Cxya_new(1,1:3) Cxya_new(2,1:3) Cxya_new(3,1:3)];\nend;\n\n\ndisp('Plotting ...');\n\n% Plot the path taken by the robot, by plotting the uncertainty in the current position\nfigure; \n    %plot(X, Y, 'b.');\n    title('Path taken by the robot [Wang]');\n    xlabel('X [mm] World co-ordinates');\n    ylabel('Y [mm] World co-ordinates');\n    hold on;\n        for kk = 1:1:N,\n            C = [P(kk,1:3);P(kk,4:6);P(kk,7:9)];\n            plot_uncertainty([X(kk) Y(kk) A(kk)]', C, 1, 2);\n        end;\n    hold off;\n    axis('equal');\n\n% After the run, plot the results (X,Y,A), i.e. the estimated positions \nfigure;\n    subplot(3,1,1); plot(X, 'b'); title('X [mm]');\n    subplot(3,1,2); plot(Y, 'b'); title('Y [mm]');\n    subplot(3,1,3); plot(A*180/pi, 'b'); title('A [deg]');\n\n% Plot the estimated variances (in X, Y and A) - 1 standard deviation\nsubplot(3,1,1); hold on;\n    plot(X'+sqrt(P(:,1)), 'b:');\n    plot(X'-sqrt(P(:,1)), 'b:');\nhold off;\nsubplot(3,1,2); hold on;\n    plot(Y'+sqrt(P(:,5)), 'b:');\n    plot(Y'-sqrt(P(:,5)), 'b:');\nhold off;\nsubplot(3,1,3); hold on;\n    plot((A'+sqrt(P(:,9)))*180/pi, 'b:');\n    plot((A'-sqrt(P(:,9)))*180/pi, 'b:');\nhold off;",
 "title": ""
}