{
 "espireDate": "N",
 "format": "cpp",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "EXAn7RiG",
 "pasteDate": "Feb 8, 2018, 3:44:59 PM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "// MergeSort.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include \"stdafx.h\"\n#include \"mpi.h\"\n#include <iostream>\n#include <vector>\n#include <time.h>\n#include <stdint.h>\n\nusing namespace std;\n\nconst int tagSize = 1;\nconst int tagData = 2;\nconst int tagResult = 3;\n\n\n\nvoid generate(vector<int>& v, size_t n) {\n\tv.reserve(n);\n\tfor (size_t i = 0; i < n; ++i) {\n\t\tv.push_back((i * 101011) % 123456);\n\t}\n}\n\n\n\n\nbool isSorted(vector<int> const & v) {\n\tsize_t const n = v.size();\n\tfor (size_t i = 1; i < n; ++i) {\n\t\tif (v[i - 1] > v[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n//Local merging of sorted sequences.\n//Merges the sequences from begin1 to end1 with that from begin2 to end2.\n//The result is stored starting at merged(which must have enough space)\n\nvoid merge(int* begin1, int* end1, int* begin2, int* end2, int*merged) {\n\tint* curr1 = begin1;\n\tint* curr2 = begin2;\n\n\twhile (curr1 < end1 || curr2 < end2) {\n\t\tif (curr2 >= end2 || (curr1 < end1 && *curr1 < *curr2)) {\n\t\t\t*merged = *curr1;\n\t\t\t++curr1;\n\t\t}\n\t\telse {\n\t\t\t*merged = *curr2;\n\t\t\t++curr2;\n\t\t}\n\n\t\t++merged;\n\t}\n}\n\n\n//Recursively executes merge-sort for the sequence of sequence from in and of size n.\n//If nrProcs=1, all happens locally.\n//Otherwise, half of the input sequence is sent to a child process for sorting and the other half is sorted recursively calling mergeSortRec()\n\nvoid mergeSortRec(size_t n, int* in, size_t me, size_t nrProcs) {\n\t//in -  address of first element in vector of elements\n\n\t//if size of the array is <1 , exit\n\tif (n <= 1) {\n\t\treturn;\n\t}\n\n\tsize_t k = n / 2;\n\tif (nrProcs >= 2) {\n\t\tsize_t child = me + nrProcs / 2;\n\t\tint sizes[2];\n\t\tsizes[0] = n - k;\n\t\tsizes[1] = nrProcs - nrProcs / 2;\n\n\t\tcout << \"Worker \" << me << \", sending to child \" << child << \" , part size = \" << n - k << \", nrProcs = \" << sizes[1] << \"\\n\";\n\n\t\t//First send number of numbers to send and the number of processes that can be used by the child\n\t\tMPI_Send(sizes, 2, MPI_INT, child, tagSize, MPI_COMM_WORLD);\n\t\tMPI_Send(in + k, n - k, MPI_INT, child, tagData, MPI_COMM_WORLD);\n\t\tmergeSortRec(k, in, me, nrProcs / 2);\n\t\tMPI_Status status;\n\t\tMPI_Recv(in + k, n - k, MPI_INT, child, tagResult, MPI_COMM_WORLD, &status);\n\t\tcout << \"Worker \" << me << \", received from child \" << child << \", part size = \" << n - k << \"\\n\";\n\n\n\t}\n\telse {\n\t\t//if one process, perform local mergeSort(normal merge sort)\n\t\tmergeSortRec(k, in, me, 1);\n\t\tmergeSortRec(n - k, in + k, me, 1);\n\t}\n\n\tint* buf = new int[n];\n\t//in - start index of list1\n\t//in + k - start index of list2\n\tmerge(in, in + k, in + k, in + n, buf);\n\tfor (size_t i = 0; i < n; ++i) {\n\t\tin[i] = buf[i];\n\t}\n\tdelete[] buf;\n}\n\n\n//Called only by process 0.\nvoid mergeSort(vector<int> &v, size_t nrProcs) {\n\tmergeSortRec(v.size(), v.data(), 0, nrProcs);\n}\n\n\n\n//Main function to be executed on the worker.\n//It receives a vector from the parent, sorts it,\n//possibly by using subordinate processes, and sends the result back to the parent.\nvoid mergeWorker(size_t me) {\n\t//First, receive the number of numbers to sort and the numbers of sub-processes to use;\n\t//The sender is considered the parent.\n\tint sizes[2];\n\tMPI_Status status;\n\tMPI_Recv(sizes, 2, MPI_INT, MPI_ANY_SOURCE, tagSize, MPI_COMM_WORLD, &status);\n\n\tint parent = status.MPI_SOURCE;\n\tsize_t n = sizes[0];\n\tsize_t nrProcs = sizes[1];\n\tcout << \"Worker \" << me << \", child of \" << parent << \", part size = \" << n << \" , nrProcs = \" << nrProcs << \"\\n\";\n\n\t//Receive data from the parent\n\tvector<int> v;\n\tv.resize(n);\n\tMPI_Recv(v.data(), n, MPI_INT, parent, tagData, MPI_COMM_WORLD, &status);\n\tcout << \"Worker \" << me << \", received from parent \" << parent << \", part size = \" << n << \"\\n\";\n\n\t//Do the local sorting\n\tmergeSortRec(v.size(), v.data(), me, nrProcs);\n\n\t//Send back result to the parent\n\tcout << \"Worker \" << me << \", sending to parent \" << parent << \", part size = \" << n << \"\\n\";\n\tMPI_Ssend(v.data(), n, MPI_INT, parent, tagResult, MPI_COMM_WORLD);\n\n}\n\n\n\n\n\n\nint main(int argc, char *argv[])\n{\n\n\t//MPI_Init(&argc, &argv);\n\tMPI_Init(0, 0);\n\tint me;\n\tint nrProcs;\n\tMPI_Comm_size(MPI_COMM_WORLD, &nrProcs);\n\tMPI_Comm_rank(MPI_COMM_WORLD, &me);\n\n\tunsigned n;\n\tvector<int> v;\n\n\tif (argc != 2 || 1 != sscanf_s(argv[1], \"%u\", &n)) {\n\t\tfprintf(stderr, \"usage: mergesort <n>\\n\");\n\t\treturn 1;\n\t}\n\n\tif (me == 0) {\n\t\tgenerate(v, n);\n\t\tcout << \"Array Generated.\\n\";\n\t\tmergeSort(v, nrProcs);\n\t}\n\telse {\n\t\tmergeWorker(me);\n\t}\n\n\tif (me == 0) {\n\t\tcout << ((n == v.size() && isSorted(v)) ? \"OK!\" : \"Wrong!\") << \"\\n\";\n\t}\n\n\n\tMPI_Finalize();\n\treturn 0;\n}",
 "title": ""
}