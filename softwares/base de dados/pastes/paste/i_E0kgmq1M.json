{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "E0kgmq1M",
 "pasteDate": "Feb 26, 2018, 12:52:18 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "#include <stdio.h>\n\n#include \"lib.h\"\n\n\nint main(void) {\n    char *raw_request = \"GET / HTTP/1.1rn\"\n            \"Host: localhost:8080rn\"\n            \"Connection: keep-alivern\"\n            \"Upgrade-Insecure-Requests: 1rn\"\n            \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8rn\"\n            \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/604.5.6 (KHTML, like Gecko) Version/11.0.3 Safari/604.5.6rn\"\n            \"Accept-Language: en-usrn\"\n            \"DNT: 1rn\"\n            \"Accept-Encoding: gzip, deflatern\"\n            \"rn\"\n            \"Usually GET requests don't have a bodyrn\"\n            \"But I don't care in this case :)\";\n    struct Request *req = parse_request(raw_request);\n    if (req) {\n        printf(\"Method: %dn\", req->method);\n        printf(\"Request-URI: %sn\", req->url);\n        printf(\"HTTP-Version: %sn\", req->version);\n        puts(\"Headers:\");\n        struct Header *h;\n        for (h=req->headers; h; h=h->next) {\n            printf(\"%32s: %sn\", h->name, h->value);\n        }\n        puts(\"message-body:\");\n        puts(req->body);\n    }\n    free_request(req);\n    return 0;\n}\n\t\n#ifndef C11CODEREVIEW_LIB_H\n#define C11CODEREVIEW_LIB_H\n\ntypedef enum Method {UNSUPPORTED, GET, HEAD} Method;\n\ntypedef struct Header {\n    char *name;\n    char *value;\n    struct Header *next;\n} Header;\n\ntypedef struct Request {\n    enum Method method;\n    char *url;\n    char *version;\n    struct Header *headers;\n    char *body;\n} Request;\n\n\nstruct Request *parse_request(const char *raw);\nvoid free_header(struct Header *h);\nvoid free_request(struct Request *req);\n\n#endif //C11CODEREVIEW_LIB_H\n\t\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lib.h\"\n\nstruct Request *parse_request(const char *raw) {\n    struct Request *req = NULL;\n    req = malloc(sizeof(struct Request));\n    if (!req) {\n        return NULL;\n    }\n    memset(req, 0, sizeof(struct Request));\n\n    // Method\n    size_t meth_len = strcspn(raw, \" \");\n    if (memcmp(raw, \"GET\", strlen(\"GET\")) == 0) {\n        req->method = GET;\n    } else if (memcmp(raw, \"HEAD\", strlen(\"HEAD\")) == 0) {\n        req->method = HEAD;\n    } else {\n        req->method = UNSUPPORTED;\n    }\n    raw += meth_len + 1; // move past <SP>\n\n    // Request-URI\n    size_t url_len = strcspn(raw, \" \");\n    req->url = malloc(url_len + 1);\n    if (!req->url) {\n        free_request(req);\n        return NULL;\n    }\n    memcpy(req->url, raw, url_len);\n    req->url[url_len] = '\u0000';\n    raw += url_len + 1; // move past <SP>\n\n    // HTTP-Version\n    size_t ver_len = strcspn(raw, \"rn\");\n    req->version = malloc(ver_len + 1);\n    if (!req->version) {\n        free_request(req);\n        return NULL;\n    }\n    memcpy(req->version, raw, ver_len);\n    req->version[ver_len] = '\u0000';\n    raw += ver_len + 2; // move past <CR><LF>\n\n    struct Header *header = NULL, *last = NULL;\n    while (raw[0]!='r' || raw[1]!='n') {\n        last = header;\n        header = malloc(sizeof(Header));\n        if (!header) {\n            free_request(req);\n            return NULL;\n        }\n\n        // name\n        size_t name_len = strcspn(raw, \":\");\n        header->name = malloc(name_len + 1);\n        if (!header->name) {\n            free_request(req);\n            return NULL;\n        }\n        memcpy(header->name, raw, name_len);\n        header->name[name_len] = '\u0000';\n        raw += name_len + 1; // move past :\n        while (*raw == ' ') {\n            raw++;\n        }\n\n        // value\n        size_t value_len = strcspn(raw, \"rn\");\n        header->value = malloc(value_len + 1);\n        if (!header->value) {\n            free_request(req);\n            return NULL;\n        }\n        memcpy(header->value, raw, value_len);\n        header->value[value_len] = '\u0000';\n        raw += value_len + 2; // move past <CR><LF>\n\n        // next\n        header->next = last;\n    }\n    req->headers = header;\n    raw += 2; // move past <CR><LF>\n\n    size_t body_len = strlen(raw);\n    req->body = malloc(body_len + 1);\n    if (!req->body) {\n        free_request(req);\n        return NULL;\n    }\n    memcpy(req->body, raw, body_len);\n    req->body[body_len] = '\u0000';\n\n\n    return req;\n}\n\n\nvoid free_header(struct Header *h) {\n    if (h) {\n        free(h->name);\n        free(h->value);\n        free_header(h->next);\n        free(h);\n    }\n}\n\n\nvoid free_request(struct Request *req) {\n    free(req->url);\n    free(req->version);\n    free_header(req->headers);\n    free(req->body);\n    free(req);\n}\n\t\nif (!foo) {\n    free_request(req);\n    return NULL;\n}",
 "title": ""
}