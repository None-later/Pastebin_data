{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "kw_error",
  "lg_en"
 ],
 "key": "tMgcGfVt",
 "pasteDate": "Feb 20, 2018, 6:26:01 PM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "if (self.capturedVideos.count != 0) {        \n    //Create AVMutableComposition Object.This object will hold our multiple AVMutableCompositionTrack.\n    AVMutableComposition* mixComposition = [[AVMutableComposition alloc] init];\n\n    for (AVAsset *asset in self.capturedVideos) {\n        //check if the video is the first one captures so that it  is placed at time 0.\n        if ([self.capturedVideos indexOfObject:asset] == 0) {\n            AVMutableCompositionTrack *firstTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n            [firstTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset.duration) ofTrack:[[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] atTime:kCMTimeZero error:nil];\n            previousAsset = asset;\n        } else{\n            AVMutableCompositionTrack *track = [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n            [track insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset.duration) ofTrack:[[asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] atTime:previousAsset.duration error:nil];\n            previousAsset = asset;\n        }\n    }\n\n    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n    NSString *documentsDirectory = [paths objectAtIndex:0];\n    NSString *myPathDocs =  [documentsDirectory stringByAppendingPathComponent:\n    [NSString stringWithFormat:@\"mergeVideo-%d.mov\",arc4random() % 1000]];\n    NSURL *url = [NSURL fileURLWithPath:myPathDocs];\n    // 5 - Create exporter\n    AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mixComposition presetName:AVAssetExportPresetHighestQuality];\n    exporter.outputURL=url;\n    exporter.outputFileType = AVFileTypeQuickTimeMovie;\n    exporter.shouldOptimizeForNetworkUse = YES;\n    [exporter exportAsynchronouslyWithCompletionHandler:^{\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self exportDidFinish:exporter];\n        });\n    }];\n}\n\t\nAVMutableComposition *mainComposition = [[AVMutableComposition alloc] init];\n      AVMutableCompositionTrack *compositionVideoTrack = [mainComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];\n\n\n      AVMutableCompositionTrack *soundtrackTrack = [mainComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];\n      CMTime insertTime = kCMTimeZero;\n\n      for (AVAsset *videoAsset in assets) {\n\n          [compositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.duration) ofTrack:[[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0] atTime:insertTime error:nil];\n\n          [soundtrackTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.duration) ofTrack:[[videoAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0] atTime:insertTime error:nil];\n\n          // Updating the insertTime for the next insert\n          insertTime = CMTimeAdd(insertTime, videoAsset.duration);\n      }\n\n      NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\n      NSString *documentsDirectory = [paths objectAtIndex:0];\n\n      // Creating a full path and URL to the exported video\n      NSString *outputVideoPath =  [documentsDirectory stringByAppendingPathComponent:\n                              [NSString stringWithFormat:@\"mergeVideo-%d.mov\",arc4random() % 1000]];\n\n      // NSString *documentsDirectory = [paths objectAtIndex:0];\n      NSString *myPathDocs =  [documentsDirectory stringByAppendingPathComponent:\n                         current_name];\n      NSURL *outptVideoUrl = [NSURL fileURLWithPath:myPathDocs];\n      AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mainComposition presetName:AVAssetExportPreset640x480];\n\n      // Setting attributes of the exporter\n      exporter.outputURL=outptVideoUrl;\n      exporter.outputFileType =AVFileTypeMPEG4;   //AVFileTypeQuickTimeMovie;\n      exporter.shouldOptimizeForNetworkUse = YES;\n      [exporter exportAsynchronouslyWithCompletionHandler:^{\n          dispatch_async(dispatch_get_main_queue(), ^{\n              //completion(exporter);\n              [self exportDidFinish:exporter];\n              // [self exportDidFinish:exporter:assets];\n          });\n      }];\n\t\nfunc merge(arrayVideos:[AVAsset], completion:@escaping (_ exporter: AVAssetExportSession) -> ()) -> Void {\n\n  let mainComposition = AVMutableComposition()\n  let compositionVideoTrack = mainComposition.addMutableTrack(withMediaType: .video, preferredTrackID: kCMPersistentTrackID_Invalid)\n  compositionVideoTrack?.preferredTransform = CGAffineTransform(rotationAngle: .pi / 2)\n\n  let soundtrackTrack = mainComposition.addMutableTrack(withMediaType: .audio, preferredTrackID: kCMPersistentTrackID_Invalid)\n\n  var insertTime = kCMTimeZero\n\n  for videoAsset in arrayVideos {\n    try! compositionVideoTrack?.insertTimeRange(CMTimeRangeMake(kCMTimeZero, videoAsset.duration), of: videoAsset.tracks(withMediaType: .video)[0], at: insertTime)\n    try! soundtrackTrack?.insertTimeRange(CMTimeRangeMake(kCMTimeZero, videoAsset.duration), of: videoAsset.tracks(withMediaType: .audio)[0], at: insertTime)\n\n    insertTime = CMTimeAdd(insertTime, videoAsset.duration)\n  }\n\n  let outputFileURL = URL(fileURLWithPath: NSTemporaryDirectory() + \"merge.mp4\")\n\n  let fileManager = FileManager()\n  fileManager.removeItemIfExisted(outputFileURL)\n\n  let exporter = AVAssetExportSession(asset: mainComposition, presetName: AVAssetExportPresetHighestQuality)\n\n  exporter?.outputURL = outputFileURL\n  exporter?.outputFileType = AVFileType.mp4\n  exporter?.shouldOptimizeForNetworkUse = true\n\n  exporter?.exportAsynchronously {\n    DispatchQueue.main.async {\n      completion(exporter!)\n    }\n  }\n}",
 "title": ""
}