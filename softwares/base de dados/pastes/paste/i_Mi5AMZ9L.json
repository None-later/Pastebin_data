{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "re_sql",
  "re_url",
  "lg_en",
  "kw_tor",
  "re_ast1"
 ],
 "key": "Mi5AMZ9L",
 "pasteDate": "Feb 18, 2018, 3:08:55 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "--//====================================================\\\\--\n--||\t\t\t   CREATED BY  KARMARANGE\n--\\\\====================================================//--\n\nlocal e = script.Parent:FindFirstChild(\"Body Colors\")\nif e then\ne:Destroy()\nend\n\nwait(1 / 60)\n\n\nwait(0.75)\nHOLDSHIELD = false\nPlayer = game:GetService(\"Players\").LocalPlayer\nPlayerGui = Player.PlayerGui\nCam = workspace.CurrentCamera\nBackpack = Player.Backpack\nCharacter = Player.Character\nHumanoid = Character.Humanoid\nMouse = Player:GetMouse()\nRootPart = Character[\"HumanoidRootPart\"]\nTorso = Character[\"Torso\"]\nHead = Character[\"Head\"]\nRightArm = Character[\"Right Arm\"]\nLeftArm = Character[\"Left Arm\"]\nRightLeg = Character[\"Right Leg\"]\nLeftLeg = Character[\"Left Leg\"]\nRootJoint = RootPart[\"RootJoint\"]\nNeck = Torso[\"Neck\"]\nRightShoulder = Torso[\"Right Shoulder\"]\nLeftShoulder = Torso[\"Left Shoulder\"]\nRightHip = Torso[\"Right Hip\"]\nLeftHip = Torso[\"Left Hip\"]\nHead.BrickColor = BrickColor.new(\"Light stone grey\")\nRightArm.BrickColor = BrickColor.new(\"Light stone grey\")\nLeftArm.BrickColor = BrickColor.new(\"Light stone grey\")\nLeftLeg.BrickColor = BrickColor.new(\"Light stone grey\")\nRightLeg.BrickColor = BrickColor.new(\"Light stone grey\")\nTorso.BrickColor = BrickColor.new(\"Light stone grey\")\nwait(0.2)\nHead.face:Destroy()\nHumanoid.MaxHealth = \"inf\"\nHumanoid.Health = \"inf\"\nHumanoid.WalkSpeed = 45\nHumanoid.JumpPower = 250\nlocal eye1 = Instance.new(\"Hat\")\neye1.AttachmentPos = Vector3.new(-0.25,3.4,1)\neye1.AttachmentForward = Vector3.new(0,-1,0)\neye1.AttachmentRight = Vector3.new(0,0,1)\neye1.AttachmentUp = Vector3.new(1,0,0)\npupil1 = Instance.new(\"Part\")\npupil1.Size = Vector3.new(1, 1, 1)\npupil1.CanCollide = false\nlocal mesh = Instance.new(\"SpecialMesh\")\nmesh.MeshType = \"Sphere\"\nmesh.Parent = pupil1\npupil1.Material = \"Neon\"\npupil1.BrickColor = BrickColor.new(\"Really red\")\npupil1.Parent = eye1\npupil1.Name = \"Handle\"\npupil1.Transparency = 0.75\nlocal eye2 = Instance.new(\"Hat\")\neye2.AttachmentPos = Vector3.new(-0.25,3.4,-1)\neye2.AttachmentForward = Vector3.new(0,-1,0)\neye2.AttachmentRight = Vector3.new(0,0,1)\neye2.AttachmentUp = Vector3.new(1,0,0)\npupil2 = Instance.new(\"Part\")\npupil2.Size = Vector3.new(1, 1, 1)\npupil2.CanCollide = false\npupil2.Transparency = 0.75\nlocal mesh2 = Instance.new(\"SpecialMesh\")\nmesh2.MeshType = \"Sphere\"\nmesh2.Parent = pupil2\npupil2.Material = \"Neon\"\npupil2.BrickColor = BrickColor.new(\"Really red\")\npupil2.Parent = eye2\npupil2.Name = \"Handle\"\nk = Instance.new(\"Sound\",Character)\nk.Volume = 0.6\nk.Looped = true\nk.PlaybackSpeed = 1\nk.Pitch = 1\nk.SoundId = \"rbxassetid://416762834\"\nk:Play()\nk.Name = \"BackgroundMusic\"\nlocal horns = Instance.new(\"Hat\")\nhorns.AttachmentPos = Vector3.new(0, 0, -1)\nhorns.AttachmentForward = Vector3.new(0, -1, -1)\nhorns.AttachmentRight = Vector3.new(1, 0, 0)\nhorns.AttachmentUp = Vector3.new(0, 1, 0)\nhe = Instance.new(\"Part\")\nhe.Size = Vector3.new(0.5,0.5,0.5)\nhe.CanCollide = false\nhe.Name = \"Handle\"\nhe.Parent = horns\nhe.BrickColor = BrickColor.new(\"Institutional white\")\nlocal mesh2 = Instance.new(\"SpecialMesh\")\nmesh2.MeshType = \"FileMesh\"\nmesh2.Parent = he\nmesh2.MeshId = \"http://www.roblox.com/asset/?id=76062497\"\nmesh2.Scale = Vector3.new(6.7,6.7,6.7)\nif Character:FindFirstChild(\"Shirt\") then\nCharacter.Shirt:Destroy()\nend\nif Character:FindFirstChild(\"Pants\") then\nCharacter.Pants:Destroy()\nend\nlocal top = Instance.new(\"Shirt\")\ntop.ShirtTemplate = \"rbxassetid://448647975\"\nlocal bottom = Instance.new(\"Pants\")\nbottom.PantsTemplate = \"rbxassetid://448648561\"\ntop.Parent = Character\nbottom.Parent = Character\nHead.Mesh:Destroy()\nlocal newmesh = Instance.new(\"SpecialMesh\")\nnewmesh.Scale = Vector3.new(6,6,6)\nnewmesh.MeshId = \"http://www.roblox.com/asset/?id=181343290\"\nnewmesh.TextureId = \"http://www.roblox.com/asset/?id=181343313\"\nnewmesh.Parent = Head\nHead.BrickColor = BrickColor.new(\"Really black\")\nRightArm.BrickColor = BrickColor.new(\"Really black\")\nLeftArm.BrickColor = BrickColor.new(\"Really black\")\nLeftLeg.BrickColor = BrickColor.new(\"Really black\")\nRightLeg.BrickColor = BrickColor.new(\"Really black\")\nTorso.BrickColor = BrickColor.new(\"Really black\")\nlocal horns2 = Instance.new(\"Hat\")\nhorns2.AttachmentPos = Vector3.new(0, -4, 0.6)\nhorns2.AttachmentForward = Vector3.new(0, 0, -1)\nhorns2.AttachmentRight = Vector3.new(1, 0, 0)\nhorns2.AttachmentUp = Vector3.new(0, 1, 0)\nhe = Instance.new(\"Part\")\nhe.Size = Vector3.new(0.5,0.5,0.5)\nhe.CanCollide = false\nhe.Name = \"Handle\"\nhe.Parent = horns2\nlocal mesh2 = Instance.new(\"SpecialMesh\")\nmesh2.MeshType = \"FileMesh\"\nmesh2.Parent = he\nmesh2.MeshId = \"http://www.roblox.com/asset/?id=215680403\"\nmesh2.TextureId = \"http://www.roblox.com/asset/?id=398639091\"\nmesh2.Scale = Vector3.new(4, 4, 4)\nlocal hair = Instance.new(\"Hat\")\nhair.AttachmentPos = Vector3.new(0, 0, -1)\nhair.AttachmentForward = Vector3.new(0, 5, -1)\nhair.AttachmentRight = Vector3.new(1, 0, 0)\nhair.AttachmentUp = Vector3.new(0, 1, 0)\nhe = Instance.new(\"Part\")\nhe.Size = Vector3.new(0.5,0.5,0.5)\nhe.CanCollide = false\nhe.Name = \"Handle\"\nhe.Parent = hair\nhe.BrickColor = BrickColor.new(\"Really black\")\nlocal mesh2 = Instance.new(\"SpecialMesh\")\nmesh2.MeshType = \"FileMesh\"\nmesh2.Parent = he\nmesh2.MeshId = \"http://www.roblox.com/asset/?id=398987591\"\nmesh2.Scale = Vector3.new(5,3.5,6)\nlocal eye3 = Instance.new(\"Hat\")\neye3.AttachmentPos = Vector3.new(-0.25,3.4,1)\neye3.AttachmentForward = Vector3.new(0,-1,0)\neye3.AttachmentRight = Vector3.new(0,0,1)\neye3.AttachmentUp = Vector3.new(1,0,0)\npupil1 = Instance.new(\"Part\")\npupil1.Size = Vector3.new(0.8,0.8,0.8)\npupil1.CanCollide = false\nlocal mesh = Instance.new(\"SpecialMesh\")\nmesh.MeshType = \"Sphere\"\nmesh.Parent = pupil1\npupil1.Material = \"Neon\"\npupil1.BrickColor = BrickColor.new(\"Really black\")\npupil1.Parent = eye3\npupil1.Name = \"Handle\"\nlocal eye4 = Instance.new(\"Hat\")\neye4.AttachmentPos = Vector3.new(-0.25,3.4,-1)\neye4.AttachmentForward = Vector3.new(0,-1,0)\neye4.AttachmentRight = Vector3.new(0,0,1)\neye4.AttachmentUp = Vector3.new(1,0,0)\npupil2 = Instance.new(\"Part\")\npupil2.Size = Vector3.new(0.8, 0.8, 0.8)\npupil2.CanCollide = false\nlocal mesh2 = Instance.new(\"SpecialMesh\")\nmesh2.MeshType = \"Sphere\"\nmesh2.Parent = pupil2\npupil2.Material = \"Neon\"\npupil2.BrickColor = BrickColor.new(\"Really black\")\npupil2.Parent = eye4\npupil2.Name = \"Handle\"\n\n\n\n\nIT = Instance.new\nCF = CFrame.new\nVT = Vector3.new\nRAD = math.rad\nC3 = Color3.new\nUD2 = UDim2.new\nBRICKC = BrickColor.new\nANGLES = CFrame.Angles\nEULER = CFrame.fromEulerAnglesXYZ\nCOS = math.cos\nACOS = math.acos\nSIN = math.sin\nASIN = math.asin\nABS = math.abs\nMRANDOM = math.random\nFLOOR = math.floor\n\n\tlocal function weldBetween(a, b)\n\t    local weldd = Instance.new(\"ManualWeld\")\n\t    weldd.Part0 = a\n\t    weldd.Part1 = b\n\t    weldd.C0 = CFrame.new()\n\t    weldd.C1 = b.CFrame:inverse() * a.CFrame\n\t    weldd.Parent = a\n\t    return weldd\n\tend\n\n\n\n--//=================================\\\\\n--||\t\t  CUSTOMIZATION\n--\\\\=================================//\n\nClass_Name = \"Vesper\"\nWeapon_Name = \"Vesper\"\n\nCustom_Colors = {\n\tCustom_Color_1 = BRICKC(\"Institutional white\"); --1st color for the weapon.\n\tCustom_Color_2 = BRICKC(\"Institutional white\"); --2nd color for the weapon.\n\n\tCustom_Color_3 = BRICKC(\"Institutional white\"); --Color for the abilities.\n\tCustom_Color_4 = BRICKC(\"Institutional white\"); --Color for the secondary bar.\n\tCustom_Color_5 = BRICKC(\"Institutional white\"); --Color for the mana bar.\n\tCustom_Color_6 = BRICKC(\"Institutional white\"); --Color for the health bar.\n\tCustom_Color_7 = BRICKC(\"Institutional white\"); --Color for the stun bar.\n\n\tCustom_Color_8 = BRICKC(\"Institutional white\"); --Background for the mana bar.\n\tCustom_Color_9 = BRICKC(\"Institutional white\"); --Background for the secondary mana bar.\n\tCustom_Color_10 = BRICKC(\"Institutional white\"); --Background for the stun bar.\n\tCustom_Color_11 = BRICKC(\"Institutional white\"); --Background for the health bar.\n\tCustom_Color_12 = BRICKC(\"Institutional white\"); --Background for the abilities.\n}\n\nMana_Bar_Background_Transparency = 0 --Transparency for the background of the mana bar.\nSecondary_Mana_Bar_Background_Transparency = 0 --Transparency for the background of the secondary mana bar.\nHealth_Bar_Background_Transparency = 0 --Transparency for the background of the health bar.\nStun_Bar_Background_Transparency = 0 --Transparency for the background of the stun bar.\nAbility_Background_Transparency = 0  --Transparency for the background of the abilities.\nStat_Background_Transparency = 0 --Transparency for the background of the stats.\n\nPlayer_Size = 6 --Size of the player.\nAnimation_Speed = 8\nFrame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)\n\nEnable_Gui = false --Enables or disables the Weapon Gui. Also functions as hiding or showing the Gui.\nEnable_Stats = false --Enables or disables stats.\nPut_Stats_In_Character = false --Places stats in Character.\nEnable_Stagger_Hit = false --Enables or disables staggering when hitting a hitbox of some sort.\nPlay_Hitbox_Hit_Sound = true --Plays a hit sound when hitting a hitbox of some sort.\nEnable_Stagger = false --Enables or disables staggering.\nEnable_Stun = false --Enables or disables the stun mechanic.\nEnable_Abilities = false --Enables abilites with cooldowns and mana costs.\nEnable_Secondary_Bar = false --Enables the secondary mana bar, if true.\n\nStart_Equipped = false --Starts the player equipped with their weapon.\nStart_Equipped_With_Equipped_Animation = false --Used in conjunction with the above option. Starts your equip animation.\nCan_Equip_Or_Unequip = true --Enables or disables the ability to unequip or equip your weapon.\nDisable_Animator = true --Disables the Animator in the humanoid.\nDisable_Animate = true --Disables the Animate script in the character.\nDisable_Moving_Arms = false --Keeps the arms from moving around.\nUse_Motors_Instead_Of_Welds = false --Uses motors instead of welds to disable moving arms.\nWalkspeed_Depends_On_Movement_Value = false --Walkspeed depends on movement value. Self-explanatory.\nDisable_Jump = false --Disables jumping.\nUse_HopperBin = true --Uses a hopperbin to do things.\n\nCooldown_1 = 0 --Cooldowns for abilites.\nCooldown_2 = 0\nCooldown_3 = 0\nCooldown_4 = 0\nSkill_1_Mana_Cost = 0 --How much mana is required to use the skill.\nSkill_2_Mana_Cost = 0\nSkill_3_Mana_Cost = 0\nSkill_4_Mana_Cost = 0\nMax_Mana = 0 --Maximum amount of mana you can have.\nMax_Secondary_Mana = 0 --Maximum amount of secondary mana you can have.\nMana_Name = \"Mana\" --Name for the mana bar.\nSecondary_Mana_Name = \"Block\" --Name for the secondary mana bar.\nMax_Stun = 1 --Maximum amount of stun you can have.\nRecover_Mana = 0 --How much mana you gain.\nMana_Regen_Mode = \"1\" --Basically switches from one mana regen system to another.\nSecondary_Mana_Regen_Mode = \"1\" --Basically switches from one secondary mana regen system to another.\nStun_Lose_Mode = \"1\" --Basically switches from one secondary stun loss system to another.\nRecover_Secondary_Mana = 0 --How much secondary mana you gain.\nLose_Stun = 0 --How much stun you lose.\nStun_Wait = 0 --Delay between losing stun.\nMana_Wait = 0 --Delay between gaining mana.\nSecondary_Mana_Wait = 0 --Delay between gaining secondary mana.\nMenu_Update_Speed = 0 --How fast the Weapon Gui will update.\nConstant_Update = false --Removes the delay between updating the Weapon GUI.\nShow_Stats = false --Hides or shows stats.\nStat_Offset = 0.74 --For cosmetic purposes. {0.74, 0.78}\n\n--//=================================\\\\\n--|| \t  END OF CUSTOMIZATION\n--\\\\=================================//\n\n\nfunction chatfunc(text)\nlocal chat = coroutine.wrap(function()\nif Character:FindFirstChild(\"TalkingBillBoard\")~= nil then\nCharacter:FindFirstChild(\"TalkingBillBoard\"):destroy()\nend\nlocal naeeym2 = Instance.new(\"BillboardGui\",Character)\nnaeeym2.Size = UDim2.new(0,100,0,40)\nnaeeym2.StudsOffset = Vector3.new(0,7,0)\nnaeeym2.Adornee = Character.Head\nnaeeym2.Name = \"TalkingBillBoard\"\nnaeeym2.AlwaysOnTop = true\nlocal tecks2 = Instance.new(\"TextLabel\",naeeym2)\ntecks2.BackgroundTransparency = 1\ntecks2.BorderSizePixel = 0\ntecks2.Text = \"\"\ntecks2.Font = \"Antique\"\ntecks2.TextSize = 30\ntecks2.TextStrokeTransparency = 0\ntecks2.TextColor3 = Color3.new(0,0,0)\ntecks2.TextStrokeColor3 = Color3.new(0,0,0)\ntecks2.Size = UDim2.new(1,0,0.5,0)\nlocal tecks3 = Instance.new(\"TextLabel\",naeeym2)\ntecks3.BackgroundTransparency = 1\ntecks3.BorderSizePixel = 0\ntecks3.Text = \"\"\ntecks3.Font = \"Fantasy\"\ntecks3.TextSize = 30\ntecks3.TextStrokeTransparency = 0\ntecks3.TextColor3 = Color3.new(1,1,1)\ntecks3.TextStrokeColor3 = Color3.new(0,0,0)\ntecks3.Size = UDim2.new(1,0,0.5,0)\nfor i = 1,string.len(text),1 do\ntecks2.Text = string.sub(text,1,i)\ntecks3.Text = string.sub(text,1,i)\nwait(0.01)\nend\nwait(2)\nfor i = 1, 50 do\nwait()\ntecks2.Position = tecks2.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))\ntecks2.Rotation = tecks2.Rotation - .8\ntecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04\ntecks2.TextTransparency = tecks2.TextTransparency + .04\ntecks3.Position = tecks2.Position - UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))\ntecks3.Rotation = tecks2.Rotation + .8\ntecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04\ntecks3.TextTransparency = tecks2.TextTransparency + .04\nend\nnaeeym2:Destroy()\nend)\nchat()\nend\nfunction onChatted(msg)\nchatfunc(msg)\nend\nPlayer.Chatted:connect(onChatted)\n\n\n--//=================================\\\\\n--|| \t      USEFUL VALUES\n--\\\\=================================//\n\nlocal ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))\nlocal NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))\nlocal RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))\nlocal LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))\nlocal CO1 = 0\nlocal CO2 = 0\nlocal CO3 = 0\nlocal CO4 = 0\nlocal CHANGEDEFENSE = 0\nlocal CHANGEDAMAGE = 0\nlocal CHANGEMOVEMENT = 0\nlocal ANIM = \"Idle\"\nlocal ATTACK = false\nlocal EQUIPPED = false\nlocal HOLD = false\nlocal COMBO = 1\nlocal LASTPOINT = nil\nlocal BLCF = nil\nlocal SCFR = nil\nlocal STAGGERHITANIM = false\nlocal STAGGERANIM = false\nlocal STUNANIM = false\nlocal CRITCHANCENUMBER = 0\nlocal IDLENUMBER = 0\nlocal DONUMBER = 0\nlocal HANDIDLE = false\nlocal SINE = 0\nlocal CHANGE = 2 / Animation_Speed\nlocal WALKINGANIM = false\nlocal WALK = 0\nlocal DISABLEJUMPING = false\nlocal HASBEENBLOCKED = false\nlocal STUNDELAYNUMBER = 0\nlocal MANADELAYNUMBER = 0\nlocal SECONDARYMANADELAYNUMBER = 0\nlocal ROBLOXIDLEANIMATION = IT(\"Animation\")\nROBLOXIDLEANIMATION.Name = \"Roblox Idle Animation\"\nROBLOXIDLEANIMATION.AnimationId = \"http://www.roblox.com/asset/?id=180435571\"\n--ROBLOXIDLEANIMATION.Parent = Humanoid\nlocal WEAPONGUI = IT(\"ScreenGui\", nil)\nWEAPONGUI.Name = \"Weapon GUI\"\nlocal WEAPONTOOL = IT(\"HopperBin\", nil)\nWEAPONTOOL.Name = Weapon_Name\nlocal Weapon = IT(\"Model\")\nWeapon.Name = Weapon_Name\nlocal Effects = IT(\"Folder\", Weapon)\nEffects.Name = \"Effects\"\nlocal ANIMATOR = Humanoid.Animator\nlocal ANIMATE = Character.Animate\nlocal HITPLAYERSOUNDS = {--[[\"199149137\", \"199149186\", \"199149221\", \"199149235\", \"199149269\", \"199149297\"--]]\"263032172\", \"263032182\", \"263032200\", \"263032221\", \"263032252\", \"263033191\"}\nlocal HITARMORSOUNDS = {\"199149321\", \"199149338\", \"199149367\", \"199149409\", \"199149452\"}\nlocal HITWEAPONSOUNDS = {\"199148971\", \"199149025\", \"199149072\", \"199149109\", \"199149119\"}\nlocal HITBLOCKSOUNDS = {\"199148933\", \"199148947\"}\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\t\t\t  STATS\n--\\\\=================================//\n\nif Character:FindFirstChild(\"Stats\") ~= nil then\nCharacter:FindFirstChild(\"Stats\").Parent = nil\nend\n\nlocal Stats = IT(\"Folder\", nil)\nStats.Name = \"Stats\"\nlocal ChangeStat = IT(\"Folder\", Stats)\nChangeStat.Name = \"ChangeStat\"\nlocal Defense = IT(\"NumberValue\", Stats)\nDefense.Name = \"Defense\"\nDefense.Value = 1\nlocal Movement = IT(\"NumberValue\", Stats)\nMovement.Name = \"Movement\"\nMovement.Value = 1\nlocal Damage = IT(\"NumberValue\", Stats)\nDamage.Name = \"Damage\"\nDamage.Value = 1\nlocal Mana = IT(\"NumberValue\", Stats)\nMana.Name = \"Mana\"\nMana.Value = 0\nlocal SecondaryMana = IT(\"NumberValue\", Stats)\nSecondaryMana.Name = \"SecondaryMana\"\nSecondaryMana.Value = 0\nlocal CanCrit = IT(\"BoolValue\", Stats)\nCanCrit.Name = \"CanCrit\"\nCanCrit.Value = false\nlocal CritChance = IT(\"NumberValue\", Stats)\nCritChance.Name = \"CritChance\"\nCritChance.Value = 20\nlocal CanPenetrateArmor = IT(\"BoolValue\", Stats)\nCanPenetrateArmor.Name = \"CanPenetrateArmor\"\nCanPenetrateArmor.Value = false\nlocal AntiTeamKill = IT(\"BoolValue\", Stats)\nAntiTeamKill.Name = \"AntiTeamKill\"\nAntiTeamKill.Value = false\nlocal Rooted = IT(\"BoolValue\", Stats)\nRooted.Name = \"Rooted\"\nRooted.Value = false\nlocal Block = IT(\"BoolValue\", Stats)\nBlock.Name = \"Block\"\nBlock.Value = false\nlocal RecentEnemy = IT(\"ObjectValue\", Stats)\nRecentEnemy.Name = \"RecentEnemy\"\nRecentEnemy.Value = nil\nlocal StaggerHit = IT(\"BoolValue\", Stats)\nStaggerHit.Name = \"StaggerHit\"\nStaggerHit.Value = false\nlocal Stagger = IT(\"BoolValue\", Stats)\nStagger.Name = \"Stagger\"\nStagger.Value = false\nlocal Stun = IT(\"BoolValue\", Stats)\nStun.Name = \"Stun\"\nStun.Value = false\nlocal StunValue = IT(\"NumberValue\", Stats)\nStunValue.Name = \"StunValue\"\nStunValue.Value = 0\n\nif Enable_Stats == true and Put_Stats_In_Character == true then\n\tStats.Parent = Character\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--|| \t     DEBUFFS / BUFFS\n--\\\\=================================//\n\nlocal DEFENSECHANGE1 = IT(\"NumberValue\", ChangeStat)\nDEFENSECHANGE1.Name = \"ChangeDefense\"\nDEFENSECHANGE1.Value = 0\n\nlocal MOVEMENTCHANGE1 = IT(\"NumberValue\", nil)\nMOVEMENTCHANGE1.Name = \"ChangeMovement\"\nMOVEMENTCHANGE1.Value = 0\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--|| SAZERENOS' ARTIFICIAL HEARTBEAT\n--\\\\=================================//\n\nArtificialHB = Instance.new(\"BindableEvent\", script)\nArtificialHB.Name = \"ArtificialHB\"\n\nscript:WaitForChild(\"ArtificialHB\")\n\nframe = Frame_Speed\ntf = 0\nallowframeloss = false\ntossremainder = false\nlastframe = tick()\nscript.ArtificialHB:Fire()\n\ngame:GetService(\"RunService\").Heartbeat:connect(function(s, p)\n\ttf = tf + s\n\tif tf >= frame then\n\t\tif allowframeloss then\n\t\t\tscript.ArtificialHB:Fire()\n\t\t\tlastframe = tick()\n\t\telse\n\t\t\tfor i = 1, math.floor(tf / frame) do\n\t\t\t\tscript.ArtificialHB:Fire()\n\t\t\tend\n\t\tlastframe = tick()\n\t\tend\n\t\tif tossremainder then\n\t\t\ttf = 0\n\t\telse\n\t\t\ttf = tf - frame * math.floor(tf / frame)\n\t\tend\n\tend\nend)\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--|| \t      SOME FUNCTIONS\n--\\\\=================================//\n\nfunction Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)\n\treturn workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)\nend\n\nfunction PositiveAngle(NUMBER)\n\tif NUMBER >= 0 then\n\t\tNUMBER = 0\n\tend\n\treturn NUMBER\nend\n\nfunction NegativeAngle(NUMBER)\n\tif NUMBER <= 0 then\n\t\tNUMBER = 0\n\tend\n\treturn NUMBER\nend\n\nfunction Swait(NUMBER)\n\tif NUMBER == 0 or NUMBER == nil then\n\t\tArtificialHB.Event:wait()\n\telse\n\t\tfor i = 1, NUMBER do\n\t\t\tArtificialHB.Event:wait()\n\t\tend\n\tend\nend\n\nfunction QuaternionFromCFrame(cf)\n\tlocal mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()\n\tlocal trace = m00 + m11 + m22\n\tif trace > 0 then \n\t\tlocal s = math.sqrt(1 + trace)\n\t\tlocal recip = 0.5 / s\n\t\treturn (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5\n\telse\n\t\tlocal i = 0\n\t\tif m11 > m00 then\n\t\t\ti = 1\n\t\tend\n\t\tif m22 > (i == 0 and m00 or m11) then\n\t\t\ti = 2\n\t\tend\n\t\tif i == 0 then\n\t\t\tlocal s = math.sqrt(m00 - m11 - m22 + 1)\n\t\t\tlocal recip = 0.5 / s\n\t\t\treturn 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip\n\t\telseif i == 1 then\n\t\t\tlocal s = math.sqrt(m11 - m22 - m00 + 1)\n\t\t\tlocal recip = 0.5 / s\n\t\t\treturn (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip\n\t\telseif i == 2 then\n\t\t\tlocal s = math.sqrt(m22 - m00 - m11 + 1)\n\t\t\tlocal recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip\n\t\tend\n\tend\nend\n \nfunction QuaternionToCFrame(px, py, pz, x, y, z, w)\n\tlocal xs, ys, zs = x + x, y + y, z + z\n\tlocal wx, wy, wz = w * xs, w * ys, w * zs\n\tlocal xx = x * xs\n\tlocal xy = x * ys\n\tlocal xz = x * zs\n\tlocal yy = y * ys\n\tlocal yz = y * zs\n\tlocal zz = z * zs\n\treturn CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))\nend\n \nfunction QuaternionSlerp(a, b, t)\n\tlocal cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]\n\tlocal startInterp, finishInterp;\n\tif cosTheta >= 0.0001 then\n\t\tif (1 - cosTheta) > 0.0001 then\n\t\t\tlocal theta = ACOS(cosTheta)\n\t\t\tlocal invSinTheta = 1 / SIN(theta)\n\t\t\tstartInterp = SIN((1 - t) * theta) * invSinTheta\n\t\t\tfinishInterp = SIN(t * theta) * invSinTheta\n\t\telse\n\t\t\tstartInterp = 1 - t\n\t\t\tfinishInterp = t\n\t\tend\n\telse\n\t\tif (1 + cosTheta) > 0.0001 then\n\t\t\tlocal theta = ACOS(-cosTheta)\n\t\t\tlocal invSinTheta = 1 / SIN(theta)\n\t\t\tstartInterp = SIN((t - 1) * theta) * invSinTheta\n\t\t\tfinishInterp = SIN(t * theta) * invSinTheta\n\t\telse\n\t\t\tstartInterp = t - 1\n\t\t\tfinishInterp = t\n\t\tend\n\tend\n\treturn a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp\nend\n\nfunction Clerp(a, b, t)\n\tlocal qa = {QuaternionFromCFrame(a)}\n\tlocal qb = {QuaternionFromCFrame(b)}\n\tlocal ax, ay, az = a.x, a.y, a.z\n\tlocal bx, by, bz = b.x, b.y, b.z\n\tlocal _t = 1 - t\n\treturn QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))\nend\n\nfunction CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)\n\tlocal frame = IT(\"Frame\")\n\tframe.BackgroundTransparency = TRANSPARENCY\n\tframe.BorderSizePixel = BORDERSIZEPIXEL\n\tframe.Position = POSITION\n\tframe.Size = SIZE\n\tframe.BackgroundColor3 = COLOR\n\tframe.BorderColor3 = BORDERCOLOR\n\tframe.Name = NAME\n\tframe.Parent = PARENT\n\treturn frame\nend\n\nfunction CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)\n\tlocal label = IT(\"TextLabel\")\n\tlabel.BackgroundTransparency = 1\n\tlabel.Size = UD2(1, 0, 1, 0)\n\tlabel.Position = UD2(0, 0, 0, 0)\n\tlabel.TextColor3 = C3(255, 255, 255)\n\tlabel.TextStrokeTransparency = STROKETRANSPARENCY\n\tlabel.TextTransparency = TRANSPARENCY\n\tlabel.FontSize = TEXTFONTSIZE\n\tlabel.Font = TEXTFONT\n\tlabel.BorderSizePixel = BORDERSIZEPIXEL\n\tlabel.TextScaled = true\n\tlabel.Text = TEXT\n\tlabel.Name = NAME\n\tlabel.Parent = PARENT\n\treturn label\nend\n\nfunction NoOutlines(PART)\n\tPART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10\nend\n\nfunction CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE)\n\tlocal NEWPART = IT(\"Part\")\n\tNEWPART.formFactor = FORMFACTOR\n\tNEWPART.Reflectance = REFLECTANCE\n\tNEWPART.Transparency = TRANSPARENCY\n\tNEWPART.CanCollide = false\n\tNEWPART.Locked = true\n\tNEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))\n\tNEWPART.Name = NAME\n\tNEWPART.Size = SIZE\n\tNEWPART.Position = Torso.Position\n\tNoOutlines(NEWPART)\n\tNEWPART.Material = MATERIAL\n\tNEWPART:BreakJoints()\n\tNEWPART.Parent = PARENT\n\treturn NEWPART\nend\n\nfunction CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)\n\tlocal NEWMESH = IT(MESH)\n\tif MESH == \"SpecialMesh\" then\n\t\tNEWMESH.MeshType = MESHTYPE\n\t\tif MESHID ~= \"nil\" and MESHID ~= \"\" then\n\t\t\tNEWMESH.MeshId = \"http://www.roblox.com/asset/?id=\"..MESHID\n\t\tend\n\t\tif TEXTUREID ~= \"nil\" and TEXTUREID ~= \"\" then\n\t\t\tNEWMESH.TextureId = \"http://www.roblox.com/asset/?id=909271408\"\n\t\tend\n\tend\n\tNEWMESH.Offset = OFFSET or VT(0, 0, 0)\n\tNEWMESH.Scale = SCALE\n\tNEWMESH.Parent = PARENT\n    PARENT.Transparency = 1\n\treturn NEWMESH\nend\n\nfunction CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)\n\tlocal NEWWELD = IT(TYPE)\n\tNEWWELD.Part0 = PART0\n\tNEWWELD.Part1 = PART1\n\tNEWWELD.C0 = C0\n\tNEWWELD.C1 = C1\n\tNEWWELD.Parent = PARENT\n\treturn NEWWELD\nend\n\nfunction CreateSound(ID, PARENT, VOLUME, PITCH)\n\tcoroutine.resume(coroutine.create(function()\n\t\tlocal NEWSOUND = IT(\"Sound\", PARENT)\n\t\tNEWSOUND.Volume = VOLUME\n\t\tNEWSOUND.Pitch = PITCH\n\t\tNEWSOUND.SoundId = \"http://www.roblox.com/asset/?id=\"..ID\n\t\tSwait()\n\t\tNEWSOUND:play()\n\t\tgame:GetService(\"Debris\"):AddItem(NEWSOUND, 10)\n\tend))\nend\n\nfunction CFrameFromTopBack(at, top, back)\n\tlocal right = top:Cross(back)\n\treturn CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)\nend\n\nfunction Lightning(POSITION1, POSITION2, MULTIPLIERTIME, LIGHTNINGDELAY, OFFSET, BRICKCOLOR, MATERIAL, SIZE, TRANSPARENCY, LASTINGTIME)\n\tlocal MAGNITUDE = (POSITION1 - POSITION2).magnitude \n\tlocal CURRENTPOSITION = POSITION1\n\tlocal LIGHTNINGOFFSET = {-OFFSET, OFFSET}\n\tcoroutine.resume(coroutine.create(function()\n\t\tfor i = 1, MULTIPLIERTIME do \n\t\t\tlocal LIGHTNINGPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR,\"Effect\", VT(SIZE * Player_Size, SIZE * Player_Size, MAGNITUDE / MULTIPLIERTIME))\n\t\t\tLIGHTNINGPART.Anchored = true\n\t\t\tlocal LIGHTNINGOFFSET2 = VT(LIGHTNINGOFFSET[MRANDOM(1, 2)], LIGHTNINGOFFSET[MRANDOM(1, 2)], LIGHTNINGOFFSET[MRANDOM(1, 2)]) \n\t\t\tlocal LIGHTNINGPOSITION1 = CF(CURRENTPOSITION, POSITION2) * CF(0, 0, MAGNITUDE / MULTIPLIERTIME).p + LIGHTNINGOFFSET2\n\t\t\tif MULTIPLIERTIME == i then \n\t\t\t\tlocal LIGHTNINGMAGNITUDE1 = (CURRENTPOSITION - POSITION2).magnitude\n\t\t\t\tLIGHTNINGPART.Size = VT(SIZE * Player_Size, SIZE * Player_Size, LIGHTNINGMAGNITUDE1)\n\t\t\t\tLIGHTNINGPART.CFrame = CF(CURRENTPOSITION, POSITION2) * CF(0, 0, -LIGHTNINGMAGNITUDE1 / 2)\n\t\t\telse\n\t\t\t\tLIGHTNINGPART.CFrame = CF(CURRENTPOSITION, LIGHTNINGPOSITION1) * CF(0, 0, MAGNITUDE / MULTIPLIERTIME / 2)\n\t\t\tend\n\t\t\tCURRENTPOSITION=LIGHTNINGPART.CFrame * CF(0, 0, MAGNITUDE / MULTIPLIERTIME / 2).p\n\t\t\tgame.Debris:AddItem(LIGHTNINGPART, LASTINGTIME)\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\twhile LIGHTNINGPART.Transparency ~= 1 do\n\t\t\t\t\t--local StartTransparency = tra\n\t\t\t\t\tfor i=0, 1, LASTINGTIME do\n\t\t\t\t\t\tSwait()\n\t\t\t\t\t\tLIGHTNINGPART.Transparency = LIGHTNINGPART.Transparency + (0.1 / LASTINGTIME)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend))\n\t\tSwait(LIGHTNINGDELAY / Animation_Speed)\n\t\tend\n\tend))\nend\n\n\nfunction MagicBlock(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"BlockMesh\", EFFECTPART, \"\", \"\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicSphere(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"Sphere\", \"\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicCylinder(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"CylinderMesh\", EFFECTPART, \"\", \"\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicHead(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"Head\", \"\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicRing(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"3270017\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicWave(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"20329976\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), VT(0, 0, (-0.1 * Z1)) + (OFFSET * Player_Size))\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Offset = VT(0, 0, (-0.1 * MESH.Scale.Z))\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicCrystal(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"9756362\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicSwirl(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"1051557\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicSharpCone(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"1778999\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicFlatCone(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"1033714\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicSpikedCrown(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"1323306\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicFlatCrown(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"1078075\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction MagicSkull(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X1, Y1, Z1, X2, Y2, Z2, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"4770583\", \"\", VT(X1 * Player_Size, Y1 * Player_Size, Z1 * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tMESH.Scale = MESH.Scale + VT(X2 * Player_Size, Y2 * Player_Size, Z2 * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH)\nend\n\nfunction ElectricEffect(BRICKCOLOR, MATERIAL, CFRAME, ROTATION, OFFSET, X, Y, Z, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"SpecialMesh\", EFFECTPART, \"FileMesh\", \"4770583\", \"\", VT(X * Player_Size, Y * Player_Size, Z * Player_Size), OFFSET * Player_Size)\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tlocal XVALUE = MRANDOM()\n\tlocal YVALUE = MRANDOM()\n\tlocal ZVALUE = MRANDOM()\n\tcoroutine.resume(coroutine.create(function(PART, MESH, THEXVALUE, THEYVALUE, THEZVALUE)\n\t\tfor i = 0, 1, delay do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\tPART.Transparency = i\n\t\t\tTHEXVALUE = THEXVALUE - 0.1 * (delay * 10)\n\t\t\tTHEYVALUE = THEYVALUE - 0.1 * (delay * 10)\n\t\t\tTHEZVALUE = THEZVALUE - 0.1 * (delay * 10)\n\t\t\tMESH.Scale = MESH.Scale + VT(THEXVALUE * Player_Size, THEYVALUE * Player_Size, THEZVALUE * Player_Size)\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART, EFFECTMESH, XVALUE, YVALUE, ZVALUE)\nend\n\nfunction TrailEffect(BRICKCOLOR, MATERIAL, CURRENTCFRAME, OLDCFRAME, MESHTYPE, REFLECTANCE, SIZE, ROTATION, X, Y, Z, delay)\n\tlocal MAGNITUDECFRAME = (CURRENTCFRAME.p - OLDCFRAME.p).magnitude\n\tif MAGNITUDECFRAME > (1 / 100) then\n\t\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 0, BRICKCOLOR, \"Effect\", VT(1, MAGNITUDECFRAME, 1))\n\t\tEFFECTPART.Anchored = true\n\t\tEFFECTPART.CFrame = CF((CURRENTCFRAME.p + OLDCFRAME.p) / 2, OLDCFRAME.p) * ANGLES(RAD(90), 0, 0)\n\t\tlocal THEMESHTYPE = \"BlockMesh\"\n\t\tif MESHTYPE == \"Cylinder\" then\n\t\t\tTHEMESHTYPE = \"CylinderMesh\"\n\t\tend\n\t\tlocal EFFECTMESH = CreateMesh(THEMESHTYPE, EFFECTPART, \"\", \"\", \"\", VT(0 + SIZE * Player_Size, 1, 0 + SIZE * Player_Size), VT(0, 0, 0))\n\t\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\t\tcoroutine.resume(coroutine.create(function(PART, MESH)\n\t\t\tfor i = 0, 1, delay do\n\t\t\t\tSwait()\n\t\t\t\tPART.CFrame = PART.CFrame * ROTATION\n\t\t\t\tPART.Transparency = i\n\t\t\t\tMESH.Scale = MESH.Scale + VT(X * Player_Size, Y * Player_Size, Z * Player_Size)\n\t\t\tend\n\t\t\tPART.Parent = nil\n\t\tend), EFFECTPART, EFFECTMESH)\n\tend\nend\n\nfunction ClangEffect(BRICKCOLOR, MATERIAL, CFRAME, ANGLE, DURATION, SIZE, POWER, REFLECTANCE, X, Y, Z, delay)\n\tlocal EFFECTPART = CreatePart(3, Effects, MATERIAL, 0, 1, BRICKCOLOR, \"Effect\", VT())\n\tEFFECTPART.Anchored = true\n\tEFFECTPART.CFrame = CFRAME\n\tlocal EFFECTMESH = CreateMesh(\"BlockMesh\", EFFECTPART, \"\", \"\", \"\", VT(0, 0, 0), VT(0, 0, 0))\n\tgame:GetService(\"Debris\"):AddItem(EFFECTPART, 10)\n\tlocal THELASTPOINT = CFRAME\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, DURATION do\n\t\t\tSwait()\n\t\t\tPART.CFrame = PART.CFrame * ANGLES(RAD(ANGLE), 0, 0) * CF(0, POWER * Player_Size, 0)\n\t\t\tTrailEffect(BRICKCOLOR, MATERIAL, PART.CFrame, THELASTPOINT, \"Cylinder\", REFLECTANCE, SIZE * Player_Size, ANGLES(0, 0, 0), X * Player_Size, Y * Player_Size, Z * Player_Size, delay)\n\t\t\tTHELASTPOINT = PART.CFrame\n\t\tend\n\t\tPART.Parent = nil\n\tend), EFFECTPART)\nend\n\n--local list={}\nfunction Triangle(Color, Material, a, b, c, delay)\n\tlocal edge1 = (c - a):Dot((b - a).unit)\n\tlocal edge2 = (a - b):Dot((c - b).unit)\n\tlocal edge3 = (b - c):Dot((a - c).unit)\n\tif edge1 <= (b - a).magnitude and edge1 >= 0 then\n\t\ta, b, c=a, b, c\n\telseif edge2 <= (c - b).magnitude and edge2 >= 0 then\n\t\ta, b, c=b, c, a\n\telseif edge3 <= (a - c).magnitude and edge3 >= 0 then\n\t\ta, b, c=c, a, b\n\telse\n\t\tassert(false, \"unreachable\")\n\tend\n\tlocal len1 = (c - a):Dot((b - a).unit)\n\tlocal len2 = (b - a).magnitude - len1\n\tlocal width = (a + (b - a).unit * len1 - c).magnitude\n\tlocal maincf = CFrameFromTopBack(a, (b - a):Cross(c - b).unit, - (b - a).unit)\n\tif len1 > 1 / 100 then\n\t\tlocal sz = VT(0.2, width, len1)\n\t\tlocal w1 = CreatePart(3, Effects, Material, 0, 0.5, Color, \"Trail\", sz)\n\t\tlocal sp = CreateMesh(\"SpecialMesh\", w1, \"Wedge\", \"\", \"\", VT(0, 1, 1) * sz / w1.Size, VT(0, 0, 0))\n\t\tw1.Anchored = true\n\t\tw1.CFrame = maincf * ANGLES(math.pi, 0, math.pi / 2) * CF(0, width / 2, len1 / 2)\n\t\tcoroutine.resume(coroutine.create(function()\n\t\t\tfor i = 0.5, 1, delay * (2 / Animation_Speed) do\n\t\t\t\tSwait()\n\t\t\t\tw1.Transparency = i\n\t\t\tend\n\t\t\tw1.Parent = nil\n\t\tend))\n\t\tgame:GetService(\"Debris\"):AddItem(w1, 10)\n\t\t--table.insert(list, w1)\n\tend\n\tif len2 > 1 / 100 then\n\t\tlocal sz = VT(0.2, width, len2)\n\t\tlocal w2 = CreatePart(3, Effects, Material, 0, 0.5, Color, \"Trail\", sz)\n\t\tlocal sp = CreateMesh(\"SpecialMesh\", w2, \"Wedge\", \"\", \"\", VT(0, 1, 1) * sz / w2.Size, VT(0, 0, 0))\n\t\tw2.Anchored = true\n\t\tw2.CFrame = maincf * ANGLES(math.pi, math.pi, -math.pi / 2) * CF(0, width / 2, -len1 - len2 / 2)\n\t\tcoroutine.resume(coroutine.create(function()\n\t\t\tfor i = 0.5, 1, delay * (2 / Animation_Speed) do\n\t\t\t\tSwait()\n\t\t\t\tw2.Transparency = i\n\t\t\tend\n\t\t\tw2.Parent = nil\n\t\tend))\n\t\tgame:GetService(\"Debris\"):AddItem(w2, 10)\n\t\t--table.insert(list, w2)\n\tend\n\t--return unpack(list)\nend\n\n--[[Usage:\n\tlocal Pos = Part\n\tlocal Offset = Part.CFrame * CF(0, 0, 0)\n\tlocal Color = \"Institutional white\"\n\tlocal Material = \"Neon\"\n\tlocal TheDelay = 0.01\n\tlocal Height = 4\n\tBLCF = Offset\n\tif SCFR and (Pos.Position - SCFR.p).magnitude > 0.1 then\n\t\tlocal a, b = Triangle(Color, Material, (SCFR * CF(0, Height / 2,0)).p, (SCFR * CF(0, -Height / 2, 0)).p, (BLCF * CF(0, Height / 2,0)).p, TheDelay)\n\t\tif a then game:GetService(\"Debris\"):AddItem(a, 1) end\n\t\tif b then game:GetService(\"Debris\"):AddItem(b, 1) end\n\t\tlocal a, b = Triangle(Color, Material, (BLCF * CF(0, Height / 2, 0)).p, (BLCF * CF(0, -Height / 2, 0)).p, (SCFR * CF(0, -Height / 2, 0)).p, TheDelay)\n\t\tif a then game:GetService(\"Debris\"):AddItem(a, 1) end\n\t\tif b then game:GetService(\"Debris\"):AddItem(b, 1) end\n\t\tSCFR = BLCF\n\telseif not SCFR then\n\t\tSCFR = BLCF\n\tend\n--\nBLCF = nil\nSCFR = nil\n--]]\n\n--//=================================\\\\\n--\\\\=================================//\n\n\nfunction createaccessory(attachmentpart,mesh,texture,scale,offset)\nlocal acs = Instance.new(\"Part\")\nacs.CanCollide = false\nacs.Anchored = false\nacs.Size = Vector3.new(1,1,1)\nacs.CFrame = attachmentpart.CFrame\nacs.Parent = Character\n    local meshs = Instance.new(\"SpecialMesh\")\n    meshs.MeshId = mesh\n    meshs.TextureId = texture\n    meshs.Parent = acs\n    meshs.Scale = scale\n    meshs.Offset = offset\nweldBetween(attachmentpart,acs)\nend\n\n\n--//=================================\\\\\n--||\t      RESIZE PLAYER\n--\\\\=================================//\n\nif Player_Size ~= 1 then\nRootPart.Size = RootPart.Size * Player_Size\nTorso.Size = Torso.Size * Player_Size\nHead.Size = Head.Size * Player_Size\nRightArm.Size = RightArm.Size * Player_Size\nLeftArm.Size = LeftArm.Size * Player_Size\nRightLeg.Size = RightLeg.Size * Player_Size\nLeftLeg.Size = LeftLeg.Size * Player_Size\nRootJoint.Parent = RootPart\nNeck.Parent = Torso\nRightShoulder.Parent = Torso\nLeftShoulder.Parent = Torso\nRightHip.Parent = Torso\nLeftHip.Parent = Torso\n\t\nRootJoint.C0 = ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tRootJoint.C1 = ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tNeck.C0 = NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tNeck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180))\n\tRightShoulder.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0\n\tLeftShoulder.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0\n\tif Disable_Moving_Arms == false then\n\t\tRightShoulder.C1 = ANGLES(0, RAD(90), 0) * CF(0 * Player_Size, 0.5 * Player_Size, -0.5)\n\t\tLeftShoulder.C1 = ANGLES(0, RAD(-90), 0) * CF(0 * Player_Size, 0.5 * Player_Size, -0.5)\n\telse\n\t\tRightShoulder.C1 = CF(0 * Player_Size, 0.5 * Player_Size, 0 * Player_Size)\n\t\tLeftShoulder.C1 = CF(0 * Player_Size, 0.5 * Player_Size, 0 * Player_Size)\n\tend\n\tRightHip.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tLeftHip.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tRightHip.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))\n\tLeftHip.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))\nwait(0.1)\neye1.Parent = Character\neye2.Parent = Character\neye3.Parent = Character\neye4.Parent = Character\nhorns.Parent = Character\nhorns2.Parent = Character\nhair.Parent = Character\ncreateaccessory(Torso,\"http://www.roblox.com/asset/?id=215682815\",\"http://www.roblox.com/asset/?id=215682864\",Vector3.new(6,6,6),Vector3.new(0,5,-4))\nend\n\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\t     WEAPON CREATION\n--\\\\=================================//\n\nlocal HandlePart = CreatePart(3, Weapon, \"SmoothPlastic\", 0, 0, \"Really black\", \"Handle\", VT(0, 0, 0))\nlocal HandleMesh = CreateMesh(\"SpecialMesh\", HandlePart, \"FileMesh\", \"93180631\", \"93180676\", VT(1, 1, 1), VT(0, 3.1 * Player_Size, 0))\nlocal HandleWeld = CreateWeldOrSnapOrMotor(\"Weld\", HandlePart, Torso, HandlePart, CF(2 * Player_Size, 2 * Player_Size, 0.6 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(135)), CF(0, 0, 0))\n\nlocal HitboxPart = CreatePart(3, Weapon, \"SmoothPlastic\", 0, 1, \"Really black\", \"Hitbox\", VT(0, 0, 0))\nlocal HitboxWeld = CreateWeldOrSnapOrMotor(\"Weld\", HitboxPart, HandlePart, HitboxPart, CF(0 * Player_Size, 4 * Player_Size, 0 * Player_Size), CF(0, 0, 0))\n\nlocal EffectPart = CreatePart(3, Weapon, \"SmoothPlastic\", 0, 1, \"Really black\", \"Effect Part\", VT(0, 0, 0))\nlocal EffectWeld = CreateWeldOrSnapOrMotor(\"Weld\", EffectPart, HandlePart, EffectPart, CF(0 * Player_Size, 7 * Player_Size, 0 * Player_Size), CF(0, 0, 0))\n\nif Player_Size ~= 1 then\n\tfor _, v in pairs (Weapon:GetChildren()) do\n\t\tif v.ClassName == \"Motor\" or v.ClassName == \"Weld\" or v.ClassName == \"Snap\" then\n\t\t\tlocal p1 = v.Part1\n\t\t\tv.Part1 = nil\n\t\t\tlocal cf1, cf2, cf3, cf4, cf5, cf6, cf7, cf8, cf9, cf10, cf11, cf12 = v.C1:components()\n\t\t\tv.C1 = CF(cf1 * Player_Size, cf2 * Player_Size, cf3 * Player_Size, cf4, cf5, cf6, cf7, cf8, cf9, cf10, cf11, cf12)\n\t\t\tv.Part1 = p1\n\t\telseif v.ClassName == \"Part\" then\n\t\t\tfor _, b in pairs (v:GetChildren()) do\n\t\t\t\tif b.ClassName == \"SpecialMesh\" or b.ClassName == \"BlockMesh\" then\n\t\t\t\t\tb.Scale = VT(b.Scale.x * Player_Size, b.Scale.y * Player_Size, b.Scale.z * Player_Size)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfor _, c in pairs(Weapon:GetChildren()) do\n\tif c.ClassName == \"Part\" then\n\t\tc.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)\n\tend\nend\n\nif Start_Equipped == true and Start_Equipped_With_Equipped_Animation == false then\n\tHandleWeld.Part0 = RightArm\n\tHandleWeld.C0 = CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0))\nend\n\nWeapon.Parent = Character\n\nHumanoid.Died:connect(function()\n\tATTACK = true\nend)\n\nprint(Class_Name..\" loaded.\")\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\t     DAMAGE FUNCTIONS\n--\\\\=================================//\n\nfunction StatLabel(LABELTYPE, CFRAME, TEXT, COLOR)\n\tlocal STATPART = CreatePart(3, Effects, \"SmoothPlastic\", 0, 1, \"Really black\", \"Effect\", VT())\n\tSTATPART.CFrame = CF(CFRAME.p + VT(0, 1.5, 0))\n\tlocal BODYGYRO = IT(\"BodyGyro\", STATPART)\n\tlocal BODYPOSITION = IT(\"BodyPosition\", STATPART)\n\tBODYPOSITION.P = 2000\n\tBODYPOSITION.D = 100\n\tBODYPOSITION.maxForce = VT(math.huge, math.huge, math.huge)\n\tif LABELTYPE == \"Normal\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2, 2), 6, MRANDOM(-2, 2))\n\telseif LABELTYPE == \"Debuff\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2, 2), 8, MRANDOM(-2, 2))\n\telseif LABELTYPE == \"Interruption\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2,2), 8, MRANDOM(-2, 2))\n\tend\n\tgame:GetService(\"Debris\"):AddItem(STATPART ,5)\n\tlocal BILLBOARDGUI = Instance.new(\"BillboardGui\", STATPART)\n\tBILLBOARDGUI.Adornee = STATPART\n\tBILLBOARDGUI.Size = UD2(2.5, 0, 2.5 ,0)\n\tBILLBOARDGUI.StudsOffset = VT(-2, 2, 0)\n\tBILLBOARDGUI.AlwaysOnTop = false\n\tlocal TEXTLABEL = Instance.new(\"TextLabel\", BILLBOARDGUI)\n\tTEXTLABEL.BackgroundTransparency = 1\n\tTEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)\n\tTEXTLABEL.Text = TEXT\n\tTEXTLABEL.Font = \"SourceSans\"\n\tTEXTLABEL.FontSize=\"Size42\"\n\tTEXTLABEL.TextColor3 = COLOR\n\tTEXTLABEL.TextStrokeTransparency = 0\n\tTEXTLABEL.TextScaled = true\n\tTEXTLABEL.TextWrapped = true\n\tcoroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)\n\t\twait(0.2)\n\t\tfor i=1, 5 do\n\t\t\twait()\n\t\t\tTHEBODYPOSITION.Position = THEPART.Position - VT(0, 0.5 ,0)\n\t\tend\n\t\twait(1.2)\n\t\tfor i=1, 5 do\n\t\t\twait()\n\t\t\tTHETEXTLABEL.TextTransparency = THETEXTLABEL.TextTransparency + 0.2\n\t\t\tTHETEXTLABEL.TextStrokeTransparency = THETEXTLABEL.TextStrokeTransparency + 0.2\n\t\t\tTHEBODYPOSITION.position = THEPART.Position + VT(0, 0.5, 0)\n\t\tend\n\t\tTHEPART.Parent = nil\n\tend),STATPART, BODYPOSITION, TEXTLABEL)\nend\n\nfunction IncreaseOrDecreaseStat(LOCATION, STAT, AMOUNT, DURATION, SHOWTHESTAT)\n\tif LOCATION:FindFirstChild(\"Stats\") ~= nil then\n\t\tif LOCATION.Stats:FindFirstChild(\"Block\") ~= nil then\n\t\t\tif LOCATION.Stats:FindFirstChild(\"Block\").Value == true then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\tif LOCATION.Stats:FindFirstChild(\"ChangeStat\") ~= nil and LOCATION.Stats:FindFirstChild(\"Block\").Value == false then\n\t\t\tlocal NewStatChange = IT(\"NumberValue\")\n\t\t\tNewStatChange.Value = AMOUNT\n\t\t\tif STAT == \"Defense\" then\n\t\t\t\tNewStatChange.Name = \"ChangeDefense\"\n\t\t\telseif STAT == \"Damage\" then\n\t\t\t\tNewStatChange.Name = \"ChangeDamage\"\n\t\t\telseif STAT == \"Movement\" then\n\t\t\t\tNewStatChange.Name = \"ChangeMovement\"\n\t\t\tend\n\t\t\tif SHOWTHESTAT == true then\n\t\t\t\tif AMOUNT < 0 then\n\t\t\t\t\tStatLabel(\"Debuff\", LOCATION.Head.CFrame * CF(0, 0 + (LOCATION.Head.Size.z - 1), 0), \"-\"..STAT, C3(1, 1, 1))\n\t\t\t\telseif AMOUNT > 0 then\n\t\t\t\t\tStatLabel(\"Debuff\", LOCATION.Head.CFrame * CF(0, 0 + (LOCATION.Head.Size.z - 1), 0), \"+\"..STAT, C3(1, 1, 1))\n\t\t\t\tend\n\t\t\tend\n\t\t\tif DURATION ~= nil and DURATION ~= 0 then\n\t\t\t\tlocal StatDuration = IT(\"NumberValue\")\n\t\t\t\tStatDuration.Name = \"Duration\"\n\t\t\t\tStatDuration.Value = DURATION\n\t\t\t\tStatDuration.Parent = NewStatChange\n\t\t\tend\n\t\t\tNewStatChange.Parent = LOCATION.Stats:FindFirstChild(\"ChangeStat\")\n\t\tend\n\tend\nend\n\n\n--Usage: DamageFunction(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, hit, false, 5, 10, MRANDOM(5, 10), \"Normal\", Part, 0.5, false, true, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\nfunction DamageFunction(HITWEAPONSOUND, HITARMORSOUND, HITBLOCKSOUND, HITPLAYERSOUND, HITWEAPONSOUNDPITCH, HITARMORSOUNDPITCH, HITBLOCKSOUNDPITCH, HITPLAYERSOUNDPITCH, HIT, HITEVENWHENDEAD, MINIMUMDAMAGE, MAXIMUMDAMAGE, KNOCKBACK, TYPE, PROPERTY, DELAY, KNOCKBACKTYPE, INCREASESTUN, STAGGER, STAGGERHIT, RANGED, DECREASETHESTAT, DECREASEAMOUNT, DECREASEDURATION, SHOWDECREASEDSTAT)\n\tif HIT.Parent == nil then\n\t\treturn\n\tend\n\tlocal HITHUMANOID = HIT.Parent:FindFirstChild(\"Humanoid\")\n\tfor _, v in pairs(HIT.Parent:GetChildren()) do\n\t\tif v:IsA(\"Humanoid\") then\n\t\t\tHITHUMANOID = v\n            HITHUMANOID.MaxHealth = 100\n\t\tend\n\tend\n\tif HIT.Name == \"Hitbox\" and RANGED ~= true and HIT.Parent ~= Weapon and Enable_Stagger_Hit == true then\n\t\tStaggerHit.Value = true\n\t\tif Play_Hitbox_Hit_Sound == true then\n\t\t\tif HITWEAPONSOUND ~= \"\" and HITWEAPONSOUND ~= \"nil\" then\n\t\t\t\tCreateSound(HITWEAPONSOUND, HIT, 1, HITWEAPONSOUNDPITCH)\n\t\t\tend\n\t\tend\n\t\treturn\n\tend\n\tif HIT.Parent.Parent:FindFirstChild(\"Torso\") ~= nil or HIT.Parent.Parent:FindFirstChild(\"UpperTorso\") ~= nil then\n\t\tHITHUMANOID = HIT.Parent.Parent:FindFirstChild(\"Humanoid\")\n\tend\n\tif HIT.Parent.ClassName == \"Hat\" or HIT.ClassName == \"Accessory\" then\n\t\tHIT = HIT.Parent.Parent:FindFirstChild(\"Head\")\n\tend\n\tif HITHUMANOID ~= nil and HIT.Parent.Name ~= Character.Name and (HIT.Parent:FindFirstChild(\"Torso\") ~= nil or HIT.Parent:FindFirstChild(\"UpperTorso\") ~= nil) then\n\t\tif HIT.Parent:FindFirstChild(\"DebounceHit\") ~= nil then\n\t\t\tif HIT.Parent.DebounceHit.Value == true then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\tif AntiTeamKill.Value == true then\n\t\t\tif Player.Neutral == false and game.Players:GetPlayerFromCharacter(HIT.Parent) ~= nil then\n\t\t\t\tif game.Players:GetPlayerFromCharacter(HIT.Parent).TeamColor == Player.TeamColor then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif HITEVENWHENDEAD == false then\n\t\t\tif HIT.Parent:FindFirstChild(\"Humanoid\") ~= nil then\n\t\t\t\tif HIT.Parent:FindFirstChild(\"Humanoid\").Health <= 0 then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif HIT.Parent:FindFirstChild(\"Stats\") ~= nil then\n\t\t\tif HIT.Parent.Stats:FindFirstChild(\"StunValue\") ~= nil then\n\t\t\t\tHIT.Parent.Stats:FindFirstChild(\"StunValue\").Value = HIT.Parent.Stats:FindFirstChild(\"StunValue\").Value + INCREASESTUN\n\t\t\tend\n\t\tend\n\t\tif HIT.Parent:FindFirstChild(\"Stats\") ~= nil then\n\t\t\tif HIT.Parent.Stats:FindFirstChild(\"Stagger\") ~= nil then\n\t\t\t\tif STAGGER == true and Enable_Stagger == true then\n\t\t\t\t\tHIT.Parent.Stats:FindFirstChild(\"Stagger\").Value = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif HIT.Parent:FindFirstChild(\"Stats\") ~= nil then\n\t\t\tif HIT.Parent.Stats:FindFirstChild(\"Block\") ~= nil then\n\t\t\t\tif HIT.Parent.Stats:FindFirstChild(\"Block\").Value == true then\n\t\t\t\t\tHASBEENBLOCKED = true\n\t\t\t\t\tif HIT.Parent.Stats:FindFirstChild(\"Block\"):FindFirstChild(\"BlockDebounce\") == nil then\n\t\t\t\t\t\tStatLabel(\"Interruption\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), \"Blocked!\", C3(0, 100 / 255, 255 / 255))\n\t\t\t\t\t\tif RANGED ~= true then\n\t\t\t\t\t\t\tif HITBLOCKSOUND ~= \"\" and HITBLOCKSOUND ~= \"nil\" then\n\t\t\t\t\t\t\t\tCreateSound(HITBLOCKSOUND, HIT, 1, HITBLOCKSOUNDPITCH)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\tlocal BlockDebounce = IT(\"BoolValue\", HIT.Parent.Stats:FindFirstChild(\"Block\"))\n\t\t\t\t\t\tBlockDebounce.Name = \"BlockDebounce\"\n\t\t\t\t\t\tBlockDebounce.Value = true\n\t\t\t\t\t\tif RANGED ~= true then\n\t\t\t\t\t\t\tgame:GetService(\"Debris\"):AddItem(BlockDebounce, 0.5)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tgame:GetService(\"Debris\"):AddItem(BlockDebounce, 0.1)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif RANGED ~= true and Enable_Stagger == true then\n\t\t\t\t\t\tHIT.Parent.Stats:FindFirstChild(\"Block\").Value = false\n\t\t\t\t\t\tStagger.Value = true\n\t\t\t\t\tend\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif DECREASETHESTAT ~= nil then\n\t\t\tif HIT.Parent:FindFirstChild(\"Stats\") ~= nil then\n\t\t\t\tIncreaseOrDecreaseStat(HIT.Parent, DECREASETHESTAT, DECREASEAMOUNT, DECREASEDURATION, SHOWDECREASEDSTAT)\n\t\t\tend\n\t\tend\n\t\tlocal DAMAGE = MRANDOM(MINIMUMDAMAGE,MAXIMUMDAMAGE) * Damage.Value\n\t\tif HIT.Parent:FindFirstChild(\"Stats\") ~= nil then\n\t\t\tif HIT.Parent.Stats:FindFirstChild(\"Defense\") ~= nil then\n\t\t\t\tif CanPenetrateArmor.Value == true then\n\t\t\t\t\tDAMAGE = DAMAGE\n\t\t\t\telse\n\t\t\t\t\tDAMAGE = DAMAGE / HIT.Parent.Stats:FindFirstChild(\"Defense\").Value\n\t\t\t\tend\n\t\t\telseif HIT.Parent.Stats:FindFirstChild(\"Defense\") == nil then\n\t\t\t\tDAMAGE = DAMAGE\n\t\t\tend\n\t\tend\n\t\tif CanCrit.Value == true then\n\t\t\tCRITCHANCENUMBER = MRANDOM(1, CritChance.Value)\n\t\t\tif CRITCHANCENUMBER == 1 then\n\t\t\t\tDAMAGE = DAMAGE * 2\n\t\t\tend\n\t\tend\n\t\tDAMAGE = math.floor(DAMAGE)\n\t\tif HASBEENBLOCKED == false then\n\t\t\tHITHUMANOID.Health = HITHUMANOID.Health - DAMAGE\n\t\tend\n\t\tif DAMAGE <= 3 and HASBEENBLOCKED == false then\n\t\t\tif STAGGERHIT == true and Enable_Stagger_Hit == true and RANGED ~= true then\n\t\t\t\tStaggerHit.Value = true\n\t\t\tend\n\t\t\tif HITARMORSOUND ~= \"\" and HITARMORSOUND ~= \"nil\" then\n\t\t\t\tCreateSound(HITARMORSOUND, HIT, 1, HITARMORSOUNDPITCH)\n\t\t\tend\n\t\telseif DAMAGE > 3 and DAMAGE < 100 and HASBEENBLOCKED == false then\n\t\t\tif HITPLAYERSOUND ~= \"\" and HITPLAYERSOUND ~= \"nil\" then\n\t\t\t\tCreateSound(HITPLAYERSOUND, HIT, 1, HITPLAYERSOUNDPITCH)\n\t\t\tend\n\t\tend\n\t\tif DAMAGE > 3 and DAMAGE < 20 and HASBEENBLOCKED == false then\n\t\t\tif CanCrit.Value == true and CRITCHANCENUMBER == 1 then\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), \"Crit! \\n\"..DAMAGE, C3(200/255, 0, 0))\n\t\t\t\tCreateSound(\"296102734\", HIT, 1, 1)\n\t\t\telse\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), DAMAGE, C3(255/255, 220/255, 0))\n\t\t\tend\n\t\telseif DAMAGE >= 20 and DAMAGE < 100 and HASBEENBLOCKED == false then\n\t\t\tif CanCrit.Value == true and CRITCHANCENUMBER == 1 then\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), \"Crit! \\n\"..DAMAGE, C3(200/255, 0, 0))\n\t\t\t\tCreateSound(\"296102734\", HIT, 1, 1)\n\t\t\telse\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), DAMAGE, C3(255/255, 0, 0))\n\t\t\tend\n\t\telseif DAMAGE <= 3 and HASBEENBLOCKED == false then\n\t\t\tif CanCrit.Value == true and CRITCHANCENUMBER == 1 then\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), \"Crit! \\n\"..DAMAGE, C3(200/255, 0, 0))\n\t\t\t\tCreateSound(\"296102734\", HIT, 1, 1)\n\t\t\telse\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), DAMAGE, C3(225/255, 225/255, 225/255))\n            end\n\t\telseif DAMAGE == 100 and HASBEENBLOCKED == false then\n\t\t\t\tCreateSound(\"296102734\", HIT, 1, 1)\n\t\t\t\tStatLabel(\"Normal\", HIT.Parent.Head.CFrame * CF(0, 0 + (HIT.Parent.Head.Size.z - 1), 0), \"INF\", C3(225/255, 225/255, 225/255))\n            reap(HIT.Parent)\n\t\tend\n\t\tif TYPE == \"Normal\" then\n\t\t\tlocal vp = IT(\"BodyVelocity\")\n\t\t\tvp.P=500\n\t\t\tvp.maxForce = VT(math.huge, 0, math.huge)\n\t\t\tif KNOCKBACKTYPE == 1 then\n\t\t\t\tvp.Velocity = PROPERTY.CFrame.lookVector * KNOCKBACK + PROPERTY.Velocity / 1.05\n\t\t\telseif KNOCKBACKTYPE == 2 then\n\t\t\t\tvp.Velocity = PROPERTY.CFrame.lookVector * KNOCKBACK\n\t\t\tend\n\t\t\tif KNOCKBACK > 0 and HASBEENBLOCKED == false then\n\t\t\t\tvp.Parent = HIT--.Parent.Torso\n\t\t\tend\n\t\t\tgame:GetService(\"Debris\"):AddItem(vp, 0.5)\n\t\tend\n\t\tHASBEENBLOCKED = false\n\t\tRecentEnemy.Value = HIT.Parent\n\t\tlocal DebounceHit = IT(\"BoolValue\", HIT.Parent)\n\t\tDebounceHit.Name = \"DebounceHit\"\n\t\tDebounceHit.Value = true\n\t\tgame:GetService(\"Debris\"):AddItem(DebounceHit, DELAY)\n\tend\nend\n\nfunction reap(t)\nlocal s = Instance.new(\"Model\")\ns.Name = t.Name\ns.Parent = workspace\nif t:FindFirstChild(\"Torso\") then\nlocal tors = Instance.new(\"Part\")\ntors.Name = \"Torso\"\ntors.Size = t.Torso.Size\ntors.Parent = s\ntors.CFrame = t.Torso.CFrame\nlocal tor = Instance.new(\"CharacterMesh\")\ntor.Parent = s\ntor.BodyPart = \"Torso\"\ntor.MeshId = \"36780113\"\ntor.OverlayTextureId = \"494636944\"\nend\nif t:FindFirstChild(\"Left Leg\") then\nlocal lleg = t:FindFirstChild(\"Left Leg\")\nlocal LL = Instance.new(\"Part\")\nLL.Name = \"Left Leg\"\nLL.Size = lleg.Size\nLL.Parent = s\nLL.CFrame = lleg.CFrame\nLL.CanCollide = true\nlocal tor = Instance.new(\"CharacterMesh\")\ntor.Parent = s\ntor.BodyPart = \"LeftLeg\"\ntor.MeshId = \"36780079\"\ntor.OverlayTextureId = \"494636944\"\nend\nif t:FindFirstChild(\"Right Leg\") then\nlocal rleg = t:FindFirstChild(\"Right Leg\")\nlocal RL = Instance.new(\"Part\")\nRL.Name = \"Right Leg\"\nRL.Size = rleg.Size\nRL.Parent = s\nRL.CFrame = rleg.CFrame\nRL.CanCollide = true\nlocal tor = Instance.new(\"CharacterMesh\")\ntor.Parent = s\ntor.BodyPart = \"RightLeg\"\ntor.MeshId = \"36780195\"\ntor.OverlayTextureId = \"494636944\"\nend\nif t:FindFirstChild(\"Right Arm\") then\nlocal rarm = t:FindFirstChild(\"Right Arm\")\nlocal RA = Instance.new(\"Part\")\nRA.Name = \"Right Arm\"\nRA.Size = rarm.Size\nRA.Parent = s\nRA.CFrame = rarm.CFrame\nRA.CanCollide = true\nlocal tor = Instance.new(\"CharacterMesh\")\ntor.Parent = s\ntor.BodyPart = \"RightArm\"\ntor.MeshId = \"36780156\"\ntor.OverlayTextureId = \"494636944\"\nend\nif t:FindFirstChild(\"Left Arm\") then\nlocal larm = t:FindFirstChild(\"Left Arm\")\nlocal LA = Instance.new(\"Part\")\nLA.Name = \"Left Arm\"\nLA.Size = larm.Size\nLA.Parent = s\nLA.CFrame = larm.CFrame\nLA.CanCollide = true\nlocal tor = Instance.new(\"CharacterMesh\")\ntor.Parent = s\ntor.BodyPart = \"LeftArm\"\ntor.MeshId = \"36780032\"\ntor.OverlayTextureId = \"494636944\"\nend\nif t:FindFirstChild(\"Head\") then\nlocal head = Instance.new(\"Part\")\nhead.Name = \"Head\"\nhead.Size = t.Head.Size\nhead.Parent = s\nhead.CFrame = t.Head.CFrame\nlocal tor = Instance.new(\"SpecialMesh\")\ntor.Scale = Vector3.new(t.Head.Size.Z,t.Head.Size.Z,t.Head.Size.Z)\ntor.MeshType = \"FileMesh\"\ntor.MeshId = \"http://www.roblox.com/asset/?id=181343290\"\ntor.TextureId = \"rbxassetid://494637850\"\ntor.Parent = head\nend\nlocal human = t.Humanoid\nhuman.Parent = s\nhuman.DisplayDistanceType = \"None\"\nt:Destroy()\nend\n\n--Usage: MagnitudeDamage(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, Part, 5, true, 5, 10, MRANDOM(5, 10), \"Normal\", Part, 0.5, false, true, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\nfunction MagnitudeDamage(HITWEAPONSOUND, HITARMORSOUND, HITBLOCKSOUND, HITPLAYERSOUND, HITWEAPONSOUNDPITCH, HITARMORSOUNDPITCH, HITBLOCKSOUNDPITCH, HITPLAYERSOUNDPITCH, PART, MAGNITUDE, HITEVENWHENDEAD, MINIMUMDAMAGE, MAXIMUMDAMAGE, KNOCKBACK, TYPE, PROPERTY, DELAY, KNOCKBACKTYPE, INCREASESTUN, STAGGER, STAGGERHIT, RANGED, MAGNITUDEDECREASETHESTAT, MAGNITUDEDECREASEAMOUNT, MAGNITUDEDECREASEDURATION, MAGNITUDESHOWDECREASEDSTAT)\n\tfor _, c in pairs(workspace:GetChildren()) do\n\t\tlocal HUMANOID = c:FindFirstChild(\"Humanoid\")\n\t\tlocal HEAD = nil\n\t\tif HUMANOID ~= nil then\n\t\t\tfor _, d in pairs(c:GetChildren()) do\n\t\t\t\tif d.ClassName == \"Model\" and RANGED ~= true then\n\t\t\t\t\tHEAD = d:FindFirstChild(\"Hitbox\")\n\t\t\t\t\tif HEAD ~= nil then\n\t\t\t\t\t\tlocal THEMAGNITUDE = (HEAD.Position - PART.Position).magnitude\n\t\t\t\t\t\tif THEMAGNITUDE <= (MAGNITUDE * Player_Size) and c.Name ~= Player.Name then\n\t\t\t\t\t\t\tif Play_Hitbox_Hit_Sound == true then\n\t\t\t\t\t\t\t\tlocal HitRefpart = CreatePart(3, Effects, \"SmoothPlastic\", 0, 1, \"Really black\", \"Effect\", VT())\n\t\t\t\t\t\t\t\tHitRefpart.Anchored = true\n\t\t\t\t\t\t\t\tHitRefpart.CFrame = CF(HEAD.Position)\n\t\t\t\t\t\t\t\tCreateSound(HITWEAPONSOUND, HitRefpart, 1, HITWEAPONSOUNDPITCH)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tif Enable_Stagger_Hit == true then\n\t\t\t\t\t\t\t\tStaggerHit.Value = true\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\telseif d:IsA\"BasePart\" then\n\t\t\t\t\tHEAD = d\n\t\t\t\t\tif HEAD ~= nil then\n\t\t\t\t\t\tlocal THEMAGNITUDE = (HEAD.Position - PART.Position).magnitude\n\t\t\t\t\t\tif THEMAGNITUDE <= (MAGNITUDE * Player_Size) and c.Name ~= Player.Name then\n\t\t\t\t\t\t\tDamageFunction(HITWEAPONSOUND, HITARMORSOUND, HITBLOCKSOUND, HITPLAYERSOUND, HITWEAPONSOUNDPITCH, HITARMORSOUNDPITCH, HITBLOCKSOUNDPITCH, HITPLAYERSOUNDPITCH, HEAD, HITEVENWHENDEAD, MINIMUMDAMAGE, MAXIMUMDAMAGE, KNOCKBACK, TYPE, PROPERTY, DELAY, KNOCKBACKTYPE, INCREASESTUN, STAGGER, STAGGERHIT, RANGED, MAGNITUDEDECREASETHESTAT, MAGNITUDEDECREASEAMOUNT, MAGNITUDEDECREASEDURATION, MAGNITUDESHOWDECREASEDSTAT)\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\n--Usage: MagnitudeBuffOrDebuff(Part, 5, \"Defense\", -0.1, 3, true, true)\nfunction MagnitudeBuffOrDebuff(PART, MAGNITUDE, STAT, AMOUNT, DURATION, SHOWBUFFORDEBUFF, APPLYTOOTHERSINSTEAD)\n\tif Player.Neutral == true then\n\t\tIncreaseOrDecreaseStat(Character, STAT, AMOUNT, DURATION, SHOWBUFFORDEBUFF)\n\tend\n\tfor _, c in pairs(workspace:GetChildren()) do\n\t\tlocal HUMANOID = c:FindFirstChild(\"Humanoid\")\n\t\tlocal THEHEAD = nil\n\t\tif HUMANOID ~= nil then\n\t\t\tif c:FindFirstChild(\"Torso\") ~= nil then\n\t\t\t\tTHEHEAD = c:FindFirstChild(\"Torso\")\n\t\t\telseif c:FindFirstChild(\"UpperTorso\") ~= nil then\n\t\t\t\tTHEHEAD = c:FindFirstChild(\"UpperTorso\")\n\t\t\tend\n\t\t\tif THEHEAD ~= nil then\n\t\t\t\tlocal THEMAGNITUDE = (THEHEAD.Position - PART.Position).magnitude\n\t\t\t\tprint(\"yes 1\")\n\t\t\t\tif APPLYTOOTHERSINSTEAD == true then\n\t\t\t\t\tif THEMAGNITUDE <= (MAGNITUDE * Player_Size) and c.Name ~= Player.Name then\n\t\t\t\t\t\tif Player.Neutral == false and game.Players:GetPlayerFromCharacter(THEHEAD.Parent) ~= nil then\n\t\t\t\t\t\t\tif game.Players:GetPlayerFromCharacter(THEHEAD.Parent).TeamColor == Player.TeamColor then\n\t\t\t\t\t\t\t\tIncreaseOrDecreaseStat(THEHEAD.Parent, STAT, AMOUNT, DURATION, SHOWBUFFORDEBUFF)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\telseif APPLYTOOTHERSINSTEAD == false then\n\t\t\t\t\tif THEMAGNITUDE <= (MAGNITUDE * Player_Size) then\n\t\t\t\t\t\tif Player.Neutral == false and game.Players:GetPlayerFromCharacter(THEHEAD.Parent) ~= nil then\n\t\t\t\t\t\t\tif game.Players:GetPlayerFromCharacter(THEHEAD.Parent).TeamColor == Player.TeamColor then\n\t\t\t\t\t\t\t\tIncreaseOrDecreaseStat(THEHEAD.Parent, STAT, AMOUNT, DURATION, SHOWBUFFORDEBUFF)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\t\t\tWEAPON GUI\n--\\\\=================================//\n\nlocal MANABAR = CreateFrame(WEAPONGUI, Mana_Bar_Background_Transparency, 2, UD2(0.23, 0, 0.82, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_8.r, Custom_Colors.Custom_Color_8.g, Custom_Colors.Custom_Color_8.b), C3(0, 0, 0),\"Mana Bar\") \nlocal MANACOVER = CreateFrame(MANABAR, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_5.r, Custom_Colors.Custom_Color_5.g, Custom_Colors.Custom_Color_5.b), C3(0, 0, 0),\"Mana Cover\")\nlocal MANATEXT = CreateLabel(MANABAR, Mana_Name..\" [\"..FLOOR(Mana.Value)..\"]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Mana Text\")\n\nlocal HEALTHBAR = CreateFrame(WEAPONGUI, Health_Bar_Background_Transparency, 2, UD2(0.5, 0, 0.82, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_11.r, Custom_Colors.Custom_Color_11.g, Custom_Colors.Custom_Color_11.b), C3(0, 0, 0), \"Health Bar\")\nlocal HEALTHCOVER = CreateFrame(HEALTHBAR, 0, 2,UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_6.r, Custom_Colors.Custom_Color_6.g, Custom_Colors.Custom_Color_6.b), C3(0, 0, 0), \"Health Cover\")\nlocal HEALTHTEXT = CreateLabel(HEALTHBAR, \"Health [\"..FLOOR(Humanoid.Health)..\"]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Health Text\")\n\nlocal STUNFRAME = CreateFrame(nil, Stun_Bar_Background_Transparency, 2, UD2(0.5, 0, 0.78, 0),UD2(0.26, 0, 0, 0),C3(Custom_Colors.Custom_Color_10.r, Custom_Colors.Custom_Color_10.g, Custom_Colors.Custom_Color_10.b), C3(0, 0, 0), \"Stun Frame\")\nlocal STUNBAR = CreateFrame(STUNFRAME, 0, 2, UD2(0, 0, 0, 0),UD2(0, 0, 1, 0),C3(Custom_Colors.Custom_Color_7.r, Custom_Colors.Custom_Color_7.g, Custom_Colors.Custom_Color_7.b), C3(0, 0, 0), \"Stun Bar\")\nlocal STUNTEXT = CreateLabel(STUNFRAME, \"Stun [\"..FLOOR(StunValue.Value)..\"]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Stun Text\")\n\nlocal SECONDARYMANABAR = CreateFrame(nil, Secondary_Mana_Bar_Background_Transparency, 2, UD2(0.23, 0, 0.78, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_9.r, Custom_Colors.Custom_Color_9.g, Custom_Colors.Custom_Color_9.b), C3(0, 0, 0),\"Secondary Mana Bar\") \nlocal SECONDARYMANACOVER = CreateFrame(SECONDARYMANABAR, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_4.r, Custom_Colors.Custom_Color_4.g, Custom_Colors.Custom_Color_4.b), C3(0, 0, 0),\"Secondary Mana Cover\")\nlocal SECONDARYMANATEXT = CreateLabel(SECONDARYMANABAR, Secondary_Mana_Name..\" [\"..FLOOR(SecondaryMana.Value)..\"]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Secondary Mana Text\")\n\nlocal DEFENSEFRAME = CreateFrame(nil, Stat_Background_Transparency, 2, UD2(0.23, 0, Stat_Offset, 0), UD2(0.075, 0, 0, 0), C3(100 / 255, 100 / 255, 255 / 255), C3(0, 0, 0),\"Defense Frame\")\nlocal DEFENSETEXT = CreateLabel(DEFENSEFRAME, \"Defense [\"..(Defense.Value * 100)..\"%]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Defense Text\")\n\nlocal DAMAGEFRAME = CreateFrame(nil, Stat_Background_Transparency, 2, UD2(0.456, 0, Stat_Offset, 0), UD2(0.075, 0, 0, 0), C3(255 / 255, 100 / 255, 100 / 255), C3(0, 0, 0),\"Damage Frame\")\nlocal DAMAGETEXT = CreateLabel(DAMAGEFRAME, \"Damage [\"..(Damage.Value * 100)..\"%]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Damage Text\")\n\nlocal MOVEMENTFRAME = CreateFrame(nil, Stat_Background_Transparency, 2, UD2(0.685, 0, Stat_Offset, 0), UD2(0.075, 0, 0, 0), C3(100 / 255, 255 / 255, 100 / 255), C3(0, 0, 0),\"Movement Frame\")\nlocal MOVEMENTTEXT = CreateLabel(MOVEMENTFRAME, \"Movement [\"..(Movement.Value * 100)..\"%]\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Movement Text\")\n\nlocal SKILL1FRAME = CreateFrame(nil, Ability_Background_Transparency, 2, UD2(0.23, 0, 0.86, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_12.r, Custom_Colors.Custom_Color_12.g, Custom_Colors.Custom_Color_12.b), C3(0, 0, 0), \"Skill 1 Frame\")\nlocal SKILL2FRAME = CreateFrame(nil, Ability_Background_Transparency, 2, UD2(0.50, 0, 0.86, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_12.r, Custom_Colors.Custom_Color_12.g, Custom_Colors.Custom_Color_12.b), C3(0, 0, 0), \"Skill 2 Frame\")\nlocal SKILL3FRAME = CreateFrame(nil, Ability_Background_Transparency, 2, UD2(0.23, 0, 0.93, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_12.r, Custom_Colors.Custom_Color_12.g, Custom_Colors.Custom_Color_12.b), C3(0, 0, 0), \"Skill 3 Frame\")\nlocal SKILL4FRAME = CreateFrame(nil, Ability_Background_Transparency, 2, UD2(0.50, 0, 0.93, 0), UD2(0.26, 0, 0, 0), C3(Custom_Colors.Custom_Color_12.r, Custom_Colors.Custom_Color_12.g, Custom_Colors.Custom_Color_12.b), C3(0, 0, 0), \"Skill 4 Frame\")\n\nlocal SKILL1BAR = CreateFrame(SKILL1FRAME, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_3.r, Custom_Colors.Custom_Color_3.g, Custom_Colors.Custom_Color_3.b), C3(0, 0, 0), \"Skill 1 Bar\")\nlocal SKILL2BAR = CreateFrame(SKILL2FRAME, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_3.r, Custom_Colors.Custom_Color_3.g, Custom_Colors.Custom_Color_3.b), C3(0, 0, 0), \"Skill 2 Bar\")\nlocal SKILL3BAR = CreateFrame(SKILL3FRAME, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_3.r, Custom_Colors.Custom_Color_3.g, Custom_Colors.Custom_Color_3.b), C3(0, 0, 0), \"Skill 3 Bar\")\nlocal SKILL4BAR = CreateFrame(SKILL4FRAME, 0, 2, UD2(0, 0, 0, 0), UD2(0, 0, 1, 0), C3(Custom_Colors.Custom_Color_3.r, Custom_Colors.Custom_Color_3.g, Custom_Colors.Custom_Color_3.b), C3(0, 0, 0), \"Skill 4 Bar\")\n\nlocal SKILL1TEXT = CreateLabel(SKILL1FRAME, \"[Z] Ability 1\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Text 1\")\nlocal SKILL2TEXT = CreateLabel(SKILL2FRAME, \"[X] Ability 2\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Text 2\")\nlocal SKILL3TEXT = CreateLabel(SKILL3FRAME, \"[C] Ability 3\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Text 3\")\nlocal SKILL4TEXT = CreateLabel(SKILL4FRAME, \"[V] Ability 4\", C3(1, 1, 1), \"Size32\", \"Legacy\", 1, 2, 1, \"Text 4\")\n\nif Enable_Gui == true then\n\tWEAPONGUI.Parent = PlayerGui\nend\n\nif Enable_Stats == true and Show_Stats == true then\n\tDEFENSEFRAME.Parent = WEAPONGUI\n\tDAMAGEFRAME.Parent = WEAPONGUI\n\tMOVEMENTFRAME.Parent = WEAPONGUI\nend\n\nif Enable_Secondary_Bar == true then\n\tSECONDARYMANABAR.Parent = WEAPONGUI\nend\n\nif Enable_Abilities == true then\n\tSKILL1FRAME.Parent = WEAPONGUI\n\tSKILL2FRAME.Parent = WEAPONGUI\n\tSKILL3FRAME.Parent = WEAPONGUI\n\tSKILL4FRAME.Parent = WEAPONGUI\nend\n\nif Enable_Stun == true then\n\tSTUNFRAME.Parent = WEAPONGUI\nend\n\nfunction UpdateGUI()\n\tMANABAR:TweenSize(UD2(0.26, 0, 0.03, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\tMANACOVER:TweenSize(UD2(1 * (Mana.Value / Max_Mana), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\tMANATEXT.Text = Mana_Name..\" [\"..FLOOR(Mana.Value)..\"]\"\n\tHEALTHBAR:TweenSize(UD2(0.26, 0, 0.03, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\tHEALTHCOVER:TweenSize(UD2(1 * (Humanoid.Health / Humanoid.MaxHealth), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\tHEALTHTEXT.Text = \"Health [\"..FLOOR(Humanoid.Health)..\"]\"\n\tif Enable_Abilities == true then\n\t\tSKILL1FRAME:TweenSize(UD2(0.26, 0, 0.06, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL2FRAME:TweenSize(UD2(0.26, 0, 0.06, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL3FRAME:TweenSize(UD2(0.26, 0, 0.06, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL4FRAME:TweenSize(UD2(0.26, 0, 0.06, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL1BAR:TweenSize(UD2(1 * (CO1 / Cooldown_1), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL2BAR:TweenSize(UD2(1 * (CO2 / Cooldown_2), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL3BAR:TweenSize(UD2(1 * (CO3 / Cooldown_3), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSKILL4BAR:TweenSize(UD2(1 * (CO4 / Cooldown_4), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\tend\n\tif Enable_Stats == true and Show_Stats == true then\n\t\tDEFENSEFRAME:TweenSize(UD2(0.075, 0, 0.03), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tDEFENSETEXT.Text = \"Defense [\"..(Defense.Value * 100)..\"%]\"\n\t\tDAMAGEFRAME:TweenSize(UD2(0.075, 0, 0.03), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tDAMAGETEXT.Text = \"Damage [\"..(Damage.Value * 100)..\"%]\"\n\t\tMOVEMENTFRAME:TweenSize(UD2(0.075, 0, 0.03), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tMOVEMENTTEXT.Text = \"Movement [\"..(Movement.Value * 100)..\"%]\"\n\tend\n\tif Enable_Stun == true then\n\t\tSTUNFRAME:TweenSize(UD2(0.26, 0, 0.03, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSTUNBAR:TweenSize(UD2(1 * (StunValue.Value / Max_Stun), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSTUNTEXT.Text = \"Stun [\"..FLOOR(StunValue.Value)..\"]\"\n\tend\n\tif Enable_Secondary_Bar == true then\n\t\tSECONDARYMANABAR:TweenSize(UD2(0.26, 0, 0.03, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSECONDARYMANACOVER:TweenSize(UD2(1 * (SecondaryMana.Value / Max_Secondary_Mana), 0, 1, 0), \"Out\", \"Quad\", Menu_Update_Speed, Constant_Update)\n\t\tSECONDARYMANATEXT.Text = Secondary_Mana_Name..\" [\"..FLOOR(SecondaryMana.Value)..\"]\"\n\tend\nend\n\nif Enable_Gui == true then\n\tUpdateGUI()\n\tfor _, v in pairs (WEAPONGUI:GetChildren()) do\n\t\tif v.ClassName == \"Frame\" then\n\t\t\tfor _, b in pairs (v:GetChildren()) do\n\t\t\t\tif b.ClassName == \"TextLabel\" then\n\t\t\t\t\tcoroutine.resume(coroutine.create(function(THETEXTLABEL)\n\t\t\t\t\t\twait(Menu_Update_Speed)\n\t\t\t\t\t\tfor i = 1, 0, -0.1 do\n\t\t\t\t\t\t\tSwait()\n\t\t\t\t\t\t\tTHETEXTLABEL.TextTransparency = i\n\t\t\t\t\t\t\tTHETEXTLABEL.TextStrokeTransparency = i\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tTHETEXTLABEL.TextTransparency = 0\n\t\t\t\t\t\tTHETEXTLABEL.TextStrokeTransparency = 0\n\t\t\t\t\tend), b)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\t     SKILL FUNCTIONS\n--\\\\=================================//\n\nfunction UpdateSkillsAndStuff()\n\tif Mana_Regen_Mode == \"1\" then\n\t\tif Mana.Value >= Max_Mana then\n\t\t\tMana.Value = Max_Mana\n\t\telseif Mana.Value < 0 then\n\t\t\tMana.Value = 0\n\t\telse\n\t\t\tif MANADELAYNUMBER <= Mana_Wait then\n\t\t\t\tMANADELAYNUMBER = MANADELAYNUMBER + 1\n\t\t\telse\n\t\t\t\tMANADELAYNUMBER = 0\n\t\t\t\tMana.Value = Mana.Value + Recover_Mana\n\t\t\tend\n\t\tend\n\telseif Mana_Regen_Mode == \"2\" then\n\t\tif Mana.Value <= Max_Mana then\n\t\t\tMana.Value = Mana.Value + (Recover_Mana / 30) / Animation_Speed\n\t\telseif Mana.Value >= Max_Mana then\n\t\t\tMana.Value = Max_Mana\n\t\telseif Mana.Value < 0 then\n\t\t\tMana.Value = 0\n\t\tend\n\tend\n\tif Enable_Secondary_Bar == true then\n\t\tif Secondary_Mana_Regen_Mode == \"1\" then\n\t\t\tif SecondaryMana.Value >= Max_Secondary_Mana then\n\t\t\t\tSecondaryMana.Value = Max_Secondary_Mana\n\t\t\telseif SecondaryMana.Value < 0 then\n\t\t\t\tSecondaryMana.Value = 0\n\t\t\telse\n\t\t\t\tif SECONDARYMANADELAYNUMBER <= Secondary_Mana_Wait then\n\t\t\t\t\tSECONDARYMANADELAYNUMBER = SECONDARYMANADELAYNUMBER + 1\n\t\t\t\telse\n\t\t\t\t\tSECONDARYMANADELAYNUMBER = 0\n\t\t\t\t\tSecondaryMana.Value = SecondaryMana.Value + Recover_Secondary_Mana\n\t\t\t\tend\n\t\t\tend\n\t\telseif Secondary_Mana_Regen_Mode == \"2\" then\n\t\t\tif SecondaryMana.Value <= Max_Secondary_Mana then\n\t\t\t\tSecondaryMana.Value = SecondaryMana.Value + (Recover_Secondary_Mana / 30) / Animation_Speed\n\t\t\telseif SecondaryMana.Value >= Max_Secondary_Mana then\n\t\t\t\tSecondaryMana.Value = Max_Secondary_Mana\n\t\t\telseif SecondaryMana.Value < 0 then\n\t\t\t\tSecondaryMana.Value = 0\n\t\t\tend\n\t\tend\n\telse\n\t\tSecondaryMana.Value = 0\n\tend\n\tif Enable_Stun == true then\n\t\tif Stun_Lose_Mode == \"1\" then\n\t\t\tif StunValue.Value > Max_Stun then\n\t\t\t\tStunValue.Value = Max_Stun\n\t\t\telseif StunValue.Value <= 0 then\n\t\t\t\tStunValue.Value = 0\n\t\t\telse\n\t\t\t\tif STUNDELAYNUMBER <= Stun_Wait then\n\t\t\t\t\tSTUNDELAYNUMBER = STUNDELAYNUMBER + 1\n\t\t\t\telse\n\t\t\t\t\tSTUNDELAYNUMBER = 0\n\t\t\t\t\tStunValue.Value = StunValue.Value - Lose_Stun\n\t\t\t\tend\n\t\t\tend\n\t\telseif Stun_Lose_Mode == \"2\" then\n\t\t\tif StunValue.Value <= Max_Stun and StunValue.Value > 0 then\n\t\t\t\tStunValue.Value = StunValue.Value - (Lose_Stun / 30) / Animation_Speed\n\t\t\telseif StunValue.Value > Max_Stun then\n\t\t\t\tStunValue.Value = Max_Stun\n\t\t\telseif StunValue.Value <= 0 then\n\t\t\t\tStunValue.Value = 0\n\t\t\tend\n\t\tend\n\telse\n\t\tStunValue.Value = 0\n\tend\n\tif Enable_Abilities == true then\n\t\tif CO1 <= Cooldown_1 then\n\t\t\tCO1 = CO1 + (1 / 30) / Animation_Speed\n\t\telseif CO1 >= Cooldown_1 then\n\t\t\tCO1 = Cooldown_1\n\t\tend\n\t\tif CO2 <= Cooldown_2 then\n\t\t\tCO2 = CO2 + (1 / 30) / Animation_Speed\n\t\telseif CO2 >= Cooldown_2 then\n\t\t\tCO2 = Cooldown_2\n\t\tend\n\t\tif CO3 <= Cooldown_3 then\n\t\t\tCO3 = CO3 + (1 / 30) / Animation_Speed\n\t\telseif CO3 >= Cooldown_3 then\n\t\t\tCO3 = Cooldown_3\n\t\tend\n\t\tif CO4 <= Cooldown_4 then\n\t\t\tCO4 = CO4 + (1 / 30) / Animation_Speed\n\t\telseif CO4 >= Cooldown_4 then\n\t\t\tCO4 = Cooldown_4\n\t\tend\n\tend\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\nfunction NewEffect(cframe,name,colour,meshid,texture,scale)\nlocal part = Instance.new(\"Part\")\npart.Size = Vector3.new(1,1,1)\npart.CFrame = cframe\npart.Name = \"Part\"\npart.BrickColor = colour\npart.Parent = Effects\npart.Anchored = true\npart.CanCollide = false\nlocal emesh = Instance.new(\"SpecialMesh\")\nemesh.MeshId = meshid\nemesh.TextureId = texture\nemesh.Parent = part\nemesh.Scale = scale\nend\n\n\n\n--//=================================\\\\\n--||\tATTACK FUNCTIONS AND STUFF\n--\\\\=================================//\n\n\n\n\nfunction StaggerHitAnimation()\n\tATTACK = true\n\tif Weapon:FindFirstChild(\"Hitbox\") ~= nil then\n\t\tfor i = 1, MRANDOM(2, 4) do\n\t\t\tClangEffect(\"Bright yellow\", \"Neon\", CF(Weapon:FindFirstChild(\"Hitbox\").Position) * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), 20, 5, 0.2, MRANDOM(5, 15) / 10, 0, -0.02, 0, -0.02, 0.1)\n\t\tend\n\tend\n\tfor i = 0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-10), RAD(0), RAD(-30)), 0.3 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(30)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.3 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-30), RAD(0), RAD(60)) * ANGLES(RAD(0), RAD(-30), RAD(0)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(0), RAD(-20)) * ANGLES(RAD(0), RAD(20), RAD(0)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.9 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-20)), 0.3 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1.1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(10)), 0.3 / Animation_Speed)\n\t\tif Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n\tATTACK = false\nend\n\nfunction StaggerAnimation()\n\tATTACK = true\n\tif Weapon:FindFirstChild(\"Hitbox\") ~= nil then\n\t\tfor i = 1, MRANDOM(2, 4) do\n\t\t\tClangEffect(\"Bright yellow\", \"Neon\", CF(Weapon:FindFirstChild(\"Hitbox\").Position) * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), 20, 5, 0.2, MRANDOM(5, 15) / 10, 0, -0.02, 0, -0.02, 0.1)\n\t\tend\n\tend\n\tDISABLEJUMPING = true\n\tCOMBO = 1\n\tStatLabel(\"Interruption\", Head.CFrame * CF(0, 0 + (Head.Size.z - 1), 0), \"Staggered!\", C3(255 / 255, 255 / 255, 0))\n\tlocal STAGGERVELOCITY = Instance.new(\"BodyVelocity\",Torso)\n\tSTAGGERVELOCITY.P = 500\n\tSTAGGERVELOCITY.maxForce = VT(math.huge, 0, math.huge)\n\tif Rooted.Value == false then\n\t\tSTAGGERVELOCITY.Velocity = RootPart.CFrame.lookVector * -40\n\tend\n\tfor i = 0, 1, 0.35 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.3 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(20)), 0.3 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size,0 * Player_Size) * ANGLES(RAD(-15), RAD(0), RAD(30)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size,0 * Player_Size) * ANGLES(RAD(-7.5), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size,0 * Player_Size) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(30)), 0.3 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size,0 * Player_Size) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.3 / Animation_Speed)\n\tend\n\tfor i = 0, 1, 0.2 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(-25), RAD(0), RAD(-20)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-15), RAD(0), RAD(30)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-7.5), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(50)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.4 / Animation_Speed)\n\tend\n\tSTAGGERVELOCITY.Parent = nil\n\tfor i = 1, 50 * Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -1.8 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-20)) * ANGLES(RAD(-5), RAD(-5), RAD(0)), 0.3 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(20), RAD(0), RAD(20)) * ANGLES(RAD(0), RAD(5), RAD(0)), 0.3 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(20)) * ANGLES(RAD(0), RAD(-20), RAD(0)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-15), RAD(0), RAD(-10)) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.4 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(70)) * ANGLES(RAD(0), RAD(30), RAD(0)), 0.3 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, 0.5 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2.5), RAD(0), RAD(-10)), 0.3 / Animation_Speed)\n\tend\n\tDISABLEJUMPING = false\n\tATTACK = false\nend\n\nfunction StunAnimation()\n\tATTACK = true\n\tDISABLEJUMPING = true\n\tCOMBO = 1\n\tStatLabel(\"Interruption\", Head.CFrame * CF(0, 0 + (Head.Size.z - 1), 0), \"Stunned!\", C3(255 / 255, 255 / 255, 0))\n\tfor i = 0, 1, 0.3 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.05 * Player_Size) * ANGLES(RAD(15), RAD(0), RAD(-150)), 0.3 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(-20)), 0.3 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(30), RAD(0), RAD(40)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(0), RAD(-50)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(30)), 0.3 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(20)), 0.3 / Animation_Speed)\n\tend\n\tfor i = 0, 1, 0.3 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.05 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(-180)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-15), RAD(0), RAD(-30)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(30), RAD(0), RAD(40)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(0), RAD(-50)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(15)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(50)), 0.4 / Animation_Speed)\n\tend\n\tfor i = 0, 1, 0.3 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(75), RAD(0), RAD(-180)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-15), RAD(0), RAD(-60)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(20), RAD(0), RAD(70)) * ANGLES(RAD(0), RAD(30), RAD(0)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-10), RAD(0), RAD(-80)) * ANGLES(RAD(0), RAD(-40), RAD(0)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(10)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(80)), 0.4 / Animation_Speed)\n\tend\n\tfor i = 1, 70 * Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -2.5 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-180)), 0.3 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.3 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(-10), RAD(90)) * RIGHTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.3 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0.2 * Player_Size) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.3 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.3 / Animation_Speed)\n\tend\n\tfor i = 0, 1, 0.2 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -1.5 * Player_Size) * ANGLES(RAD(20), RAD(0), RAD(100)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-30)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(-10), RAD(30)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(80), RAD(0), RAD(20)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(70)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.25 * Player_Size, -1 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(20)), 0.4 / Animation_Speed)\n\tend\n\tDISABLEJUMPING = false\n\tATTACK = false\nend\n\nfunction EAbility()\n\tATTACK = true\n\tATTACK = false\nend\n\nfunction Attack1()\n\tATTACK = true\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-50)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5), RAD(0), RAD(15)), 0.4 / Animation_Speed)\n\t    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0.5 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(5)) * ANGLES(RAD(0), RAD(-30), RAD(0)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-25), RAD(0), RAD(-35)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t    RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-5)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size, -0.075 * Player_Size) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-2.5), RAD(0), RAD(-15)), 0.4 / Animation_Speed)\n\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-110), RAD(90), RAD(0)), 0.4 / Animation_Speed)\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n\tCreateSound(\"553461718\", LeftArm, 1.2, MRANDOM(7, 9) / 10)\n\tfor i=0, 1, 0.1 / Animation_Speed*5 do\n\t\tSwait()\n\t\tlocal Pos = HitboxPart\n\t\tlocal Offset = HitboxPart.CFrame * CF(0, 0.1 * Player_Size, 0)\n\t\tlocal Color = \"Cyan\"\n\t\tlocal Material = \"Neon\"\n\t\tlocal TheDelay = 0.01\n\t\tlocal Height = 6.2 * Player_Size\n\t\tBLCF = Offset\n\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-10)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(2.5), RAD(0), RAD(10)), 0.4 / Animation_Speed)\n\t    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-25)) * ANGLES(RAD(0), RAD(-30), RAD(0)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed*4)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-15), RAD(0), RAD(-55)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2.5), RAD(0), RAD(5)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-15)), 0.4 / Animation_Speed)\n\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-130), RAD(90), RAD(0)), 0.4 / Animation_Speed)\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n    shockwaveright()\n\tBLCF = nil\n\tSCFR = nil\n\tATTACK = false\nend\n\nfunction Burst()\n\tATTACK = true\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 3 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(90), RAD(0)), 0.2 / Animation_Speed)\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n\tCreateSound(\"553461718\", LeftArm, 1.2, MRANDOM(7, 9) / 10)\n    SilenceRoar()\n\tfor i=0, 1, 0.1 / Animation_Speed*5 do\n\t\tSwait()\n\t\tlocal Pos = HitboxPart\n\t\tlocal Offset = HitboxPart.CFrame * CF(0, 0.1 * Player_Size, 0)\n\t\tlocal Color = \"Cyan\"\n\t\tlocal Material = \"Neon\"\n\t\tlocal TheDelay = 0.01\n\t\tlocal Height = 6.2 * Player_Size\n\t\tBLCF = Offset\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(90), RAD(0)), 0.2 / Animation_Speed)\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n\tBLCF = nil\n\tSCFR = nil\n\tATTACK = false\nend\n\nfunction ray()\n\tATTACK = true\n\tlocal FIREEFFECTCOLORS = {\"Really black\", \"White\", \"Maroon\"}\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tMagicBlock(FIREEFFECTCOLORS[MRANDOM(1, #FIREEFFECTCOLORS)], \"Neon\", LeftArm.CFrame * CF(0 * Player_Size, MRANDOM(-15, -10) / 10 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), 0, RAD(MRANDOM(-360, 360))), CF(0, 0, -0.1) * ANGLES(0, 0, RAD(MRANDOM(-20, 20))), VT(0, 1, 0), 1, 1, 1, -0.05, -0.05, -0.05, 0.05)\n\t\t--MagicBlock(FIREEFFECTCOLORS[MRANDOM(1, #FIREEFFECTCOLORS)], \"Neon\", RootPart.CFrame * CF(0 * Player_Size, MRANDOM(-2, 2) * Player_Size, 0 * Player_Size) * ANGLES(0, RAD(MRANDOM(-360, 360)), 0), CF(0, MRANDOM(5, 10) / 100, 0) * ANGLES(0, RAD(MRANDOM(-10, 10)), 0), VT(MRANDOM(20, 40) / 10, 0, 0), 1, 1, 1, -0.05, -0.05, -0.05, 0.05)\n\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(5), RAD(0), RAD(-40)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(35)) * ANGLES(RAD(2.5), RAD(0), RAD(0)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.75 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(50)) * ANGLES(RAD(80), RAD(-20), RAD(-30)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-7.5), RAD(0), RAD(-5)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size, 0.05 * Player_Size) * ANGLES(RAD(0), RAD(-40), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-10)), 0.4 / Animation_Speed)\n\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(-20), RAD(90), RAD(0)), 0.4 / Animation_Speed)\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n    local framed = CFrame.new(Mouse.hit.p.X,Mouse.hit.p.Y+250,Mouse.hit.p.Z)\n    local cloud = NewEffect(framed,\"Cloud\",BrickColor.new(\"Dark stone grey\"),\"http://www.roblox.com/asset/?id=111820358\",\"\",Vector3.new(1000,150,1000))\n\tCreateSound(\"267154400\", workspace, 10, MRANDOM(9, 11) / 10)\n\tMagicBlock(\"Really black\", \"Neon\", LeftArm.CFrame * CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), ANGLES(0, 0, 0), VT(0, 0, 0), 5, 5, 5, 0.5, 0.5, 0.5, 0.05)\n\tMagicBlock(\"White\", \"Neon\", LeftArm.CFrame * CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), ANGLES(0, 0, 0), VT(0, 0, 0), 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.05)\n\tMagicBlock(\"Maroon\", \"Neon\", LeftArm.CFrame * CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), ANGLES(0, 0, 0), VT(0, 0, 0), 0.05, 0.05, 0.05, 0.5, 0.5, 0.5, 0.05)\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(5), RAD(0), RAD(-30)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(25)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.25 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-20 + MRANDOM(-2.5, 2.5))) * ANGLES(RAD(70 + MRANDOM(-2.5, 2.5)), RAD(40), RAD(0)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-7.5)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size, 0.05 * Player_Size) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-2.5), RAD(0), RAD(-12.5)), 0.4 / Animation_Speed)\n\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(-20), RAD(90), RAD(0)), 0.4 / Animation_Speed)\n\t\t--[[RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(5), RAD(0), RAD(40)), 0.4 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-30)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.4 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-10 + MRANDOM(-2.5, 2.5))) * ANGLES(RAD(40 + MRANDOM(-2.5, 2.5)), RAD(70), RAD(20)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(60), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(10)), 0.4 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-7.5), RAD(0), RAD(5)), 0.4 / Animation_Speed)\n\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, -0.25 * Player_Size) * ANGLES(RAD(-20), RAD(90), RAD(0)), 0.4 / Animation_Speed)]]--\n\t\tif StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true then\n\t\t\tbreak\n\t\tend\n\tend\n    wait(1)\n\tCreateSound(\"438666077\", workspace, 10, MRANDOM(9, 11) / 10)\n    wait(0.2)\n\t--CreateSound(\"444667859\", workspace, 10, MRANDOM(4, 6) / 10)\n    local cm = Instance.new(\"CylinderMesh\")\n    local cm2 = cm:Clone()\n    local death = Instance.new(\"Part\")\n    death.CFrame = CFrame.new(framed.X,framed.Y-250,framed.Z)\n    death.Material = \"Neon\"\n    death.BrickColor = BrickColor.new(\"Really black\")\n    death.Size = Vector3.new(25,600,25)\n    death.Transparency = 0.25\n    death.Parent = Effects\n    death.CanCollide = false\n    death.Anchored = true\n    cm.Parent = death\n    local death2 = Instance.new(\"Part\")\n    death2.CFrame = CFrame.new(framed.X,framed.Y-250,framed.Z)\n    death2.Material = \"Neon\"\n    death2.BrickColor = BrickColor.new(\"White\")\n    death2.Size = Vector3.new(27,600,27)\n    death2.Parent = Effects\n    death2.CanCollide = false\n    death2.Anchored = true\n    cm2.Parent = death2\n    local exp = Instance.new(\"Part\")\n    exp.Parent = Effects\n    exp.Size = Vector3.new(1,1,1)\n    exp.Anchored = true\n    exp.Transparency = 0\n    exp.CanCollide = false\n    exp.CFrame = death.CFrame\n    exp.BrickColor = BrickColor.new(\"Really black\")\n    exp.Material = \"Neon\"\n    local meshe = Instance.new(\"SpecialMesh\")\n    meshe.MeshType = \"Sphere\"\n    meshe.Parent = exp\n    meshe.Scale = Vector3.new(0.8,0.8,0.8)\n    local exp2 = Instance.new(\"Part\")\n    exp2.Parent = Effects\n    exp2.Size = Vector3.new(1,1,1)\n    exp2.Anchored = true\n    exp2.Transparency = 0.25\n    exp2.CanCollide = false\n    exp2.CFrame = death.CFrame\n    exp2.BrickColor = BrickColor.new(\"White\")\n    exp2.Material = \"Neon\"\n    local meshe2 = Instance.new(\"SpecialMesh\")\n    meshe2.MeshType = \"Sphere\"\n    meshe2.Parent = exp2\n    meshe2.Scale = Vector3.new(1,1,1)\n    local shockwave = Instance.new(\"Part\")\n    shockwave.CanCollide = false\n    shockwave.Anchored = true\n    shockwave.Parent = Effects\n    shockwave.BrickColor = BrickColor.new(\"Really black\")\n    local meshg = Instance.new(\"SpecialMesh\")\n    meshg.MeshId = \"http://www.roblox.com/asset/?id=20329976\"\n    meshg.Parent = shockwave\n    meshg.Scale = Vector3.new(3, 12, 3)\n    shockwave.CFrame = death.CFrame\n    SIZE = 25\n    for size = 1, 45 do\n    MagnitudeDamage(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, exp, 20, false, 100, 100, MRANDOM(35, 50), \"Normal\", RootPart, 0.5, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\n\t\t\t\tMagicBlock(\"White\", \"Neon\", death.CFrame * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), ANGLES(RAD(MRANDOM(-5, 5)), RAD(MRANDOM(-5, 5)), RAD(MRANDOM(-5, 5))), VT(0, 0, 0), SIZE, SIZE, SIZE, SIZE / 3, SIZE / 3, SIZE / 3, 0.05)\n\t\t\t\tMagicBlock(\"Really black\", \"Neon\", death.CFrame * ANGLES(RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50)), RAD(MRANDOM(-50, 50))), ANGLES(RAD(MRANDOM(-5, 5)), RAD(MRANDOM(-5, 5)), RAD(MRANDOM(-5, 5))), VT(0, 0, 0), SIZE * 0.75, SIZE * 0.75, SIZE * 0.75, SIZE / 4, SIZE / 4, SIZE / 4, 0.05)\n        meshe.Scale = meshe.Scale + Vector3.new(6,6,6)\n        exp.Transparency = exp.Transparency + (1/45)\n        meshe2.Scale = meshe2.Scale + Vector3.new(6,6,6)\n        exp2.Transparency = exp2.Transparency + (1/45)\n        cm.Scale = cm.Scale - Vector3.new(1/45,0,1/45)\n        cm2.Scale = cm2.Scale - Vector3.new(1/45,0,1/45)\n        shockwave.Transparency = shockwave.Transparency + 1/45\n        meshg.Scale = meshg.Scale + Vector3.new(8,3,8)\n        wait(0.025)\n    end\n    exp:Destroy()\n    exp2:Destroy()\n    death:Destroy()\n    death2:Destroy()\n    wait(1.2)\n    Effects:ClearAllChildren()\n\tATTACK = false\nend\n\nfunction Move2()\n\tATTACK = true\n\tATTACK = false\nend\n\nfunction Move3()\n\tATTACK = true\n\tATTACK = false\nend\n\nfunction Move4()\n\tATTACK = true\n\tATTACK = false\nend\n\nfunction shockwaveright()\nlocal shockwave = Instance.new(\"Part\")\nCreateSound(\"260430189\", LeftArm, 4, MRANDOM(7, 9) / 10)\nshockwave.CanCollide = false\nshockwave.Anchored = true\nshockwave.Parent = Character\nshockwave.BrickColor = BrickColor.new(\"Really black\")\nlocal meshg = Instance.new(\"SpecialMesh\")\nmeshg.MeshId = \"http://www.roblox.com/asset/?id=20329976\"\nmeshg.Parent = shockwave\nmeshg.Scale = Vector3.new(3, 12, 3)\nshockwave.CFrame = RightArm.CFrame\nMagnitudeDamage(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, LeftArm, 5, false, 65, 70, MRANDOM(35, 50), \"Normal\", RootPart, 0.5, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\nfor i = 1,20 do\n    shockwave.Transparency = shockwave.Transparency + 0.05\n    meshg.Scale = meshg.Scale + Vector3.new(1,0,1)\n    wait(0.025)\nend\nshockwave:Destroy()\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n--//=================================\\\\\n--||\t      SET THINGS UP\n--\\\\=================================//\n\n\n--//=================================\\\\\n--\\\\=================================//\n\n\nfunction SilenceRoar()\n\tCreateSound(\"199149137\", Torso, 10, 1)\n    local exp = Instance.new(\"Part\")\n    exp.Parent = Character\n    exp.Size = Vector3.new(1,1,1)\n    exp.Anchored = true\n    exp.Transparency = 0.25\n    exp.CanCollide = false\n    exp.CFrame = Torso.CFrame\n    exp.BrickColor = BrickColor.new(\"Really black\")\n    exp.Material = \"Neon\"\n    local meshe = Instance.new(\"SpecialMesh\")\n    meshe.MeshType = \"Sphere\"\n    meshe.Parent = exp\n    local exp2 = Instance.new(\"Part\")\n    exp2.Parent = Character\n    exp2.Size = Vector3.new(70,70,70)\n    exp2.Anchored = true\n    exp2.Transparency = 0.25\n    exp2.CanCollide = false\n    exp2.CFrame = Torso.CFrame\n    exp2.BrickColor = BrickColor.new(\"Really black\")\n    exp2.Material = \"Neon\"\n    local meshe2 = Instance.new(\"SpecialMesh\")\n    meshe2.MeshType = \"Sphere\"\n    meshe2.Parent = exp2\n    for size = 1, 25 do\n    MagnitudeDamage(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, Torso, 12, false, 65, 70, MRANDOM(35, 50), \"Normal\", RootPart, 0.5, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\n        meshe.Scale = meshe.Scale + Vector3.new(7,7,7)\n        exp.Transparency = exp.Transparency + (1/25)\n        meshe2.Scale = meshe2.Scale - Vector3.new(1/25,1/25,1/25)\n        exp2.Transparency = exp2.Transparency + (1/25)\n        exp.CFrame = Torso.CFrame\n        exp2.CFrame = Torso.CFrame\n        wait(0.00025)\n    end\n    for size = 1, 25 do\n    MagnitudeDamage(HITWEAPONSOUNDS[MRANDOM(1, #HITWEAPONSOUNDS)], HITARMORSOUNDS[MRANDOM(1, #HITARMORSOUNDS)], HITBLOCKSOUNDS[MRANDOM(1, #HITBLOCKSOUNDS)], HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], 1, 1, 1, 1, Torso, 12, false, 65, 70, MRANDOM(35, 50), \"Normal\", RootPart, 0.5, 1, MRANDOM(5, 10), nil, true, false, nil, 0, 0, false)\n        meshe.Scale = meshe.Scale + Vector3.new(7,7,7)\n        exp.Transparency = exp.Transparency + (1/25)\n        meshe2.Scale = meshe2.Scale - Vector3.new(1/25,1/25,1/25)\n        exp2.Transparency = exp2.Transparency + (1/25)\n        exp.CFrame = Torso.CFrame\n        exp2.CFrame = Torso.CFrame\n        wait(0.00025)\n    end\n    exp:Destroy()\nend\n\nfunction Shield()\n    TIMER = 1\n    Humanoid.WalkSpeed = 0\n    ATTACK = true\n    j = Character:GetChildren()\n    for m = 1,#j do\n    if j[m].ClassName == \"Part\" then\n    j[m].Anchored = true\n    end\n    end\n    local ff = Instance.new(\"ForceField\")\n    ff.Parent = Character\n    local exp = Instance.new(\"Part\")\n    exp.Parent = Character\n    exp.Size = Vector3.new(65,65,65)\n    exp.Anchored = true\n    exp.Transparency = 1\n    exp.CanCollide = true\n    exp.Shape = \"Ball\"\n    exp.CFrame = Torso.CFrame\n    exp.BrickColor = BrickColor.new(\"White\")\n    exp.Material = \"Neon\"\n    local meshe = Instance.new(\"SpecialMesh\")\n    meshe.MeshType = \"Sphere\"\n    meshe.Parent = exp\n    meshe.Scale = Vector3.new(0,0,0)\n    local exp2 = Instance.new(\"Part\")\n    exp2.Parent = Character\n    exp2.Size = Vector3.new(64,64,64)\n    exp2.Anchored = true\n    exp2.Transparency = 1\n    exp2.CanCollide = true\n    exp2.Shape = \"Ball\"\n    exp2.CFrame = Torso.CFrame\n    exp2.BrickColor = BrickColor.new(\"Really black\")\n    exp2.Material = \"Neon\"\n    local meshe2 = Instance.new(\"SpecialMesh\")\n    meshe2.MeshType = \"Sphere\"\n    meshe2.Parent = exp2\n    meshe2.Scale = Vector3.new(0,0,0)\n    for i = 1,20 do\n        meshe.Scale = meshe.Scale + Vector3.new(0.05,0.05,0.05)\n        meshe2.Scale = meshe2.Scale + Vector3.new(0.05,0.05,0.05)\n        exp.Transparency = exp.Transparency - (0.25/20)\n        exp2.Transparency = exp2.Transparency - 0.1\n    wait(0.01)\n    end\n    while true do\n        if HOLDSHIELD == true and TIMER == 1 then\n            meshe.Scale = meshe.Scale + Vector3.new(0.01,0.01,0.01)\n            meshe2.Scale = meshe2.Scale - Vector3.new(0.01,0.01,0.01)\n            TIMER = 2\n            wait(0.1)\n        elseif HOLDSHIELD == true and TIMER == 2 then\n            meshe.Scale = meshe.Scale - Vector3.new(0.01,0.01,0.01)\n            meshe2.Scale = meshe2.Scale + Vector3.new(0.01,0.01,0.01)\n            TIMER = 1\n            wait(0.1)\n        elseif HOLDSHIELD == false then\n            ff:Destroy()\n            y = meshe.Scale.X\n            x = meshe2.Scale.X\n            for i = 1,20 do\n                exp.CanCollide = false\n                exp2.CanCollide = false\n                meshe.Scale = meshe.Scale - Vector3.new(y/20,y/20,y/20)\n                meshe2.Scale = meshe2.Scale - Vector3.new(x/20,x/20,x/20)\n                exp.Transparency = exp.Transparency + (0.75/20)\n                exp2.Transparency = exp2.Transparency + 0.05\n                wait(0.05)\n            end\n        break\n        end\n    end\n    j = Character:GetChildren()\n    for m = 1,#j do\n    if j[m].ClassName == \"Part\" then\n    j[m].Anchored = false\n    end\n    end\n    exp:Destroy()\n    exp2:Destroy()\n    ATTACK = false\n    Humanoid.WalkSpeed = 45\nend\n\n--//=================================\\\\\n--||\t  ASSIGN THINGS TO KEYS\n--\\\\=================================//\n\nHumanoid.Changed:connect(function(Jump)\n\tif Jump == \"Jump\" and (Disable_Jump == true or DISABLEJUMPING == true) then\n\t\tHumanoid.Jump = false\n\tend\nend)\n\nfunction MouseDown(Mouse)\nHOLD = true\nend\n\nfunction MouseUp(Mouse)\nHOLD = false\nend\n\nfunction KeyDown(Key)\n\tif Key == \"f\" and Can_Equip_Or_Unequip == true and ATTACK == false then\n\t\tATTACK = true\n\t\tCOMBO = 1\n\t\tif EQUIPPED == false then\n\t\t\tEQUIPPED = true\n\t\t\tif Disable_Animate == true then\n\t\t\t\tANIMATE.Parent = nil\n\t\t\t\tlocal IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)\n\t\t\t\tIDLEANIMATION:Play()\n\t\t\tend\n\t\t\tif Disable_Animator == true then\n\t\t\t\tANIMATOR.Parent = nil\n\t\t\tend\n\t\t\tSwait()\n\t\telseif EQUIPPED == true then\n\t\tend\n\t\tATTACK = false\n\tend\n\tif Key == \"e\" and EQUIPPED == true and ATTACK == false then\n        Attack1()\n\tend\n\tif Key == \"z\" and EQUIPPED == true and ATTACK == false and CO1 >= Cooldown_1 and Mana.Value >= Skill_1_Mana_Cost then\n    HOLDSHIELD = true\n    Shield()\n\tend\n\tif Key == \"x\" and EQUIPPED == true and ATTACK == false and CO2 >= Cooldown_2 and Mana.Value >= Skill_2_Mana_Cost then\n\tend\n\tif Key == \"c\" and EQUIPPED == true and ATTACK == false and CO3 >= Cooldown_3 and Mana.Value >= Skill_3_Mana_Cost then\n\tend\n\tif Key == \"v\" and EQUIPPED == true and ATTACK == false and CO4 >= Cooldown_4 and Mana.Value >= Skill_4_Mana_Cost then\n\tBurst()\n\tend\n\t\tif Key == \"p\" and ATTACK == false and EQUIPPED == true then\n        ray()\n\t\tend\n\t\tif Key == \"[\" then\n\t\t\tStagger.Value = true\n\t\tend\n\t\tif Key == \"]\" then\n\t\t\tStun.Value = true\n\t\tend\nend\n\nfunction KeyUp(Key)\nHOLDSHIELD = false\nend\n\nif Use_HopperBin == false then\n\n\tMouse.Button1Down:connect(function(NEWKEY)\n\t\tMouseDown(NEWKEY)\n\tend)\n\tMouse.Button1Up:connect(function(NEWKEY)\n\t\tMouseUp(NEWKEY)\n\tend)\n\tMouse.KeyDown:connect(function(NEWKEY)\n\t\tKeyDown(NEWKEY)\n\tend)\n\tMouse.KeyUp:connect(function(NEWKEY)\n\t\tKeyUp(NEWKEY)\n\tend)\n\nelseif Use_HopperBin == true then\n\tWEAPONTOOL.Parent = Backpack\n\tscript.Parent = WEAPONTOOL\n\tfunction SelectTool(Mouse)\n\t\tMouse.Button1Down:connect(function()\n\t\t\tMouseDown(Mouse)\n\t\tend)\n\t\tMouse.Button1Up:connect(function()\n\t\t\tMouseUp(Mouse)\n\t\tend)\n\t\tMouse.KeyDown:connect(KeyDown)\n\t\tMouse.KeyUp:connect(KeyUp)\n\tend\n\tfunction DeselectTool(Mouse)\n\tend\n\tWEAPONTOOL.Selected:connect(SelectTool)\n\tWEAPONTOOL.Deselected:connect(DeselectTool)\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--||\tWRAP THE WHOLE SCRIPT UP\n--\\\\=================================//\n\nwhile true do\n\tSwait()\n\tif HitboxPart ~= nil and ATTACK == false and StaggerHit.Value == false and Stagger.Value == false and Stun.Value == false then\n\t\tHitboxPart.Name = \"NilHitbox\"\n\telse\n\t\tHitboxPart.Name = \"Hitbox\"\n\tend\n\tif Enable_Gui == true then\n\t\tUpdateGUI()\n\tend\n\tUpdateSkillsAndStuff()\n\tif Walkspeed_Depends_On_Movement_Value == true then\n\t\tif Movement.Value < 0 or StaggerHit.Value == true or Stagger.Value == true or Stun.Value == true or Rooted.Value == true then\n\t\t\tHumanoid.WalkSpeed = 0\n\t\telse\n\t\t\tHumanoid.WalkSpeed = 16 * Movement.Value * Player_Size\n\t\tend\n\tend\n\tif Enable_Stun == true and StunValue.Value >= Max_Stun then\n\t\tStunValue.Value = 0\n\t\tStun.Value = true\n\tend\n\tif Enable_Stagger_Hit == true then\n\t\tif StaggerHit.Value == true and STAGGERHITANIM == false then\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\tSTAGGERHITANIM = true\n\t\t\t\twhile ATTACK == true do\n\t\t\t\t\tSwait()\n\t\t\t\tend\n\t\t\t\tStaggerHitAnimation()\n\t\t\t\tStaggerHit.Value = false\n\t\t\t\tSTAGGERHITANIM = false\n\t\t\tend))\n\t\tend\n\telse\n\t\tStaggerHit.Value = false\n\tend\n\tif Enable_Stagger == true then\n\t\tif Stagger.Value == true and STAGGERANIM == false then\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\tSTAGGERANIM = true\n\t\t\t\twhile ATTACK == true do\n\t\t\t\t\tSwait()\n\t\t\t\tend\n\t\t\t\tStaggerAnimation()\n\t\t\t\tStagger.Value = false\n\t\t\t\tSTAGGERANIM = false\n\t\t\tend))\n\t\tend\n\telse\n\t\tStagger.Value = false\n\tend\n\tif Enable_Stun == true then\n\t\tif Stun.Value == true and STUNANIM == false then\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\tStunValue.Value = 0\n\t\t\t\tSTUNANIM = true\n\t\t\t\twhile ATTACK == true do\n\t\t\t\t\tSwait()\n\t\t\t\tend\n\t\t\t\tStunAnimation()\n\t\t\t\tStun.Value = false\n\t\t\t\tSTUNANIM = false\n\t\t\tend))\n\t\tend\n\telse\n\t\tStunValue.Value = 0\n\t\tStun.Value = false\n\tend\n\tif DONUMBER >= .5 then\n\t\tHANDIDLE = true\n\telseif DONUMBER <= 0 then\n\t\tHANDIDLE = false\n\tend\n\tif HANDIDLE == false then\n\t\tDONUMBER = DONUMBER + 0.003 / Animation_Speed\n\telse\n\t\tDONUMBER = DONUMBER - 0.003 / Animation_Speed\n\tend\n\tif ATTACK == false then\n\t\tIDLENUMBER = IDLENUMBER + 1\n\telse\n\t\tIDLENUMBER = 0\n\tend\n\tif Enable_Stats == true then\n\t\tfor _, v in pairs (ChangeStat:GetChildren()) do\n\t\t\tif v:FindFirstChild(\"Duration\") ~= nil then\n\t\t\t\tv:FindFirstChild(\"Duration\").Value = v:FindFirstChild(\"Duration\").Value - (1 / 30) / Animation_Speed\n\t\t\t\tif v:FindFirstChild(\"Duration\").Value <= 0 then\n\t\t\t\t\tv.Parent = nil\n\t\t\t\tend\n\t\t\tend\n\t\t\tif v.Name == \"ChangeDefense\" then\n\t\t\t\tCHANGEDEFENSE = CHANGEDEFENSE + v.Value\n\t\t\telseif v.Name == \"ChangeDamage\" then\n\t\t\t\tCHANGEDAMAGE = CHANGEDAMAGE + v.Value\n\t\t\telseif v.Name == \"ChangeMovement\" then\n\t\t\t\tCHANGEMOVEMENT = CHANGEMOVEMENT + v.Value\n\t\t\tend\n\t\tend\n\t\tDefense.Value = 1 + (CHANGEDEFENSE)\n\t\tif Defense.Value <= 0.01 then\n\t\t\tDefense.Value = 0.01\n\t\tend\n\t\tDamage.Value = 1 + (CHANGEDAMAGE)\n\t\tif Damage.Value <= 0 then\n\t\t\tDamage.Value = 0\n\t\tend\n\t\tMovement.Value = 1 + (CHANGEMOVEMENT)\n\t\tif Movement.Value <= 0 then\n\t\t\tMovement.Value = 0\n\t\tend\n\tCHANGEDEFENSE = 0\n\tCHANGEDAMAGE = 0\n\tCHANGEMOVEMENT = 0\n\tend\n\tSINE = SINE + CHANGE\n\tlocal TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude\n\tlocal TORSOVERTICALVELOCITY = RootPart.Velocity.y\n\tlocal LV = Torso.CFrame:pointToObjectSpace(Torso.Velocity - Torso.Position)\n\tlocal HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4 * Player_Size, Character)\n\tlocal WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)\n\tif ANIM == \"Walk\" and EQUIPPED == true and TORSOVELOCITY > 1 then\n\t\tRootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.1 * COS(SINE / (WALKSPEEDVALUE / 2)) * Player_Size) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tNeck.C1 = Clerp(Neck.C1, CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tRightHip.C1 = Clerp(RightHip.C1, CF(0.5 * Player_Size, 0.875 * Player_Size - 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, -0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tLeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5 * Player_Size, 0.875 * Player_Size + 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, 0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\telseif (ANIM ~= \"Walk\" and EQUIPPED == true) or (TORSOVELOCITY < 1) then\n\t\tRootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\tNeck.C1 = Clerp(Neck.C1, CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\tRightHip.C1 = Clerp(RightHip.C1, CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\tLeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\tend\n\tif TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then\n\t\tANIM = \"Jump\"\n\t\tif EQUIPPED == true and ATTACK == false then\n            Humanoid.WalkSpeed = 150\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(90), RAD(0)), 0.2 / Animation_Speed)\n\t\tend\n\telseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then\n\t\tANIM = \"Fall\"\n\t\tif EQUIPPED == true and ATTACK == false then\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(90), RAD(0)), 0.2 / Animation_Speed)\n\t\tend\n\telseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then\n\t\tANIM = \"Idle\"\n\t\tif EQUIPPED == true and ATTACK == false then\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-20)), 0.15 / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(25)), 0.15 / Animation_Speed)\n\t\t    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.25 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1 * Player_Size, 0.2 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(25), RAD(0), RAD(55)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size - 0.05 * COS(SINE / 12) * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-2.5)), 0.15 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size - 0.05 * COS(SINE / 12) * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7.5), RAD(0), RAD(-15)), 0.15 / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-100), RAD(90), RAD(0)), 0.15 / Animation_Speed)\n\t\tend\n\telseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then\n\t\tANIM = \"Walk\"\n\t\tWALK = WALK + 1 / Animation_Speed\n\t\tif WALK >= 15 - (5 * (Humanoid.WalkSpeed / 16 / Player_Size)) then\n\t\t\tWALK = 0\n\t\t\tif WALKINGANIM == true then\n\t\t\t\tWALKINGANIM = false\n\t\t\telseif WALKINGANIM == false then\n\t\t\t\tWALKINGANIM = true\n\t\t\tend\n\t\tend\n\t\tif EQUIPPED == true and ATTACK == false then\n            Humanoid.WalkSpeed = 45\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0.05 * COS(SINE / WALKSPEEDVALUE) * Player_Size, 0 * Player_Size, -0.1 * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-40)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(40)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.25 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1 * Player_Size, 0.2 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(25), RAD(0), RAD(55)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(0.95 * Player_Size, -1 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(0), RAD(130), RAD(0)) * ANGLES(RAD(-1.25 - 2.5 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.9 * Player_Size, 0.25 * Player_Size) * ANGLES(RAD(0), RAD(-50), RAD(0)) * ANGLES(RAD(-2.5 + 2.5 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tHandleWeld.C0 = Clerp(HandleWeld.C0, CF(0 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(90), RAD(0)), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tend\n\tend\n\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//====================================================\\\\--\n--||\t\t\t  \t\t END OF SCRIPT\n--\\\\====================================================//",
 "title": ""
}