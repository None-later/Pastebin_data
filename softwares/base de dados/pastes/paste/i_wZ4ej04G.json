{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "kw_inject",
  "lg_en"
 ],
 "key": "wZ4ej04G",
 "pasteDate": "Feb 21, 2018, 12:14:16 PM",
 "relevancy": 3.0,
 "relevant": false,
 "text": "class FlagSet\n\tclass <<self\n\t\t# frozen flags\n\t\tattr_reader :flags\n\t\t# the amount of possible states\n\t\tattr_reader :states\n\t\t\n\t\t# If this flagset includes certain flag\n\t\tdef include?(flag)\n\t\t\t@position.has_key?(flag)\n\t\tend\n\t\t\n\t\t# Get the Position of a flag\n\t\tdef position(flag)\n\t\t\t@position[flag]\n\t\tend\n\t\t\n\t\t# Convert an integer to this kind of FlagSet\n\t\tdef from(integer)\n\t\t\traise ArgumentError, \"Invalid State, maximum is #{states-1}\" unless integer < states\n\t\t\tnew(*@flags.select { |flag| integer[position(flag)] == 1 })\n\t\tend\n\t\talias from_integer from\n\n\n\t\t# Example:\n\t\t#   MyFlags = FlagSet.new(:a, :b, :c)\n\t\t#   x = MyFlags.new(:a, :b)\n\t\t#   x.a? # => true\n\t\t#   x.b? # => true\n\t\t#   x.c? # => false\n\t\t#   x.c!\n\t\t#   x.a!(false)\n\t\t#   x.a? # => false\n\t\t#   x.b? # => true\n\t\t#   x.c? # => true\n\t\tdef new(*flags)\n\t\t\tstr_flags = flags.map { |flag| flag.to_s }\n\t\t\tsym_flags = []\n\t\t\tposition  = {}\n\t\t\tstr_flags.each_with_index { |flag, index|\n\t\t\t\traise ArgumentError, \"Invalid flag #{flag}\" unless flag =~ /\\A[A-Za-z_][A-Za-z0-9_]*\\z/ && !self.instance_methods.include?(flag)\n\t\t\t\tsym_flag           = flag.to_sym\n\t\t\t\tposition[sym_flag] = index\n\t\t\t\tsym_flags         << sym_flag\n\t\t\t}\n\t\t\tflagset = Class.new(FlagSet)\n\t\t\tflagset.instance_variable_set(\"@flags\", sym_flags)\n\t\t\tflagset.instance_variable_get(\"@flags\").freeze\n\t\t\tflagset.instance_variable_set(\"@position\", position)\n\t\t\tflagset.instance_variable_set(\"@states\", 2**(str_flags.length))\n\t\t\tstr_flags.each_with_index { |flag, position|\n\t\t\t\tflagset.class_eval(\"def #{flag}?; @value[#{position}] == 1; end\")\n\t\t\t\tflagset.class_eval(\"def #{flag}!(set=true); if set then @value |= #{2**position} else @value &= #{2**position} end; end\")\n\t\t\t}\n\t\t\tclass <<flagset; define_method(:new, (class <<Object; instance_method(:new); end)); end # restore new-method\n\t\t\tflagset\n\t\tend\n\tend\n\n\tdef initialize(*flags)\n\t\tflags  = flags.map { |flag| flag.to_sym }\n\t\t@value = flags.inject(0) { |sum, flag|\n\t\t\traise ArgumentError, \"Invalid flag #{flag}\" unless position = self.class.position(flag)\n\t\t\tsum + 2**position\n\t\t}\n\tend\n\t\n\t# Flagwise AND (returns a FlagSet with all Flags set in both)\n\tdef &(other)\n\t\tself.class.from(other.to_i & self.to_i)\n\tend\n\n\t# Flagwise OR (returns a FlagSet with all Flags set in either)\n\tdef |(other)\n\t\tself.class.from(other.to_i | self.to_i)\n\tend\n\t\n\t# Flagwise exclusive OR (returns a FlagSet with all Flags set in only one of either)\n\tdef ^(other)\n\t\tself.class.from(other.to_i ^ self.to_i)\n\tend\n\t\n\t# An Integer-representation of the FlagSet \n\tdef to_i\n\t\t@value\n\tend\n\t\n\t# The flags set in this FlagSet\n\tdef flags\n\t\tflags = []\n\t\tself.class.flags.each_with_index { |flag, index| flags << flag if @value[index] == 1 }\n\t\tflags\n\tend\nend\n\nif __FILE__ == $0 then\n\tPermission = FlagSet.new(\n\t\t:owner_execute,\n\t\t:owner_read,\n\t\t:owner_write,\n\t\t:group_execute,\n\t\t:group_read,\n\t\t:group_write,\n\t\t:world_execute,\n\t\t:world_read,\n\t\t:world_write\n\t)\n\t\n\tp [\"states\", Permission.states] # => true\n\tp x = Permission.new(:owner_execute)\n\tp (x.methods - Object.methods).sort\n\tp [\"owner_execute?\", x.owner_execute?] # => true\n\tp [\"world_read?\", x.world_read?] # => false\n\tp [\"world_read!\", x.world_read!]\n\tp [\"world_read?\", x.world_read?] # => true\n\tp [\"x.to_i\", i = x.to_i] # => 1\n\ty = Permission.from_integer(i)\n\tp [\"y\", y]\n\tp [\"y.flags\", y.flags] #=> [:owner_execute, :world_read]\n\tz = Permission.new(:group_write, :owner_execute)\n\tp [\"(z | y).flags\", (z | y).flags]\n\tp [\"(z & y).flags\", (z & y).flags]\n\tp [\"(z ^ y).flags\", (z ^ y).flags]\nend",
 "title": ""
}