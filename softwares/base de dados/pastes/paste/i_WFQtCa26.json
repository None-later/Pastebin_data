{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "re_sql",
  "re_url",
  "lg_en",
  "re_ast1"
 ],
 "key": "WFQtCa26",
 "pasteDate": "Feb 11, 2018, 10:06:43 PM",
 "relevancy": 1.0,
 "relevant": false,
 "text": "--//=========================\\\\--\n--||  CREATED BY SHACKLUSTER ||--\n--\\\\=========================//--\n\nwait(0.2)\n\nPlayer = game:GetService(\"Players\").LocalPlayer\nPlayerGui = Player.PlayerGui\nCam = workspace.CurrentCamera\nBackpack = Player.Backpack\nCharacter = Player.Character\nHumanoid = Character.Humanoid\nMouse = Player:GetMouse()\nRootPart = Character[\"HumanoidRootPart\"]\nTorso = Character[\"Torso\"]\nHead = Character[\"Head\"]\nRightArm = Character[\"Right Arm\"]\nLeftArm = Character[\"Left Arm\"]\nRightLeg = Character[\"Right Leg\"]\nLeftLeg = Character[\"Left Leg\"]\nRootJoint = RootPart[\"RootJoint\"]\nNeck = Torso[\"Neck\"]\nRightShoulder = Torso[\"Right Shoulder\"]\nLeftShoulder = Torso[\"Left Shoulder\"]\nRightHip = Torso[\"Right Hip\"]\nLeftHip = Torso[\"Left Hip\"]\nlocal sick = Instance.new(\"Sound\",Character)\nsick.SoundId = \"rbxassetid://1340429079\"\nsick.Looped = true\nsick.Pitch = 1\nsick.Volume = 10\nsick:Play()\nlocal sick2 = Instance.new(\"Sound\",Character)\nsick2.SoundId = \"rbxassetid://130844430\"\nsick2.Looped = true\nsick2.Pitch = 1\nsick2.Volume = 10\nHumanoid.DisplayDistanceType = \"None\"\nPlayer:ClearCharacterAppearance()\n\nIT = Instance.new\nCF = CFrame.new\nVT = Vector3.new\nRAD = math.rad\nC3 = Color3.new\nUD2 = UDim2.new\nBRICKC = BrickColor.new\nANGLES = CFrame.Angles\nEULER = CFrame.fromEulerAnglesXYZ\nCOS = math.cos\nACOS = math.acos\nSIN = math.sin\nASIN = math.asin\nABS = math.abs\nMRANDOM = math.random\nFLOOR = math.floor\n\nfunction CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)\n\tlocal NEWMESH = IT(MESH)\n\tif MESH == \"SpecialMesh\" then\n\t\tNEWMESH.MeshType = MESHTYPE\n\t\tif MESHID ~= \"nil\" and MESHID ~= \"\" then\n\t\t\tNEWMESH.MeshId = \"http://www.roblox.com/asset/?id=\"..MESHID\n\t\tend\n\t\tif TEXTUREID ~= \"nil\" and TEXTUREID ~= \"\" then\n\t\t\tNEWMESH.TextureId = \"http://www.roblox.com/asset/?id=\"..TEXTUREID\n\t\tend\n\tend\n\tNEWMESH.Offset = OFFSET or VT(0, 0, 0)\n\tNEWMESH.Scale = SCALE\n\tNEWMESH.Parent = PARENT\n\treturn NEWMESH\nend\n\nfunction CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)\n\tlocal NEWPART = IT(\"Part\")\n\tNEWPART.formFactor = FORMFACTOR\n\tNEWPART.Reflectance = REFLECTANCE\n\tNEWPART.Transparency = TRANSPARENCY\n\tNEWPART.CanCollide = false\n\tNEWPART.Locked = true\n\tNEWPART.Anchored = true\n\tif ANCHOR == false then\n\t\tNEWPART.Anchored = false\n\tend\n\tNEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))\n\tNEWPART.Name = NAME\n\tNEWPART.Size = SIZE\n\tNEWPART.Position = Torso.Position\n\tNEWPART.Material = MATERIAL\n\tNEWPART:BreakJoints()\n\tNEWPART.Parent = PARENT\n\treturn NEWPART\nend\n\n\n\nlocal HBill = Instance.new(\"BillboardGui\",Head)\nlocal HMain, HBar = Instance.new(\"Frame\", HBill), Instance.new(\"Frame\")\nlocal HName = Instance.new(\"TextLabel\")\nHBill.Size = UDim2.new(15,0,2.2,0)\nHBill.Name = \"Health Display\"\nHBill.StudsOffset = Vector3.new(3.675,2,0)\nHBill.AlwaysOnTop = true\nHBill.Enabled = true\nHMain.BackgroundColor3 = Color3.new(0, 0, 0)\nHMain.BackgroundTransparency = 1\nHMain.Size = UDim2.new(.5,0,.5,0)\nHName.Parent = HMain\nHName.BackgroundTransparency = 1\nHName.BackgroundColor3 = Color3.new(0,0,0)\nHName.BorderColor3 = Color3.new(0,0,0)\nHName.BorderSizePixel = 2\nHName.Size = UDim2.new(1,0,.75,0)\nHName.Font = \"SciFi\"\nHName.Text = \"Eterna\"\nHName.TextScaled = true\nHName.TextColor3 = Color3.new(0,0,0)\nHName.TextStrokeColor3 = Color3.new(0,0,0)\nHName.TextStrokeTransparency = 0\nHName.TextYAlignment = \"Bottom\"\n\n\n--//=================================\\\\\n--||\t\t  CUSTOMIZATION\n--\\\\=================================//\n\nClass_Name = \"SatanBot.exe\"\nWeapon_Name = \"Add-ons\"\n\nCustom_Colors = {\n\tCustom_Color_1 = BRICKC(\"Institutional white\"); --1st color for the weapon.\n\tCustom_Color_2 = BRICKC(\"Institutional white\"); --2nd color for the weapon.\n\n\tCustom_Color_3 = BRICKC(\"Institutional white\"); --Color for the abilities.\n\tCustom_Color_4 = BRICKC(\"Institutional white\"); --Color for the secondary bar.\n\tCustom_Color_5 = BRICKC(\"Institutional white\"); --Color for the mana bar.\n\tCustom_Color_6 = BRICKC(\"Institutional white\"); --Color for the health bar.\n\tCustom_Color_7 = BRICKC(\"Institutional white\"); --Color for the stun bar.\n\n\tCustom_Color_8 = BRICKC(\"Institutional white\"); --Background for the mana bar.\n\tCustom_Color_9 = BRICKC(\"Institutional white\"); --Background for the secondary mana bar.\n\tCustom_Color_10 = BRICKC(\"Institutional white\"); --Background for the stun bar.\n\tCustom_Color_11 = BRICKC(\"Institutional white\"); --Background for the health bar.\n\tCustom_Color_12 = BRICKC(\"Institutional white\"); --Background for the abilities.\n}\n\n\nPlayer_Size = 1 --Size of the player.\nAnimation_Speed = 3\nFrame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)\n\nlocal Speed = 35\nlocal Effects2 = {}\n\n--//=================================\\\\\n--|| \t  END OF CUSTOMIZATION\n--\\\\=================================//\n\n\tlocal function weldBetween(a, b)\n\t    local weldd = Instance.new(\"ManualWeld\")\n\t    weldd.Part0 = a\n\t    weldd.Part1 = b\n\t    weldd.C0 = CFrame.new()\n\t    weldd.C1 = b.CFrame:inverse() * a.CFrame\n\t    weldd.Parent = a\n\t    return weldd\n\tend\n\nfunction createaccessory(attachmentpart,mesh,texture,scale,offset,color)\nlocal acs = Instance.new(\"Part\")\nacs.CanCollide = false\nacs.Anchored = false\nacs.Size = Vector3.new(0,0,0)\nacs.CFrame = attachmentpart.CFrame\nacs.Parent = attachmentpart\nacs.BrickColor = color\n    local meshs = Instance.new(\"SpecialMesh\")\n    meshs.MeshId = mesh\n    meshs.TextureId = texture\n    meshs.Parent = acs\n    meshs.Scale = scale\n    meshs.Offset = offset\nweldBetween(attachmentpart,acs)\nend\n\nfunction createbodypart(TYPE,COLOR,PART,OFFSET,SIZE)\nif TYPE == \"Gem\" then\n\tlocal acs = CreatePart(3, PART, \"Plastic\", 0, 0, COLOR, \"Part\", VT(0,0,0))\n\tacs.Anchored = false\n    acs.CanCollide = false\n\tacs.CFrame = PART.CFrame\n\tlocal acs2 = CreateMesh(\"SpecialMesh\", acs, \"FileMesh\", \"9756362\", \"\", SIZE, OFFSET)\nweldBetween(PART,acs)\nelseif TYPE == \"Skull\" then\n\tlocal acs = CreatePart(3, PART, \"Plastic\", 0, 0, COLOR, \"Part\", VT(0,0,0))\n\tacs.Anchored = false\n    acs.CanCollide = false\n\tacs.CFrame = PART.CFrame\n\tlocal acs2 = CreateMesh(\"SpecialMesh\", acs, \"FileMesh\", \"4770583\", \"\", SIZE, OFFSET)\nweldBetween(PART,acs)\nelseif TYPE == \"Eye\" then\n\tlocal acs = CreatePart(3, PART, \"Neon\", 0, 0, COLOR, \"Part\", VT(0,0,0))\n\tacs.Anchored = false\n    acs.CanCollide = false\n\tacs.CFrame = PART.CFrame\n\tlocal acs2 = CreateMesh(\"SpecialMesh\", acs, \"Sphere\", \"\", \"\", SIZE, OFFSET)\nweldBetween(PART,acs)\nend\nend\n\ncreatebodypart(\"Eye\", \"Black\", Head, VT(0.2, 0, -0.55), VT(2, 6, 2))\ncreatebodypart(\"Eye\", \"Black\", Head, VT(-0.2, 0, -0.55), VT(2, 6, 2))\ncreatebodypart(\"Eye\", \"Black\", Head, VT(0, 0, -0.6), VT(2, 8, 2))\n\n--//=================================\\\\\n--|| \t      USEFUL VALUES\n--\\\\=================================//\n\nlocal ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))\nlocal NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))\nlocal RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))\nlocal LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))\nlocal CO1 = 0\nlocal CO2 = 0\nlocal CO3 = 0\nlocal CO4 = 0\nlocal CHANGEDEFENSE = 0\nlocal CHANGEDAMAGE = 0\nlocal CHANGEMOVEMENT = 0\nlocal ANIM = \"Idle\"\nlocal ATTACK = false\nlocal EQUIPPED = false\nlocal HOLD = false\nlocal COMBO = 1\nlocal LASTPOINT = nil\nlocal BLCF = nil\nlocal SCFR = nil\nlocal KEYHOLD = false\nlocal STAGGERHITANIM = false\nlocal STAGGERANIM = false\nlocal STUNANIM = false\nlocal CRITCHANCENUMBER = 0\nlocal IDLENUMBER = 0\nlocal DONUMBER = 0\nlocal HANDIDLE = false\nlocal Rooted = false\nlocal SINE = 0\nlocal CHANGE = 2 / Animation_Speed\nlocal WALKINGANIM = false\nlocal WALK = 0\nlocal DANCE = false\nlocal DISABLEJUMPING = false\nlocal ROBLOXIDLEANIMATION = IT(\"Animation\")\nROBLOXIDLEANIMATION.Name = \"Roblox Idle Animation\"\nROBLOXIDLEANIMATION.AnimationId = \"http://www.roblox.com/asset/?id=180435571\"\n--ROBLOXIDLEANIMATION.Parent = Humanoid\nlocal WEAPONGUI = IT(\"ScreenGui\", PlayerGui)\nWEAPONGUI.Name = \"Weapon GUI\"\nlocal Weapon = IT(\"Model\")\nWeapon.Name = Weapon_Name\nlocal Effects = IT(\"Folder\", Weapon)\nEffects.Name = \"Effects\"\nlocal Bombs = IT(\"Folder\", Weapon)\nBombs.Name = \"BombsHolder\"\nlocal ANIMATOR = Humanoid.Animator\nlocal ANIMATE = Character.Animate\nlocal HITPLAYERSOUNDS = {--[[\"199149137\", \"199149186\", \"199149221\", \"199149235\", \"199149269\", \"199149297\"--]]\"263032172\", \"263032182\", \"263032200\", \"263032221\", \"263032252\", \"263033191\"}\nlocal HITARMORSOUNDS = {\"199149321\", \"199149338\", \"199149367\", \"199149409\", \"199149452\"}\nlocal HITWEAPONSOUNDS = {\"199148971\", \"199149025\", \"199149072\", \"199149109\", \"199149119\"}\nlocal HITBLOCKSOUNDS = {\"199148933\", \"199148947\"}\nlocal UNANCHOR = true\nlocal MAGICPARTICLE = \"655109389\"\n\nlocal SKILLTEXTCOLOR = C3(0,0,0)\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n--//=================================\\\\\n--|| SAZERENOS' ARTIFICIAL HEARTBEAT\n--\\\\=================================//\n\nArtificialHB = Instance.new(\"BindableEvent\", script)\nArtificialHB.Name = \"ArtificialHB\"\n\nscript:WaitForChild(\"ArtificialHB\")\n\nframe = Frame_Speed\ntf = 0\nallowframeloss = false\ntossremainder = false\nlastframe = tick()\nscript.ArtificialHB:Fire()\n\ngame:GetService(\"RunService\").Heartbeat:connect(function(s, p)\n\ttf = tf + s\n\tif tf >= frame then\n\t\tif allowframeloss then\n\t\t\tscript.ArtificialHB:Fire()\n\t\t\tlastframe = tick()\n\t\telse\n\t\t\tfor i = 1, math.floor(tf / frame) do\n\t\t\t\tscript.ArtificialHB:Fire()\n\t\t\tend\n\t\tlastframe = tick()\n\t\tend\n\t\tif tossremainder then\n\t\t\ttf = 0\n\t\telse\n\t\t\ttf = tf - frame * math.floor(tf / frame)\n\t\tend\n\tend\nend)\n\n--//=================================\\\\\n--\\\\=================================//\n\n\n\n\n\n--//=================================\\\\\n--|| \t      SOME FUNCTIONS\n--\\\\=================================//\n\nfunction Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)\n\treturn workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)\nend\n\nfunction PositiveAngle(NUMBER)\n\tif NUMBER >= 0 then\n\t\tNUMBER = 0\n\tend\n\treturn NUMBER\nend\n\nfunction NegativeAngle(NUMBER)\n\tif NUMBER <= 0 then\n\t\tNUMBER = 0\n\tend\n\treturn NUMBER\nend\n\nfunction Swait(NUMBER)\n\tif NUMBER == 0 or NUMBER == nil then\n\t\tArtificialHB.Event:wait()\n\telse\n\t\tfor i = 1, NUMBER do\n\t\t\tArtificialHB.Event:wait()\n\t\tend\n\tend\nend\n\nfunction QuaternionFromCFrame(cf)\n\tlocal mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()\n\tlocal trace = m00 + m11 + m22\n\tif trace > 0 then \n\t\tlocal s = math.sqrt(1 + trace)\n\t\tlocal recip = 0.5 / s\n\t\treturn (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5\n\telse\n\t\tlocal i = 0\n\t\tif m11 > m00 then\n\t\t\ti = 1\n\t\tend\n\t\tif m22 > (i == 0 and m00 or m11) then\n\t\t\ti = 2\n\t\tend\n\t\tif i == 0 then\n\t\t\tlocal s = math.sqrt(m00 - m11 - m22 + 1)\n\t\t\tlocal recip = 0.5 / s\n\t\t\treturn 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip\n\t\telseif i == 1 then\n\t\t\tlocal s = math.sqrt(m11 - m22 - m00 + 1)\n\t\t\tlocal recip = 0.5 / s\n\t\t\treturn (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip\n\t\telseif i == 2 then\n\t\t\tlocal s = math.sqrt(m22 - m00 - m11 + 1)\n\t\t\tlocal recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip\n\t\tend\n\tend\nend\n \nfunction QuaternionToCFrame(px, py, pz, x, y, z, w)\n\tlocal xs, ys, zs = x + x, y + y, z + z\n\tlocal wx, wy, wz = w * xs, w * ys, w * zs\n\tlocal xx = x * xs\n\tlocal xy = x * ys\n\tlocal xz = x * zs\n\tlocal yy = y * ys\n\tlocal yz = y * zs\n\tlocal zz = z * zs\n\treturn CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))\nend\n \n\tfunction part(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)\n\t\tlocal fp=IT(\"Part\")\n\t\tfp.formFactor=formfactor\n\t\tfp.Parent=parent\n\t\tfp.Reflectance=reflectance\n\t\tfp.Transparency=transparency\n\t\tfp.CanCollide=false\n\t\tfp.Locked=true\n\t\tfp.BrickColor=BrickColor.new(tostring(brickcolor))\n\t\tfp.Name=name\n\t\tfp.Size=size\n\t\tfp.Position=Character.Torso.Position\n\t\tNoOutlines(fp)\n\t\tfp.Material=material\n\t\tfp:BreakJoints()\n\t\treturn fp\n\tend\n\t\n\tfunction mesh(Mesh,part,meshtype,meshid,offset,scale)\n\t\tlocal mesh=IT(Mesh)\n\t\tmesh.Parent=part\n\t\tif Mesh==\"SpecialMesh\" then\n\t\t\tmesh.MeshType=meshtype\n\t\t\tmesh.MeshId=meshid\n\t\tend\n\t\tmesh.Offset=offset\n\t\tmesh.Scale=scale\n\t\treturn mesh\n\tend\n\nfunction QuaternionSlerp(a, b, t)\n\tlocal cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]\n\tlocal startInterp, finishInterp;\n\tif cosTheta >= 0.0001 then\n\t\tif (1 - cosTheta) > 0.0001 then\n\t\t\tlocal theta = ACOS(cosTheta)\n\t\t\tlocal invSinTheta = 1 / SIN(theta)\n\t\t\tstartInterp = SIN((1 - t) * theta) * invSinTheta\n\t\t\tfinishInterp = SIN(t * theta) * invSinTheta\n\t\telse\n\t\t\tstartInterp = 1 - t\n\t\t\tfinishInterp = t\n\t\tend\n\telse\n\t\tif (1 + cosTheta) > 0.0001 then\n\t\t\tlocal theta = ACOS(-cosTheta)\n\t\t\tlocal invSinTheta = 1 / SIN(theta)\n\t\t\tstartInterp = SIN((t - 1) * theta) * invSinTheta\n\t\t\tfinishInterp = SIN(t * theta) * invSinTheta\n\t\telse\n\t\t\tstartInterp = t - 1\n\t\t\tfinishInterp = t\n\t\tend\n\tend\n\treturn a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp\nend\n\nfunction Clerp(a, b, t)\n\tlocal qa = {QuaternionFromCFrame(a)}\n\tlocal qb = {QuaternionFromCFrame(b)}\n\tlocal ax, ay, az = a.x, a.y, a.z\n\tlocal bx, by, bz = b.x, b.y, b.z\n\tlocal _t = 1 - t\n\treturn QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))\nend\n\nfunction CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)\n\tlocal frame = IT(\"Frame\")\n\tframe.BackgroundTransparency = TRANSPARENCY\n\tframe.BorderSizePixel = BORDERSIZEPIXEL\n\tframe.Position = POSITION\n\tframe.Size = SIZE\n\tframe.BackgroundColor3 = COLOR\n\tframe.BorderColor3 = BORDERCOLOR\n\tframe.Name = NAME\n\tframe.Parent = PARENT\n\treturn frame\nend\n\nfunction CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)\n\tlocal label = IT(\"TextLabel\")\n\tlabel.BackgroundTransparency = 1\n\tlabel.Size = UD2(1, 0, 1, 0)\n\tlabel.Position = UD2(0, 0, 0, 0)\n\tlabel.TextColor3 = TEXTCOLOR\n\tlabel.TextStrokeTransparency = STROKETRANSPARENCY\n\tlabel.TextTransparency = TRANSPARENCY\n\tlabel.FontSize = TEXTFONTSIZE\n\tlabel.Font = TEXTFONT\n\tlabel.BorderSizePixel = BORDERSIZEPIXEL\n\tlabel.TextScaled = false\n\tlabel.Text = TEXT\n\tlabel.Name = NAME\n\tlabel.Parent = PARENT\n\treturn label\nend\n\nfunction NoOutlines(PART)\n\tPART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10\nend\n\n\nfunction CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)\n\tlocal NEWWELD = IT(TYPE)\n\tNEWWELD.Part0 = PART0\n\tNEWWELD.Part1 = PART1\n\tNEWWELD.C0 = C0\n\tNEWWELD.C1 = C1\n\tNEWWELD.Parent = PARENT\n\treturn NEWWELD\nend\n\nfunction CreateSound(ID, PARENT, VOLUME, PITCH)\n\tlocal NEWSOUND = nil\n\tcoroutine.resume(coroutine.create(function()\n\t\tNEWSOUND = IT(\"Sound\", PARENT)\n\t\tNEWSOUND.Volume = VOLUME\n\t\tNEWSOUND.Pitch = PITCH\n\t\tNEWSOUND.SoundId = \"http://www.roblox.com/asset/?id=\"..ID\n\t\tSwait()\n\t\tNEWSOUND:play()\n\t\tgame:GetService(\"Debris\"):AddItem(NEWSOUND, 10)\n\tend))\n\treturn NEWSOUND\nend\n\nfunction CFrameFromTopBack(at, top, back)\n\tlocal right = top:Cross(back)\n\treturn CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)\nend\n\nfunction CreateWave(inair,size,doesrotate,rotatedirection,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0.5, BRICKC(color), \"Effect\", VT(0,0,0))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"FileMesh\"\n\tmesh.MeshId = \"http://www.roblox.com/asset/?id=20329976\"\n\tmesh.Scale = VT(size,size,size)\n\tmesh.Offset = VT(0,0,-size/8)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,size/5,size/5)\n\t\t\tmesh.Offset = VT(0,0,-(mesh.Scale.X/8))\n\t\t\tif doesrotate == true then\n\t\t\t\twave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, rotatedirection, 0)\n\t\t\tend\n\t\t\twave.Transparency = wave.Transparency + (0.5/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nfunction CreateSwirl(inair,size,doesrotate,rotatedirection,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0.5, BRICKC(color), \"Effect\", VT(0,0,0))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"FileMesh\"\n\tmesh.MeshId = \"http://www.roblox.com/asset/?id=1051557\"\n\tmesh.Scale = VT(size,size,size)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,0,size/5)\n\t\t\tif doesrotate == true then\n\t\t\t\twave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, rotatedirection, 0)\n\t\t\tend\n\t\t\twave.Transparency = wave.Transparency + (0.5/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nfunction CreateTornado(inair,size,doesrotate,rotatedirection,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0.5, BRICKC(color), \"Effect\", VT(0,0,0))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"FileMesh\"\n\tmesh.MeshId = \"http://www.roblox.com/asset/?id=102638417\"\n\tmesh.Scale = VT(size,size,size)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,0,size/5)\n\t\t\tif doesrotate == true then\n\t\t\t\twave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, rotatedirection, 0)\n\t\t\tend\n\t\t\twave.Transparency = wave.Transparency + (0.5/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nfunction CreateRing(inair,size,doesrotate,rotatedirection,waitt,cframe,spin1,spin2,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0.5, BRICKC(color), \"Effect\", VT(0,0,0))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"FileMesh\"\n\tmesh.MeshId = \"http://www.roblox.com/asset/?id=3270017\"\n\tmesh.Scale = VT(size,size,size)\n\tmesh.Offset = VT(0,0,0)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,size/5,size/5)\n\t\t\tif doesrotate == true then\n\t\t\t\twave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(spin2, rotatedirection, spin1)\n\t\t\tend\n\t\t\twave.Transparency = wave.Transparency + (0.5/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nfunction MagicSphere(size,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0, BRICKC(color), \"Effect\", VT(1,1,1))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"Sphere\"\n\tmesh.Scale = VT(size,size,size)\n\tmesh.Offset = VT(0,0,0)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,size/5,size/5)\n\t\t\twave.Transparency = wave.Transparency + (1/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nfunction MagicSphere2(size,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 1, BRICKC(color), \"Effect\", VT(1,1,1))\n\tlocal mesh = IT(\"SpecialMesh\",wave)\n\tmesh.MeshType = \"Sphere\"\n\tmesh.Scale = VT(size,size,size)\n\tmesh.Offset = VT(0,0,0)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale - VT(size/waitt,size/waitt,size/waitt)\n\t\t\twave.Transparency = wave.Transparency - (1/waitt)\n\t\tend\n\t\twave:remove()\n\tend))\nend\n\nfunction BreakEffect(brickcolor,cframe,x1,y1,z1,material)\n\tlocal prt=part(\"Custom\",workspace,material,0,0,brickcolor,\"Effect\",VT(0.5,0.5,0.5))\n\tprt.Anchored=true\n\tprt.CFrame=cframe*EULER(math.random(-50,50),math.random(-50,50),math.random(-50,50))\n\tlocal msh=mesh(\"SpecialMesh\",prt,\"Sphere\",\"\",VT(0,0,0),VT(x1,y1,z1))\n\tcoroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) \n\t\tCF=Part.CFrame\n\t\tNumbb=0\n\t\trandnumb=math.random()-math.random()\n\t\tfor i=0,1,0.05 do\n\t\t\twait()\n\t\t\tCF=CF*CF(0,1,0)\n\t\t\t--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)\n\t\t\tPart.CFrame=CF*EULER(Numbb,0,0)\n\t\t\tPart.Transparency=i\n\t\t\tNumbb=Numbb+randnumb\n\t\tend\n\t\tPart.Parent=nil\n\tend),prt)\nend\n\nfunction MagicBlock(size,waitt,cframe,color)\n\tlocal wave = CreatePart(3, Effects, \"Neon\", 0, 0, BRICKC(color), \"Effect\", VT(size,size,size))\n\tlocal mesh = IT(\"BlockMesh\",wave)\n\twave.CFrame = cframe\n\tcoroutine.resume(coroutine.create(function(PART)\n\t\tfor i = 1, waitt do\n\t\t\tSwait()\n\t\t\tmesh.Scale = mesh.Scale + VT(size/5,size/5,size/5)\n\t\t\twave.CFrame = cframe * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))\n\t\t\twave.Transparency = wave.Transparency + (1/waitt)\n\t\t\tif wave.Transparency > 0.99 then\n\t\t\t\twave:remove()\n\t\t\tend\n\t\tend\n\tend))\nend\n\nlocal EyeSizes={\n\tNumberSequenceKeypoint.new(0,1,0),\n\tNumberSequenceKeypoint.new(1,0.2,0)\n}\nlocal EyeTrans={\n\tNumberSequenceKeypoint.new(0,0.8,0),\n\tNumberSequenceKeypoint.new(1,1,0)\n}\nlocal PE=Instance.new(\"ParticleEmitter\")\nPE.LightEmission=0\nPE.Size=NumberSequence.new(EyeSizes)\nPE.Transparency=NumberSequence.new(EyeTrans)\nPE.Lifetime=NumberRange.new(0.35,0.35,0.35)\nPE.Rotation=NumberRange.new(0,360)\nPE.Rate=15\nPE.Acceleration = Vector3.new(0,75,0)\nPE.Drag = 5\nPE.Enabled = false\nPE.Speed = NumberRange.new(0,0,0)\nPE.Texture=\"http://www.roblox.com/asset/?id=1179557490\"\nPE.ZOffset = 0\nPE.Name = \"Particles\"\n\nfunction CreateParticles(art,text,accel,drag,rate,type,isenabledbydefault)\n\tlocal particle = PE:Clone()\n\tparticle.Parent = art\n\tparticle.Acceleration = accel\n\tPE.Rate = rate\n\tif type == \"Fire\" then\n\t\tlocal EyeSizes={\n\t\t\tNumberSequenceKeypoint.new(0,1,0.3),\n\t\t\tNumberSequenceKeypoint.new(1,0.2,0.2)\n\t\t}\n\t\tPE.Size = NumberSequence.new(EyeSizes)\n\telseif type == \"Smoke\" then\n\t\tlocal EyeSizes={\n\t\t\tNumberSequenceKeypoint.new(0,1,0),\n\t\t\tNumberSequenceKeypoint.new(1,5,0.5)\n\t\t}\n\t\tPE.Size = NumberSequence.new(EyeSizes)\n\telseif type == \"Solid\" then\n\t\tlocal EyeSizes={\n\t\t\tNumberSequenceKeypoint.new(0,1,0),\n\t\t\tNumberSequenceKeypoint.new(1,1,0)\n\t\t}\n\t\tPE.Size = NumberSequence.new(EyeSizes)\n\tend\n\tPE.Drag = drag\n\tparticle.Texture = \"http://www.roblox.com/asset/?id=\"..text\n\tparticle.Enabled = isenabledbydefault\nreturn particle\nend\n\nfunction MakeForm(PART,TYPE)\n\tif TYPE == \"Cyl\" then\n\t\tlocal MSH = IT(\"CylinderMesh\",PART)\n\telseif TYPE == \"Ball\" then\n\t\tlocal MSH = IT(\"SpecialMesh\",PART)\n\t\tMSH.MeshType = \"Sphere\"\n\telseif TYPE == \"Wedge\" then\n\t\tlocal MSH = IT(\"SpecialMesh\",PART)\n\t\tMSH.MeshType = \"Wedge\"\n\tend\nend\n\n--//=================================\\\\\n--\\\\=================================//\n\nfunction createaddongen(limb,position,size)\n\tlocal part = CreatePart(3, Weapon, \"Glass\", 0, 0, \"Really black\", limb.Name..\" Gauntlet Part\", VT(0.25*Player_Size, size*0.8*Player_Size,size*0.8*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0.45 * Player_Size, position * Player_Size, 0 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(0)), CF(0, 0, 0))\n\tlocal part = CreatePart(3, Weapon, \"Neon\", 0, 0, \"Black\", limb.Name..\" Neon Gauntlet Part\", VT(0.25*Player_Size,size*Player_Size,size*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0.425 * Player_Size, position * Player_Size, 0 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(0)), CF(0, 0, 0))\nend\n\nfunction creategauntlet(limb)\n\t--main--\n\tlocal part = CreatePart(3, Weapon, \"Glass\", 0, 0, \"Really black\", limb.Name..\" Gauntlet Part\", VT(1.07*Player_Size,0.75+0.07*Player_Size,1.07*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0 * Player_Size, -0.65 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))\n\tlocal part = CreatePart(3, Weapon, \"Glass\", 0, 0, \"Really black\", limb.Name..\" Gauntlet Part\", VT(1.07*Player_Size,0.25*Player_Size,1.07*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0 * Player_Size, -0.115 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)), CF(0, 0, 0))\n\tMakeForm(part,\"Wedge\")\n\tlocal part = CreatePart(3, Weapon, \"Glass\", 0, 0, \"Really black\", limb.Name..\" Gauntlet Part\", VT(1.07*Player_Size,0.25*Player_Size,1.07*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0 * Player_Size, 0.115 * Player_Size, 0 * Player_Size) * ANGLES(RAD(180), RAD(-90), RAD(0)), CF(0, 0, 0))\n\tMakeForm(part,\"Wedge\")\n\tlocal part = CreatePart(3, Weapon, \"Glass\", 0, 0, \"Really black\", limb.Name..\" Gauntlet Part\", VT(1.07*Player_Size,0.75+0.07*Player_Size,1.07*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0 * Player_Size, 0.65 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))\n\t--neon addons\n\tlocal part = CreatePart(3, Weapon, \"Neon\", 0, 0, \"Black\", limb.Name..\" Neon Gauntlet Part\", VT(1.05*Player_Size,2.05*Player_Size,1.05*Player_Size),false)\n\tlocal weld = CreateWeldOrSnapOrMotor(\"Weld\", part, limb, part, CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))\n\t--misc--\n\tcreateaddongen(limb,0.25,0.75)\n\tcreateaddongen(limb,-0.2,0.25)\n\tcreateaddongen(limb,-0.35,0.25)\n\tcreateaddongen(limb,-0.65,0.45)\nend\n\n--//=================================\\\\\n--||\t     WEAPON CREATION\n--\\\\=================================//\n\ncreategauntlet(RightArm)\ncreategauntlet(LeftLeg)\n\nif Player_Size ~= 1 then\n\tfor _, v in pairs (Weapon:GetChildren()) do\n\t\tif v.ClassName == \"Motor\" or v.ClassName == \"Weld\" or v.ClassName == \"Snap\" then\n\t\t\tlocal p1 = v.Part1\n\t\t\tv.Part1 = nil\n\t\t\tlocal cf1, cf2, cf3, cf4, cf5, cf6, cf7, cf8, cf9, cf10, cf11, cf12 = v.C1:components()\n\t\t\tv.C1 = CF(cf1 * Player_Size, cf2 * Player_Size, cf3 * Player_Size, cf4, cf5, cf6, cf7, cf8, cf9, cf10, cf11, cf12)\n\t\t\tv.Part1 = p1\n\t\telseif v.ClassName == \"Part\" then\n\t\t\tfor _, b in pairs (v:GetChildren()) do\n\t\t\t\tif b.ClassName == \"SpecialMesh\" or b.ClassName == \"BlockMesh\" then\n\t\t\t\t\tb.Scale = VT(b.Scale.x * Player_Size, b.Scale.y * Player_Size, b.Scale.z * Player_Size)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfor _, c in pairs(Weapon:GetChildren()) do\n\tif c.ClassName == \"Part\" then\n\t\tc.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)\n\tend\nend\n\nWeapon.Parent = Character\n\nHumanoid.Died:connect(function()\n\tsick:remove()\n\tsick2:remove()\n\tCreateSound(\"167285348\", Head, 3, 1)\n\tATTACK = true\nend)\n\nprint(Class_Name..\" loaded.\")\n\n--//=================================\\\\\n--|| \t\t\tSPEECH\n--\\\\=================================//\n\nfunction chatfunc(text,waitt)\nlocal chat = coroutine.wrap(function()\nif Character:FindFirstChild(\"TalkingBillBoard\")~= nil then\nCharacter:FindFirstChild(\"TalkingBillBoard\"):destroy()\nend\nlocal naeeym2 = Instance.new(\"BillboardGui\",Character)\nnaeeym2.Size = UDim2.new(0,100,0,40)\nnaeeym2.StudsOffset = Vector3.new(0,5,0)\nnaeeym2.Adornee = Character.Head\nnaeeym2.Name = \"TalkingBillBoard\"\nnaeeym2.AlwaysOnTop = true\nlocal tecks2 = Instance.new(\"TextLabel\",naeeym2)\ntecks2.BackgroundTransparency = 1\ntecks2.BorderSizePixel = 0\ntecks2.Text = \"\"\ntecks2.Font = \"SciFi\"\ntecks2.TextSize = 30\ntecks2.TextStrokeTransparency = 1\ntecks2.TextColor3 = SKILLTEXTCOLOR\ntecks2.TextStrokeColor3 = Color3.new(0,0,0)\ntecks2.Size = UDim2.new(1,0,0.5,0)\nfor i = 1,string.len(text),1 do\ntecks2.Text = string.sub(text,1,i)\nSwait()\nend\nwait(waitt)\ncoroutine.resume(coroutine.create(function()\n\tfor i = 1, 10 do\n\t\ttecks2.TextTransparency = tecks2.TextTransparency + 0.1\n\t\tSwait()\n\tend\n\tnaeeym2:Destroy()\nend))\nend)\nchat()\nend\n\n--//=================================\\\\\n--||\t     DAMAGE FUNCTIONS\n--\\\\=================================//\n\nfunction StatLabel(LABELTYPE, CFRAME, TEXT, COLOR)\n\tlocal STATPART = CreatePart(3, Effects, \"SmoothPlastic\", 0, 1, \"Really black\", \"Effect\", VT())\n\tSTATPART.CFrame = CF(CFRAME.p + VT(0, 1.5, 0))\n\tlocal BODYGYRO = IT(\"BodyGyro\", STATPART)\n\tlocal BODYPOSITION = IT(\"BodyPosition\", STATPART)\n\tBODYPOSITION.P = 2000\n\tBODYPOSITION.D = 100\n\tBODYPOSITION.maxForce = VT(math.huge, math.huge, math.huge)\n\tif LABELTYPE == \"Normal\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2, 2), 6, MRANDOM(-2, 2))\n\telseif LABELTYPE == \"Debuff\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2, 2), 8, MRANDOM(-2, 2))\n\telseif LABELTYPE == \"Interruption\" then\n\t\tBODYPOSITION.position = STATPART.Position + VT(MRANDOM(-2,2), 8, MRANDOM(-2, 2))\n\tend\n\tgame:GetService(\"Debris\"):AddItem(STATPART ,5)\n\tlocal BILLBOARDGUI = Instance.new(\"BillboardGui\", STATPART)\n\tBILLBOARDGUI.Adornee = STATPART\n\tBILLBOARDGUI.Size = UD2(2.5, 0, 2.5 ,0)\n\tBILLBOARDGUI.StudsOffset = VT(-2, 2, 0)\n\tBILLBOARDGUI.AlwaysOnTop = false\n\tlocal TEXTLABEL = Instance.new(\"TextLabel\", BILLBOARDGUI)\n\tTEXTLABEL.BackgroundTransparency = 1\n\tTEXTLABEL.Size = UD2(2.5, 0, 2.5, 0)\n\tTEXTLABEL.Text = TEXT\n\tTEXTLABEL.Font = \"SciFi\"\n\tTEXTLABEL.FontSize=\"Size42\"\n\tTEXTLABEL.TextColor3 = COLOR\n\tTEXTLABEL.TextStrokeTransparency = 1\n\tTEXTLABEL.TextScaled = true\n\tTEXTLABEL.TextWrapped = true\n\tcoroutine.resume(coroutine.create(function(THEPART, THEBODYPOSITION, THETEXTLABEL)\n\t\twait(0.2)\n\t\tfor i=1, 5 do\n\t\t\twait()\n\t\t\tTHEBODYPOSITION.Position = THEPART.Position - VT(0, 0.5 ,0)\n\t\tend\n\t\twait(1.2)\n\t\tfor i=1, 5 do\n\t\t\twait()\n\t\t\tTHETEXTLABEL.TextTransparency = THETEXTLABEL.TextTransparency + 0.2\n\t\t\tTHETEXTLABEL.TextStrokeTransparency = THETEXTLABEL.TextStrokeTransparency + 0.2\n\t\t\tTHEBODYPOSITION.position = THEPART.Position + VT(0, 0.5, 0)\n\t\tend\n\t\tTHEPART.Parent = nil\n\tend),STATPART, BODYPOSITION, TEXTLABEL)\nend\n\n\n--//=================================\\\\\n--||\t\t\tDAMAGING\n--\\\\=================================//\n\nfunction dealdamage(hit,min,max,maxstrength,beserk,critrate,critmultiplier)\n\tif hit.Parent:FindFirstChildOfClass(\"Humanoid\") and hit.Parent:FindFirstChild(\"HitBy\"..Player.Name) == nil then\n\t\tlocal humanoid = hit.Parent:FindFirstChildOfClass(\"Humanoid\")\n\t\tlocal dmg = math.random(min,max)\n\t\tif humanoid.Health > 0 then\n\t\t\tif beserk == true then\n\t\t\t\thumanoid.Health = 0\n\t\t\telse\n\t\t\t\tCreateSound(\"260430060\", hit, 1.2, MRANDOM(7, 12) / 10)\n\t\t\t\thit.Velocity = CFrame.new(Torso.Position,hit.Position).lookVector*5*maxstrength\n\t\t\t\tif math.random(1,100) < critrate+1 then\n\t\t\t\t\thumanoid.Health = humanoid.Health - dmg*critmultiplier\n\t\t\t\t\tStatLabel(\"Normal\", hit.CFrame * CF(0, 0 + (hit.Size.z - 1), 0), \"CRIT/\"..dmg*critmultiplier, C3(255/255, 0, 0))\n\t\t\t\telse\n\t\t\t\t\thumanoid.Health = humanoid.Health - dmg\n\t\t\t\t\tStatLabel(\"Normal\", hit.CFrame * CF(0, 0 + (hit.Size.z - 1), 0), dmg, C3(0, 0, 0))\n\t\t\t\tend\n\t\t\t\tlocal defence = Instance.new(\"BoolValue\",hit.Parent)\n\t\t\t\tdefence.Name = (\"HitBy\"..Player.Name)\n\t\t\t\tgame:GetService(\"Debris\"):AddItem(defence, 0.5)\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction AoEDamage(position,radius,min,max,maxstrength,beserk,critrate,critmultiplier,CanBeDodgedByJumping)\n\tlocal dmg = math.random(min,max)\n\tfor i,v in ipairs(workspace:GetChildren()) do\n\tif v:FindFirstChild(\"HitBy\"..Player.Name) == nil then\n\t\tlocal body = v:GetChildren()\n\t\t\tfor part = 1, #body do\n\t\t\t\tif(v:FindFirstChild(\"HitBy\"..Player.Name) == nil and (body[part].ClassName == \"Part\" or body[part].ClassName == \"MeshPart\") and v ~= Character) then\n\t\t\t\t\tif(body[part].Position - position).Magnitude < radius then\n\t\t\t\t\t\tif v.ClassName == \"Model\" then\n\t\t\t\t\t\t\tif v:FindFirstChild(\"Humanoid\") then\n\t\t\t\t\t\t\t\tif v.Humanoid.Health ~= 0 then\n\t\t\t\t\t\t\t\t\tif CanBeDodgedByJumping == true then\n\t\t\t\t\t\t\t\t\t\tif body[part].Position.Y < position.Y+5 then\n\t\t\t\t\t\t\t\t\t\t\tif math.random(1,100) < critrate+1 then\n\t\t\t\t\t\t\t\t\t\t\t\tv.Humanoid.Health = v.Humanoid.Health - dmg*critmultiplier\n\t\t\t\t\t\t\t\t\t\t\t\tStatLabel(\"Normal\", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), \"CRIT/\"..dmg*critmultiplier, C3(255/255, 0, 0))\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\tv.Humanoid.Health = v.Humanoid.Health - dmg\n\t\t\t\t\t\t\t\t\t\t\t\tStatLabel(\"Normal\", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), dmg, C3(0, 0, 0))\n\t\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\tlocal defence = Instance.new(\"BoolValue\",v)\n\t\t\t\t\t\t\t\t\t\t\tdefence.Name = (\"HitBy\"..Player.Name)\n\t\t\t\t\t\t\t\t\t\t\tgame:GetService(\"Debris\"):AddItem(defence, 0.5)\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tif beserk == true then\n\t\t\t\t\t\t\t\t\t\t\tv.Humanoid.Health = 0\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\tif math.random(1,100) < critrate+1 then\n\t\t\t\t\t\t\t\t\t\t\tv.Humanoid.Health = v.Humanoid.Health - dmg*critmultiplier\n\t\t\t\t\t\t\t\t\t\t\tStatLabel(\"Normal\", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), \"CRIT/\"..dmg*critmultiplier, C3(255/255, 0, 0))\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tv.Humanoid.Health = v.Humanoid.Health - dmg\n\t\t\t\t\t\t\t\t\t\t\tStatLabel(\"Normal\", body[part].CFrame * CF(0, 0 + (body[part].Size.z - 1), 0), dmg, C3(0, 0, 0))\n\t\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\t\t\tlocal defence = Instance.new(\"BoolValue\",v)\n\t\t\t\t\t\t\t\t\t\tdefence.Name = (\"HitBy\"..Player.Name)\n\t\t\t\t\t\t\t\t\t\tgame:GetService(\"Debris\"):AddItem(defence, 0.5)\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\tbody[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tif v.ClassName == \"Part\" then\n\t\t\t\tif v.Anchored == false and (v.Position - position).Magnitude < radius then\n\t\t\t\t\tv.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nfunction killnearest(position,range,maxstrength)\n\tfor i,v in ipairs(workspace:GetChildren()) do\n\tlocal body = v:GetChildren()\n\t\tfor part = 1, #body do\n\t\t\tif((body[part].ClassName == \"Part\" or body[part].ClassName == \"MeshPart\") and v ~= Character) then\n\t\t\t\tif(body[part].Position - position).Magnitude < range then\n\t\t\t\t\tif v.ClassName == \"Model\" then\n\t\t\t\t\t\tv:BreakJoints()\n\t\t\t\t\tend\n\t\t\t\t\t--table.insert(Effects2,{body[part],\"Disappear\",0.02,2,2,2,2})\n\t\t\t\t\tbody[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif v.ClassName == \"Part\" then\n\t\t\tif v.Anchored == false and (v.Position - position).Magnitude < range then\n\t\t\t\t--table.insert(Effects2,{v,\"Disappear\",0.02,2,2,2,2})\n\t\t\t\tv.Velocity = CFrame.new(position,v.Position).lookVector*5*maxstrength\n\t\t\tend\n\t\tend\n\tend\nend\n\n--//=================================\\\\\n--||\tATTACK FUNCTIONS AND STUFF\n--\\\\=================================//\n\nfunction CheckTableForString(Table, String)\n\tfor i, v in pairs(Table) do\n\t\tif string.find(string.lower(String), string.lower(v)) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nfunction CheckIntangible(Hit)\n\tlocal ProjectileNames = {\"Water\", \"Arrow\", \"Projectile\", \"Effect\", \"Rail\", \"Lightning\", \"Bullet\"}\n\tif Hit and Hit.Parent then\n\t\tif ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild(\"Humanoid\")) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n\nDebris = game:GetService(\"Debris\")\n\nfunction CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)\n\tlocal Direction = CFrame.new(StartPos, Vec).lookVector\n\tlocal Ignore = ((type(Ignore) == \"table\" and Ignore) or {Ignore})\n\tlocal RayHit, RayPos, RayNormal = game:GetService(\"Workspace\"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Direction * Length), Ignore)\n\tif RayHit and CheckIntangible(RayHit) then\n\t\tif DelayIfHit then\n\t\t\twait()\n\t\tend\n\t\tRayHit, RayPos, RayNormal = CastZapRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)\n\tend\n\treturn RayHit, RayPos, RayNormal\nend\n\nfunction turnto(position)\n\tRootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)\nend\n\nfunction ExplodeBomb(b)\n\tb.Parent = Effects\n\tb.Anchored = true\n\tCreateSound(\"215395285\", b, 10, 1)\n\tMagicSphere(5,50,b.CFrame,\"Black\")\n\tb.Transparency = 1\n\tMagicBlock(3,45,b.CFrame,\"Black\")\n\t--BreakEffect(\"Black\",b.CFrame,2,2,2,\"Neon\")\n\tfor i = 1, 10 do\n\t\tCreateSwirl(0,5,true,-0.2,25,b.CFrame * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360))),\"Really black\")\n\tend\n\tkillnearest(b.Position,30,25)\n\tgame:GetService(\"Debris\"):AddItem(b, 5)\nend\n\nfunction Detonate()\n\tbomb = Bombs:GetChildren()\n\tfor lol = 1, #bomb do\n\t\tif bomb[lol].ClassName == \"Part\" then\n\t\t\tlocal b = bomb[lol]\n\t\t\tExplodeBomb(b)\n\t\tend\n\tend\nend\n\n\n\nfunction TyranyCannon()\n\tATTACK = true\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tturnto(Mouse.Hit.p)\n\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0.05 * Player_Size, 0 * Player_Size, -0.1 * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(40)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed/5)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(10 - 2.5 * COS(SINE / 16)), RAD(0), RAD(-25 + 2.5 * SIN(SINE / 24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(0.95 * Player_Size, -0.75 * Player_Size, -0.5 * Player_Size) * ANGLES(RAD(0), RAD(50), RAD(0)) * ANGLES(RAD(-1.25), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1.1 * Player_Size, 0.25 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2.5), RAD(0), RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\tend\n\tlocal POS = Mouse.Hit.p\n\tfor i = 1, 5 do\n\t\tMagicSphere(2,10,RightArm.CFrame * CF(0,-1,0),\"Black\")\n\t\tSwait(5)\n\tend\n\tCreateSound(\"438666196\", RightArm, 5, 1)\n\tMagicSphere(5,10,RightArm.CFrame * CF(0,-1,0),\"Black\")\n\tlocal Projectile = CreatePart(3, Bombs, \"Neon\", 0, 0, \"Black\", \"Bomb-Projectile\", VT(5,5,5),false)\n\tProjectile.CFrame = RightArm.CFrame * CF(0,-1,0)\n\tProjectile.CanCollide = false\n\tMakeForm(Projectile,\"Ball\")\n\tlocal grav = Instance.new(\"BodyPosition\",Projectile)\n\tgrav.P = 25000\n\tgrav.maxForce = Vector3.new(math.huge,math.huge,math.huge)\n\tgrav.position = POS\n\tgrav.Name = \"GravityForce\"\n\tlocal harm = Projectile.Touched:Connect(function(hit)\n\t\tif hit.Parent ~= Character and hit.Parent:FindFirstChild(\"Humanoid\") and Projectile.Parent ~= Effects then\n\t\t\tExplodeBomb(Projectile)\n\t\tend\n\tend)\n\tATTACK = false\nend\n\nfunction RayCast(Position, Direction, MaxDistance, IgnoreList)\n\treturn game:GetService(\"Workspace\"):FindPartOnRayWithIgnoreList(Ray.new(Position, Direction.unit * (MaxDistance or 999.999)), IgnoreList) \nend\n\nfunction EarthShatter()\n\tlocal HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4 * Player_Size, Character)\n\tif HITFLOOR ~= nil then\n\t\tATTACK = true\n\t\tRooted = true\n\t\tfor i=0, 1, 0.1 / Animation_Speed/2 do\n\t\t\tSwait()\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -1 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(0)), 0.2 / Animation_Speed/8)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 1 * Player_Size, 1 * Player_Size) * ANGLES(RAD(30), RAD(-690), RAD(2 - 2.5 * COS(SINE / 12) + 2.5 * SIN(SINE / 24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed/8)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(25), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed/8)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.3 * Player_Size, -1 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.2 / Animation_Speed/8)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.3 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(45), RAD(0), RAD(10)), 0.2 / Animation_Speed/8)\n\t\tend\n\t\tfor i=0, 1, 0.1 / Animation_Speed*5 do\n\t\t\tSwait()\n\t        RootPart.Anchored = true\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -1 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(0)), 0.2 / Animation_Speed*5)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed*5)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 1 * Player_Size, -1.4 * Player_Size) * ANGLES(RAD(30), RAD(-690), RAD(2 - 2.5 * COS(SINE / 12) + 2.5 * SIN(SINE / 24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed*5)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(25), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed*5)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.3 * Player_Size, -1 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.2 / Animation_Speed*5)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.3 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(45), RAD(0), RAD(10)), 0.2 / Animation_Speed*5)\n\t\tend\n\t\tlocal POS = RightArm.CFrame * CF(0,-1,0).p\n\t\tfor i = 1,10 do\n\t\tCreateWave(0,10,true,0.05,25,CF(POS),\"Really black\")\n\t\tCreateWave(0,6,true,-0.05,25,CF(POS),\"Really black\")\n\t\tCreateWave(0,2,true,0.05,25,CF(POS),\"Really black\")\n\t\tkillnearest(POS,15,25)\n\t\tCreateSound(\"438666141\", RightArm, 5, 1)\n\t\tfor i = 1, 40 do\n\t\t\tlocal angle = math.random(-180,180)\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\tlocal RayHit, RayPos = RayCast(Torso.Position, Vector3.new(0, -15, 0), 10000, {Character})\n\t\t\t\tlocal SpawnPosition = RayPos\n\t\t\t\tlocal floor = RayHit\n\t\t\t\tlocal needcframe = RootPart.CFrame*ANGLES(RAD(0),RAD(angle),RAD(0))\n\t\t\t\tlocal LastPosition = RayPos\n\t\t\t\tlocal Delay = 1\n\t\t\t\tif floor ~= nil then\n\t\t\t\t\tfor i = 1, 5 do\n\t\t\t\t\t\tlocal RayHit, RayPos = RayCast(LastPosition, needcframe.lookVector, 10, {workspace})\n\t\t\t\t\t\tlocal End = RayPos\n\t\t\t\t\t\tLastPosition = End\n\t\t\t\t\t\tkillnearest(End,15,25)\n\t\t\t\t\t\tlocal locatepart = Instance.new(\"Part\",Effects)\n\t\t\t\t\t\tlocatepart.Size = VT(0.5,0.5,0.5)\n\t\t\t\t\t\tlocatepart.Position = End\n\t\t\t\t\t\tlocatepart.CanCollide = false\n\t\t\t\t\t\tlocatepart.Anchored = true\n\t\t\t\t\t\tlocatepart.Name = \"L0\"\n\t\t\t\t\t\tlocatepart.Transparency = 1\n\t\t\t\t\t\t\tif SpawnPosition then\n\t\t\t\t\t\t\t\tCreateSwirl(0,2,false,0.05,25,CF(End),\"Really black\")\n\t\t\t\t\t\t\t\tlocal spike = Instance.new(\"CornerWedgePart\")\n\t\t\t\t\t\t\t\tspike.Size = Vector3.new(1,15,1)\n\t\t\t\t\t\t\t\tspike.Material = \"Neon\"\n\t\t\t\t\t\t\t\tspike.Color = \"Really black\"\n\t\t\t\t\t\t\t\tspike.Anchored = true\n\t\t\t\t\t\t\t\tspike.CanCollide = false\n\t\t\t\t\t\t\t\tspike.CFrame = CFrame.new(End.X,SpawnPosition.Y+2,End.Z)\n\t\t\t\t\t\t\t\tspike.Orientation = Vector3.new(math.random(-15,15),math.random(-180,180),math.random(-15,15))\n\t\t\t\t\t\t\t\tspike.Name = HITFLOOR.Name..\"Spike\"\n\t\t\t\t\t\t\t\tCreateSound(\"341300954\", spike, 1, (math.random(8,12)/10))\n\t\t\t\t\t\t\t\tfor i = 1, 3 do\n\t\t\t\t\t\t\t\t\tlocal overlay = spike:Clone()\n\t\t\t\t\t\t\t\t\toverlay.Size = overlay.Size + Vector3.new(0.2,0.2*2,0.2)\n\t\t\t\t\t\t\t\t\toverlay.CFrame = spike.CFrame\n\t\t\t\t\t\t\t\t\toverlay.Parent = nil\n\t\t\t\t\t\t\t\t\toverlay.Orientation = Vector3.new(math.random(-15,15),math.random(-180,180),math.random(-15,15))\n\t\t\t\t\t\t\t\t\toverlay.Parent = Effects\n\t\t\t\t\t\t\t\t\ttable.insert(Effects2,{overlay,\"Disappear\",0.01,0,0,0,0})\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\tspike.Size = Vector3.new(2,25,2)\n\t\t\t\t\t\t\t\tspike.Parent = Effects\n\t\t\t\t\t\t\t\ttable.insert(Effects2,{spike,\"Disappear\",0.01,0,0,0,0})\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tSwait(5)\n\t\t\t\t\t\tgame:GetService(\"Debris\"):AddItem(locatepart, 5)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend))\n\t\tend\n\t\twait(0.05)\n\t\tend\n\t\tfor i=0, 6, 0.1 / Animation_Speed*5 do\n\t\t\tSwait()\n\t        RootPart.Anchored = true\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -1 * Player_Size) * ANGLES(RAD(45), RAD(0), RAD(0)), 0.2 / Animation_Speed*5)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed*5)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 1 * Player_Size, -1.4 * Player_Size) * ANGLES(RAD(30), RAD(-690), RAD(2 - 2.5 * COS(SINE / 12) + 2.5 * SIN(SINE / 24))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed*5)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(25), RAD(45)) * LEFTSHOULDERC0, 0.15 / Animation_Speed*5)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.3 * Player_Size, -1 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.2 / Animation_Speed*5)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.3 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(45), RAD(0), RAD(10)), 0.2 / Animation_Speed*5)\n\t\tend\n\t\tATTACK = false\n\t\tRooted = false\n\tend\nend\n\nfunction RavagingOverthrower()\n\tATTACK = true\n\tRooted = true\n\tchatfunc(\"I will show you what is death!!!\",4)\n\tfor i=0, 1, 0.1 / Animation_Speed do\n\t\tSwait()\n\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)\n\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)\n\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\tend\n\tCreateSound(\"348663022\", Torso, 5, 1)\n\tlocal StartPos = RootPart.CFrame * CF(0,0,-10).p\n\tfor i = 1, 5 do\n\t\tMagicSphere2(25,25,CF(StartPos),\"Black\")\n\t\tSwait(15)\n\tend\n\tlocal soundeffect = IT(\"Sound\",Torso)\n\tsoundeffect.SoundId = \"rbxassetid://487186990\"\n\tsoundeffect.Looped = true\n\tsoundeffect.Volume = 10\n\tsoundeffect.Playing = true\n\trepeat\n\t\tturnto(Mouse.Hit.p)\n\t\tMagicSphere2(25,25,CF(StartPos),\"Black\")\n\t\tMagicSphere(25/10,25,CF(StartPos),\"Black\")\n\t\tfor i = 1, 3 do\n\t\t\tCreateSwirl(0,25,true,-0.2,5,CF(StartPos) * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360))),\"Really black\")\n\t\tend\n\t\tlocal RayHit, RayPos, RayNormal = CastZapRay(StartPos, Mouse.Hit.p, 750, Character, false)\n\t\tlocal distance = (StartPos - RayPos).magnitude\n\t\tlocal RayBeam = IT(\"Part\",Effects)\n\t\tRayBeam.Material = \"Neon\"\n\t\tRayBeam.Anchored = true\n\t\tRayBeam.BrickColor = BRICKC\"Black\"\n\t\tlocal mesh = IT(\"SpecialMesh\",RayBeam)\n\t\tmesh.MeshType = \"Cylinder\"\n\t\tRayBeam.Size = Vector3.new(distance+10, math.random(10,15), math.random(10,15))\n\t\tRayBeam.CFrame = CFrame.new(StartPos, RayPos) * CFrame.new(0, 0, -distance/2) * ANGLES(RAD(0),RAD(90),RAD(0))\n\t\tMagicSphere(15,5,CF(RayPos),\"Black\")\n\t\tkillnearest(RayPos,15,100)\n\t\tfor i = 1, 3 do\n\t\t\tCreateSwirl(0,25,true,-0.2,5,CF(RayPos) * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360))),\"Really black\")\n\t\tend\n\t\tSwait()\n\t\tif KEYHOLD == false then\n\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\tfor i = 1, 30 do\n\t\t\t\t\tRayBeam.Transparency = i/30\n\t\t\t\t\tSwait()\n\t\t\t\tend\n\t\t\t\tRayBeam:remove()\n\t\t\tend))\n\t\telse\n\t\t\tRayBeam:remove()\n\t\tend\n\tuntil KEYHOLD == false\n\tsoundeffect:remove()\n\tATTACK = false\n\tRooted = false\nend\n\nfunction dodadance()\n\tATTACK = true\n\tRooted = true\n\tDANCE = true\n\tsick:Stop()\n\tsick2:Play()\n\tlocal Animation_Speed2 = 1.5\n\tHName.Text = \"PLEASE STOP THIS\"\n\trepeat\n\t\tfor i=0, 1.3, 0.1 / Animation_Speed2 do\n\t\t\tSwait()\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(25), RAD(0), RAD(-15)), 0.15 / Animation_Speed2)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed2)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-180)) * LEFTSHOULDERC0, 0.15 / Animation_Speed2)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.5 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(120), RAD(35)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 0.15 / Animation_Speed2)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(-35)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed2)\n\t\tend\n\t\tMagicSphere(5,15,Torso.CFrame,\"Black\")\n\t\tfor i=0, 1.3, 0.1 / Animation_Speed2 do\n\t\t\tSwait()\n\t\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(25), RAD(0), RAD(15)), 0.15 / Animation_Speed2)\n\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.15 / Animation_Speed2)\n\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75 * Player_Size, 0.5 * Player_Size, -1 * Player_Size) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-120)) * LEFTSHOULDERC0, 0.15 / Animation_Speed2)\n\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(35)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.5 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(-120), RAD(-35)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\tend\n\t\tMagicSphere(5,15,Torso.CFrame,\"Black\")\n\tuntil DANCE == false\n\tHName.Text = \"Eterna\"\n\tsick:Play()\n\tsick2:Stop()\n\tATTACK = false\n\tRooted = false\nend\n\nfunction Warp()\n\tMagicSphere2(10,5,Torso.CFrame,\"Black\")\n\tRootPart.CFrame = CF(VT(Mouse.Hit.p.X,Mouse.Hit.p.Y+4,Mouse.Hit.p.Z))\n\tCreateSound(\"282061340\", Torso, 2, 1)\n\tMagicSphere(5,5,Torso.CFrame,\"Black\")\n\tfor i = 1, 3 do\n\t\tCreateSwirl(0,5,true,-0.2,25,Torso.CFrame * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360))),\"Really black\")\n\tend\n\tkillnearest(Torso.Position,12,25)\n\tSwait()\n\tturnto(Mouse.Hit.p)\nend\n\n--//=================================\\\\\n--||\t  ASSIGN THINGS TO KEYS\n--\\\\=================================//\n\nHumanoid.Changed:connect(function(Jump)\n\tif Jump == \"Jump\" and (Disable_Jump == true or DISABLEJUMPING == true) then\n\t\tHumanoid.Jump = false\n\tend\nend)\n\nfunction MouseDown(Mouse)\n\tif ATTACK == false then\n\tend\nend\n\nfunction MouseUp(Mouse)\nHOLD = false\nend\n\nfunction KeyDown(Key)\n\tKEYHOLD = true\n\tif Key == \"e\" and ATTACK == false then\n\t\tTyranyCannon()\n\t\twait(1)\n\t\tDetonate()\n\tend\n\n\tif Key == \"e\" and ATTACK == false then\n\t\tEarthShatter()\n\tend\n\n\tif Key == \"r\" and ATTACK == false then\n\t\tRavagingOverthrower()\n\tend\n\n\tif Key == \"q\" and ATTACK == false then\n\t\tWarp()\n\tend\n\n\tif Key == \"t\" and ATTACK == false then\n\t\tCreateSound(\"159882644\", Head, 5, 0.8)\n\tend\n\n\tif Key == \"t\" and DANCE == true then\n\t\tCreateSound(\"887591869\", Head, 5, 1)\n\tend\n\n\tif Key == \"x\" and (ATTACK == false or DANCE == true) then\n\t\tif DANCE == false then\n\t\t\tdodadance()\n\t\telseif DANCE == true then\n\t\t\tDANCE = false\n\t\tend\n\tend\nend\n\nfunction KeyUp(Key)\n\tKEYHOLD = false\nend\n\n\tMouse.Button1Down:connect(function(NEWKEY)\n\t\tMouseDown(NEWKEY)\n\tend)\n\tMouse.Button1Up:connect(function(NEWKEY)\n\t\tMouseUp(NEWKEY)\n\tend)\n\tMouse.KeyDown:connect(function(NEWKEY)\n\t\tKeyDown(NEWKEY)\n\tend)\n\tMouse.KeyUp:connect(function(NEWKEY)\n\t\tKeyUp(NEWKEY)\n\tend)\n\n--//=================================\\\\\n--\\\\=================================//\n\n\nfunction unanchor()\n\tif UNANCHOR == true then\n\t\tg = Character:GetChildren()\n\t\tfor i = 1, #g do\n\t\t\tif g[i].ClassName == \"Part\" then\n\t\t\t\tg[i].Anchored = false\n\t\t\tend\n\t\tend\n\tend\nend\n\n\n--//=================================\\\\\n--||\tWRAP THE WHOLE SCRIPT UP\n--\\\\=================================//\n\nHumanoid.Changed:connect(function(Jump)\n\tif Jump == \"Jump\" and (Disable_Jump == true or DISABLEJUMPING == true) then\n\t\tHumanoid.Jump = false\n\tend\nend)\n\n\t\tANIMATE.Parent = nil\n\t\tlocal IDLEANIMATION = Humanoid:LoadAnimation(ROBLOXIDLEANIMATION)\n\t\tIDLEANIMATION:Play()\n\nwhile true do\n\tSwait()\n\tSINE = SINE + CHANGE\n\tlocal TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude\n\tlocal TORSOVERTICALVELOCITY = RootPart.Velocity.y\n\tlocal LV = Torso.CFrame:pointToObjectSpace(Torso.Velocity - Torso.Position)\n\tlocal HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4 * Player_Size, Character)\n\tlocal WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)\n\t\tif ANIM == \"Walk\" and TORSOVELOCITY > 1 then\n\t\t\tRootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.1 * COS(SINE / (WALKSPEEDVALUE / 2)) * Player_Size) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tNeck.C1 = Clerp(Neck.C1, CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tRightHip.C1 = Clerp(RightHip.C1, CF(0.5 * Player_Size, 0.875 * Player_Size - 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, -0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tLeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5 * Player_Size, 0.875 * Player_Size + 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, 0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\telseif (ANIM ~= \"Walk\") or (TORSOVELOCITY < 1) then\n\t\t\tRootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tNeck.C1 = Clerp(Neck.C1, CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tRightHip.C1 = Clerp(RightHip.C1, CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\tLeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\tend\n\t\tif TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then\n\t\t\tANIM = \"Jump\"\n\t\t\tif ATTACK == false then\n\t\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(30)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)\n\t\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0.3 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t        end\n\t\telseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then\n\t\t\tANIM = \"Fall\"\n\t\t\tif ATTACK == false then\n\t\t\t\tRootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)\n\t\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(70)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)\n\t\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)\n\t\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)\n\t\t\tend\n\t\telseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then\n\t\t\tANIM = \"Idle\"\n\t\t\tif ATTACK == false then\n\t\t\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-20)), 0.15 / Animation_Speed)\n\t\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(5)), 0.15 / Animation_Speed)\n\t\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(5), RAD(0), RAD(30)) * ANGLES(RAD(3), RAD(25), RAD(5)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)\n\t\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(10 - 2.5 * COS(SINE / 16)), RAD(0), RAD(-25 + 2.5 * SIN(SINE / 24))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)\n\t\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size - 0.05 * COS(SINE / 12) * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-2.5)), 0.15 / Animation_Speed)\n\t\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -0.8 * Player_Size - 0.05 * COS(SINE / 12) * Player_Size, -0.2 * Player_Size) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7.5), RAD(0), RAD(-15)), 0.15 / Animation_Speed)\n\t\t\tend\n\t\telseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then\n\t\t\tANIM = \"Walk\"\n\t\t\tWALK = WALK + 1 / Animation_Speed\n\t\t\tif WALK >= 15 - (5 * (Humanoid.WalkSpeed / 16 / Player_Size)) then\n\t\t\t\tWALK = 0\n\t\t\t\tif WALKINGANIM == true then\n\t\t\t\t\tWALKINGANIM = false\n\t\t\t\telseif WALKINGANIM == false then\n\t\t\t\t\tWALKINGANIM = true\n\t\t\t\tend\n\t\t\tend\n\t\t\t--RightHip.C1 = Clerp(RightHip.C1, CF(0.5 * Player_Size, 0.875 * Player_Size - 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, -0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\t--LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5 * Player_Size, 0.875 * Player_Size + 0.125 * SIN(SINE / WALKSPEEDVALUE) * Player_Size, 0.125 * COS(SINE / WALKSPEEDVALUE) * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(60 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)\n\t\t\tif ATTACK == false then\n\t\t\t\tRootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(10), RAD(0), RAD(-20)), 0.15 / Animation_Speed)\n\t\t\t\tNeck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(5)), 0.15 / Animation_Speed)\n\t\t\t\tRightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)\n\t\t\t\tLeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)\n\t\t\t\tRightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\t\t\tLeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7.5), RAD(0), RAD(0)), 0.15 / Animation_Speed)\n\t\t\tend\n\t\tend\nif #Effects2>0 then\nfor e=1,#Effects2 do\nif Effects2[e]~=nil then\nlocal Thing=Effects2[e]\nif Thing~=nil then\nlocal Part=Thing[1]\nlocal Mode=Thing[2]\nlocal Delay=Thing[3]\nlocal IncX=Thing[4]\nlocal IncY=Thing[5]\nlocal IncZ=Thing[6]\nlocal Part2=Thing[8]\nif Thing[1].Transparency<=1 then\nif Thing[2]==\"Block1\" then\nThing[1].CFrame=Thing[1].CFrame\nMesh=Thing[1].Mesh\nMesh.Scale=Mesh.Scale+VT(Thing[4],Thing[5],Thing[6])\nThing[1].Transparency=Thing[1].Transparency+Thing[3]\nelseif Thing[2]==\"Cylinder\" then\nMesh=Thing[1].Mesh\nMesh.Scale=Mesh.Scale+VT(Thing[4],Thing[5],Thing[6])\nThing[1].Transparency=Thing[1].Transparency+Thing[3]\nelseif Thing[2]==\"Blood\" then\nMesh=Thing[7]\nThing[1].CFrame=Thing[1].CFrame*CF(0,.5,0)\nMesh.Scale=Mesh.Scale+VT(Thing[4],Thing[5],Thing[6])\nThing[1].Transparency=Thing[1].Transparency+Thing[3]\nelseif Thing[2]==\"Elec\" then\nMesh=Thing[1].Mesh\nMesh.Scale=Mesh.Scale+VT(Thing[7],Thing[8],Thing[9])\nThing[1].Transparency=Thing[1].Transparency+Thing[3]\nelseif Thing[2]==\"Disappear\" then\nThing[1].Transparency=Thing[1].Transparency+Thing[3]\nend\nelse\nPart.Parent=nil\ntable.remove(Effects2,e)\nend\nend\nend\nend\nend\nunanchor()\nHumanoid.MaxHealth = \"inf\"\nHumanoid.Health = \"inf\"\nHumanoid.Name = \"Ravage\"\nif Rooted == false then\n\tDisable_Jump = false\n\tHumanoid.WalkSpeed = Speed\nelseif Rooted == true then\n\tDisable_Jump = true\n\tHumanoid.WalkSpeed = 0\nend\nq = Character:GetChildren()\nfor u = 1, #q do\n\tif q[u].ClassName == \"Accessory\" or q[u].ClassName == \"Hat\" then\n\t\tq[u]:remove()\n\telseif q[u].ClassName == \"Shirt\" then\n\t\tq[u]:Destroy()\n\telseif q[u].ClassName == \"Pants\" then\n\t\tq[u]:Destroy()\n\telseif q[u].ClassName == \"CharacterMesh\" then\n\t\tq[u]:remove()\n\telseif q[u].ClassName == \"ShirtGraphic\" then\n\t\tq[u]:remove()\n\telseif q[u].ClassName == \"Part\" and q[u].Name ~= \"HumanoidRootPart\" then\n\t\tq[u].Color = Color3.new(0/255, 0/255, 0/255)\n\tend\nend\nif Head:FindFirstChild(\"face\") then\n\tHead.face:remove()\nend\nif Head:FindFirstChild(\"Died\") then\n\tHead.Died:remove()\nend\nbomb = Bombs:GetChildren()\n\tfor lol = 1, #bomb do\n\t\tif bomb[lol].ClassName == \"Part\" then\n\t\t\tMagicSphere2(2,5,bomb[lol].CFrame,\"Really black\")\n\t\tend\n\tend\nend\n\n--//=================================\\\\\n--\\\\=================================//",
 "title": ""
}