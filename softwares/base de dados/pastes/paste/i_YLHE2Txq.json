{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "re_php",
  "lg_en"
 ],
 "key": "YLHE2Txq",
 "pasteDate": "Feb 20, 2018, 7:51:56 PM",
 "relevancy": -3.0,
 "relevant": false,
 "text": "-module(ehaml).\n\n-compile(export_all).\n% -export([indentation_level/1, split_lines/1, strip_indentation/1, is_tag/1]).\n\n-define(CR, 13).\n-define(LF, 10).\n-define(SPACE, 32).\n-define(PERCENT, $%).\n-define(APOS, $').\n-define(QUOTE, $\").\n-define(COLON, $:).\n-define(ARROW, $=,$>).\n-define(COMMA, $,).\n-define(LBRACE, ${).\n-define(RBRACE, $}).\n-define(SLASH, $\\\\).\n\nparse_attributes(<<?LBRACE:8, Rest/binary>>) ->\n  lists:reverse(parse_attributes(Rest, []));\nparse_attributes(<<>>) -> \n  [].\n\n% Parsing whole attributes\nparse_attributes(<<?COLON:8, Rest/binary>>, AttrList) ->\n  Key = [],\n  Value = [],\n  parse_attributes(Rest, Key, Value, symbol, AttrList);\nparse_attributes(<<?SPACE:8, Rest/binary>>, AttrList) ->\n  parse_attributes(Rest, AttrList);\nparse_attributes(<<?RBRACE:8, _Rest/binary>>, AttrList) ->\n  lists:reverse(AttrList);\nparse_attributes(<<>>, AttrList) ->\n  lists:reverse(AttrList).\n\n% Attribute key as a Ruby Symbol\nparse_attributes(<<?SPACE:8, Rest/binary>>, Key, Value, symbol, AttrList) ->\n  parse_attributes(Rest, list_to_binary(lists:reverse(Key)), Value, arrow, AttrList);\nparse_attributes(<<?ARROW, Rest/binary>>, Key, Value, symbol, AttrList) ->\n  parse_attributes(Rest, list_to_binary(lists:reverse(Key)), Value, arrow, AttrList);\nparse_attributes(<<Char:8, Rest/binary>>, Key, Value, symbol, AttrList) ->\n  parse_attributes(Rest, [Char|Key], Value, symbol, AttrList);\n\n% Read the hash arrow, begin parsing the value\nparse_attributes(<<?SPACE:8, Rest/binary>>, Key, Value, arrow, AttrList) ->\n  parse_attributes(Rest, Key, Value, arrow, AttrList);\nparse_attributes(<<?ARROW, Rest/binary>>, Key, Value, arrow, AttrList) ->\n  parse_attributes(Rest, Key, Value, arrow, AttrList);\nparse_attributes(<<?QUOTE:8, Rest/binary>>, Key, Value, arrow, AttrList) ->\n  parse_attributes(Rest, Key, Value, dqval, AttrList);\nparse_attributes(<<?APOS:8, Rest/binary>>, Key, Value, arrow, AttrList) ->\n  parse_attributes(Rest, Key, Value, sqval, AttrList);\n\n% Single-quoted attribute values\nparse_attributes(<<?SLASH:8, ?APOS:8, Rest/binary>>, Key, Value, sqval, AttrList) ->\n  parse_attributes(Rest, Key, [?APOS|Value], sqval, AttrList);\nparse_attributes(<<?APOS:8, Rest/binary>>, Key, Value, sqval, AttrList) ->\n  parse_attributes(Rest, Key, list_to_binary(lists:reverse(Value)), attrend, AttrList);\nparse_attributes(<<Char:8, Rest/binary>>, Key, Value, sqval, AttrList) ->\n  parse_attributes(Rest, Key, [Char|Value], sqval, AttrList);\n\n% Double-quoted attribute values\nparse_attributes(<<?SLASH:8, ?QUOTE:8, Rest/binary>>, Key, Value, dqval, AttrList) ->\n  parse_attributes(Rest, Key, [?QUOTE|Value], dqval, AttrList);\nparse_attributes(<<?QUOTE:8, Rest/binary>>, Key, Value, dqval, AttrList) ->\n  parse_attributes(Rest, Key, list_to_binary(lists:reverse(Value)), attrend, AttrList);\nparse_attributes(<<Char:8, Rest/binary>>, Key, Value, dqval, AttrList) ->\n  parse_attributes(Rest, Key, [Char|Value], dqval, AttrList);\n\n% Close out the attribute (expect a comma, space, or brace)\nparse_attributes(<<?SPACE:8, Rest/binary>>, Key, Value, attrend, AttrList) ->\n  parse_attributes(Rest, Key, Value, attrend, AttrList);\nparse_attributes(<<?COMMA:8, Rest/binary>>, Key, Value, attrend, AttrList) ->\n  parse_attributes(Rest, [{Key, Value}|AttrList]);\nparse_attributes(<<?RBRACE:8, Rest/binary>>, Key, Value, attrend, AttrList) ->\n  parse_attributes(<<?RBRACE:8, Rest/binary>>, [{Key, Value}|AttrList]);\nparse_attributes(<<Char:8, _Rest/binary>>, _Key, _Value, attrend, _AttrList) ->\n  throw({unexpected_char, Char, {expected, [?COMMA, ?RBRACE, ?SPACE]}}).\n  \n  \nis_tag(<<?PERCENT:8, _Rest/binary>>) -> true;\nis_tag(Rest) when is_binary(Rest) -> false.\n\nstrip_indentation(<<?SPACE:8,?SPACE:8,Rest/binary>>) ->\n  strip_indentation(Rest);\nstrip_indentation(<<Rest/binary>>) ->\n  Rest.\n\nindentation_level(<<?SPACE:8,?SPACE:8,Rest/binary>>) ->\n  indentation_level(Rest) + 1;\nindentation_level(<<?SPACE:8, _Rest/binary>>) ->\n  throw(illegal_indentation);\nindentation_level(<<>>) ->\n  0;\nindentation_level(<<_Rest/binary>>) ->\n  0.\n\nsplit_lines(Bin) when is_binary(Bin)->\n  lists:reverse(split_lines(Bin, [], [])).\n\nsplit_lines(<<>>, [], Acc) ->\n  Acc;\nsplit_lines(<<?CR:8, ?LF:8, Rest/binary>>, Line, Acc) ->\n  split_lines(Rest, [], [list_to_binary(lists:reverse(Line))|Acc]);\n\nsplit_lines(<<?LF:8, Rest/binary>>, Line, Acc) ->\n  split_lines(Rest, [], [list_to_binary(lists:reverse(Line))|Acc]);\n\nsplit_lines(<<?CR:8, Rest/binary>>, Line, Acc) ->\n  split_lines(Rest, [], [list_to_binary(lists:reverse(Line))|Acc]);\n\nsplit_lines(<<Char:8, Rest/binary>>, Line, Acc) ->\n  split_lines(Rest, [Char|Line], Acc);\n\n% Case where no newline terminates file\nsplit_lines(<<>>, Line, Acc) ->\n  split_lines(<<>>, [], [list_to_binary(lists:reverse(Line))|Acc]).",
 "title": ""
}