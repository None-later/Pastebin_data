{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "kzKFqxMf",
 "pasteDate": "Feb 23, 2018, 1:51:01 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "TypeError: float argument required, not numpy.ndarray\n\t\nimport numpy as np\nx = np.arange(20).reshape((4,5))\nnp.savetxt('test.txt', x)\n\t\nimport numpy as np\nx = np.arange(200).reshape((4,5,10))\nnp.savetxt('test.txt', x)\n\t\nx = np.arange(200).reshape((4,5,10))\nwith file('test.txt', 'w') as outfile:\n    for slice_2d in x:\n        np.savetxt(outfile, slice_2d)\n\t\nimport numpy as np\n\n# Generate some test data\ndata = np.arange(200).reshape((4,5,10))\n\n# Write the array to disk\nwith file('test.txt', 'w') as outfile:\n    # I'm writing a header here just for the sake of readability\n    # Any line starting with \"#\" will be ignored by numpy.loadtxt\n    outfile.write('# Array shape: {0}n'.format(data.shape))\n\n    # Iterating through a ndimensional array produces slices along\n    # the last axis. This is equivalent to data[i,:,:] in this case\n    for data_slice in data:\n\n        # The formatting string indicates that I'm writing out\n        # the values in left-justified columns 7 characters in width\n        # with 2 decimal places.  \n        np.savetxt(outfile, data_slice, fmt='%-7.2f')\n\n        # Writing out a break to indicate different slices...\n        outfile.write('# New slicen')\n\t\n# Array shape: (4, 5, 10)\n0.00    1.00    2.00    3.00    4.00    5.00    6.00    7.00    8.00    9.00   \n10.00   11.00   12.00   13.00   14.00   15.00   16.00   17.00   18.00   19.00  \n20.00   21.00   22.00   23.00   24.00   25.00   26.00   27.00   28.00   29.00  \n30.00   31.00   32.00   33.00   34.00   35.00   36.00   37.00   38.00   39.00  \n40.00   41.00   42.00   43.00   44.00   45.00   46.00   47.00   48.00   49.00  \n# New slice\n50.00   51.00   52.00   53.00   54.00   55.00   56.00   57.00   58.00   59.00  \n60.00   61.00   62.00   63.00   64.00   65.00   66.00   67.00   68.00   69.00  \n70.00   71.00   72.00   73.00   74.00   75.00   76.00   77.00   78.00   79.00  \n80.00   81.00   82.00   83.00   84.00   85.00   86.00   87.00   88.00   89.00  \n90.00   91.00   92.00   93.00   94.00   95.00   96.00   97.00   98.00   99.00  \n# New slice\n100.00  101.00  102.00  103.00  104.00  105.00  106.00  107.00  108.00  109.00 \n110.00  111.00  112.00  113.00  114.00  115.00  116.00  117.00  118.00  119.00 \n120.00  121.00  122.00  123.00  124.00  125.00  126.00  127.00  128.00  129.00 \n130.00  131.00  132.00  133.00  134.00  135.00  136.00  137.00  138.00  139.00 \n140.00  141.00  142.00  143.00  144.00  145.00  146.00  147.00  148.00  149.00 \n# New slice\n150.00  151.00  152.00  153.00  154.00  155.00  156.00  157.00  158.00  159.00 \n160.00  161.00  162.00  163.00  164.00  165.00  166.00  167.00  168.00  169.00 \n170.00  171.00  172.00  173.00  174.00  175.00  176.00  177.00  178.00  179.00 \n180.00  181.00  182.00  183.00  184.00  185.00  186.00  187.00  188.00  189.00 \n190.00  191.00  192.00  193.00  194.00  195.00  196.00  197.00  198.00  199.00 \n# New slice\n\t\n# Read the array from disk\nnew_data = np.loadtxt('test.txt')\n\n# Note that this returned a 2D array!\nprint new_data.shape\n\n# However, going back to 3D is easy if we know the \n# original shape of the array\nnew_data = new_data.reshape((4,5,10))\n\n# Just to check that they're the same...\nassert np.all(new_data == data)\n\t\nimport pickle\n\nmy_data = {'a': [1, 2.0, 3, 4+6j],\n           'b': ('string', u'Unicode string'),\n           'c': None}\noutput = open('data.pkl', 'wb')\npickle.dump(data1, output)\noutput.close()\n\t\nimport pprint, pickle\n\npkl_file = open('data.pkl', 'rb')\n\ndata1 = pickle.load(pkl_file)\npprint.pprint(data1)\n\npkl_file.close()\n\t\nimport numpy as np\nimport scipy.io\n\n# Some test data\nx = np.arange(200).reshape((4,5,10))\n\n# Specify the filename of the .mat file\nmatfile = 'test_mat.mat'\n\n# Write the array to the mat file. For this to work, the array must be the value\n# corresponding to a key name of your choice in a dictionary\nscipy.io.savemat(matfile, mdict={'out': x}, oned_as='row')\n\n# For the above line, I specified the kwarg oned_as since python (2.7 with \n# numpy 1.6.1) throws a FutureWarning.  Here, this isn't really necessary \n# since oned_as is a kwarg for dealing with 1-D arrays.\n\n# Now load in the data from the .mat that was just saved\nmatdata = scipy.io.loadmat(matfile)\n\n# And just to check if the data is the same:\nassert np.all(x == matdata['out'])\n\t\nprint matdata.keys()\n\t\na.tofile('yourfile.txt',sep=\" \",format=\"%s\")\n\t\nimport numpy as np\n\ntrial = np.genfromtxt(\"/extension/file.txt\", dtype = str, delimiter = \",\")\n\nwith open(\"/extension/file.txt\", \"w\") as f:\n    for x in xrange(len(trial[:,1])):\n        for y in range(num_of_columns):\n            if y < num_of_columns-2:\n                f.write(trial[x][y] + \",\")\n            elif y == num_of_columns-1:\n                f.write(trial[x][y])\n        f.write(\"n\")",
 "title": ""
}