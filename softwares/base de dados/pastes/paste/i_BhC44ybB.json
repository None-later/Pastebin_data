{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "re_url",
  "lg_en",
  "re_ast1"
 ],
 "key": "BhC44ybB",
 "pasteDate": "Feb 18, 2018, 8:19:23 AM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "--MADE BY OneLegend (NOT THE SCRIPT) LOCAL SCRIPT: Go to line 5 and put your name where it says \"Magermash\"\n\nif script.Parent.className ~= \"HopperBin\" then \nh = Instance.new(\"HopperBin\") \nlocal admin = game.Players.NBA202121\nh.Name = \"Epic Blades\" \nscript.Parent = h \nh.Parent = admin.Backpack \nend \n\nbin = script.Parent \nplayer = bin.Parent.Parent.Character \nrarm = player[\"Right Arm\"] \nlarm = player[\"Left Arm\"] \nvisible = true \n--for i, v in pairs(game.Players:GetChildren()) do \n--bin:Clone().Parent = v.Backpack \n--end \non = 1 \n\nlocal glideg = Instance.new(\"BodyGyro\") \nlocal glidev = Instance.new(\"BodyVelocity\") \n\nfunction shadow(rblade,lblade) \nwhile on == 1 do \nwait(.1) \nif visible then \nlocal a = rblade:clone() \nlocal b = lblade:clone() \na.Anchored = true \na.Parent = player \na.CFrame = rblade.CFrame \na.CanCollide = false \na.Transparency = .2 \nb.Anchored = true \nb.Parent = player \nb.CFrame = lblade.CFrame \nb.CanCollide = false \nb.Transparency = .2 \ncoroutine.resume(coroutine.create(function() dissapate(a,b) end)) \nend \nend \nend \n\nfunction stun(blast) \nfor x = 1,15 do \nwait(1) \nlocal sap = game.Players:GetChildren() \nfor i = 1,#sap do \nwait() \nif (sap.Character.Torso.Position - Workspace.keel.Position).magnitude < 20 then \nsap.Character.Humanoid.Sit = true \nend \nend \nend \nend \n\nfunction dissapate(a,b) \nfor i = 1,8 do \nwait() \na.Transparency = a.Transparency +.1 \nb.Transparency = b.Transparency +.1 \nend \na:remove() \nb:remove() \nend \n\nbin.Selected:connect(function(mouse) \non = 1 \nif player.Torso:findFirstChild(\"Right Shoulder\") ~= nil then \nrs = player.Torso[\"Right Shoulder\"] \nrs.Part1 = nil \nend \nif player.Torso:findFirstChild(\"Left Shoulder\") ~= nil then \nls = player.Torso[\"Left Shoulder\"] \nls.Part1 = nil \nend \nif player:FindFirstChild(\"check\") == nil then \nrns = Instance.new(\"Weld\") \nrns.Parent = player.Torso \nrns.Part0 = rns.Parent \nrns.Part1 = player[\"Right Arm\"] \nrns.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nlns = Instance.new(\"Weld\") \nlns.Parent = player.Torso \nlns.Part0 = lns.Parent \nlns.Part1 = player[\"Left Arm\"] \nlns.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nrblade = Instance.new(\"Part\") \nrblade.BrickColor = BrickColor.new(\"Institutional white\") \nrblade.Name =\"check\" \nrblade.Parent = player \nrblade.CanCollide = false \nrblade.Size = Vector3.new(1,3,1) \nrblade.formFactor = \"Symmetric\" \nrblade.TopSurface = 0 \nrblade.BottomSurface = 0 \nrbm = Instance.new(\"BlockMesh\") \nrbm.Parent = rblade \nrbm.Scale = Vector3.new(.1,1,.3) \nrbw = Instance.new(\"Weld\") \nrbw.Parent = rarm \nrbw.Part0 = rarm \nrbw.Part1 = rblade \nrbw.C1 = CFrame.new(0,1,0) \nlblade = Instance.new(\"Part\") \nlblade.BrickColor = rblade.BrickColor \nlblade.Name = \"checkb\" \nlblade.Parent = player \nlblade.CanCollide = false \nlblade.Size = Vector3.new(1,3,1) \nlblade.formFactor = \"Symmetric\" \nlblade.TopSurface = 0 \nlblade.BottomSurface = 0 \nlbm = Instance.new(\"BlockMesh\") \nlbm.Parent = lblade \nlbm.Scale = Vector3.new(.1,1,.3) \nlbw = Instance.new(\"Weld\") \nlbw.Parent = larm \nlbw.Part0 = larm \nlbw.Part1 = lblade \nlbw.C1 = CFrame.new(0,1,0) \ncoroutine.resume(coroutine.create(function() shadow(rblade, lblade) end)) \nend \nrblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nif hit.Parent.Humanoid.MaxHealth > 100 then \nhit.Parent.Humanoid.MaxHealth = 100 \nend \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - math.random(3,7) \nfor i = 1, (math.random(1,3)) do \nwait() \nlocal bleed = Instance.new(\"Part\") \nbleed.formFactor = \"Symmetric\" \nbleed.Size = Vector3.new(1,1,1) \nbleed.BrickColor = BrickColor.new(\"Bright red\") \nbleed.TopSurface = 0 \nbleed.BottomSurface = 0 \nbleed.Reflectance = .1 \nbleed.Transparency = .4 \nbleed.Parent = Workspace \nbleed.Position = rblade.Position \nlocal bleedm = Instance.new(\"SpecialMesh\") \nbleedm.MeshType = \"Sphere\" \nbleedm.Scale = Vector3.new(.2,.2,.2) \nbleedm.Parent = bleed \ngame:GetService(\"Debris\"):AddItem(bleed, 5) \nend \nend \nend \nend) \n\nlblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nif hit.Parent.Humanoid.MaxHealth > 100 then \nhit.Parent.Humanoid.MaxHealth = 100 \nend \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - math.random(3,7) \nfor i = 1, (math.random(1,3)) do \nwait() \nlocal bleed = Instance.new(\"Part\") \nbleed.formFactor = \"Symmetric\" \nbleed.Size = Vector3.new(1,1,1) \nbleed.BrickColor = BrickColor.new(\"Bright red\") \nbleed.TopSurface = 0 \nbleed.BottomSurface = 0 \nbleed.Reflectance = .1 \nbleed.Transparency = .4 \nbleed.Parent = Workspace \nbleed.Position = lblade.Position \nlocal bleedm = Instance.new(\"SpecialMesh\") \nbleedm.MeshType = \"Sphere\" \nbleedm.Scale = Vector3.new(.2,.2,.2) \nbleedm.Parent = bleed \ngame:GetService(\"Debris\"):AddItem(bleed, 5) \nend \nend \nend \nend) \n----end of blades \nright = rns \nleft = lns \nmouse.KeyDown:connect(function(key) \nkey = key:lower() \nprint(key) \nif key == \"z\" and rblade.Transparency <= 0 then \nfor i = 1,50 do \nwait() \nrblade.Transparency = rblade.Transparency + .02 \nlblade.Transparency = lblade.Transparency + .02 \nend \nrblade.Transparency = 1 \nlblade.Transparency = 1 \nvisible = false \nelseif key == \"x\" and rblade.Transparency > 0 then \nvisible = true \nfor i = 1,50 do \nwait() \nrblade.Transparency = rblade.Transparency - .02 \nlblade.Transparency = lblade.Transparency - .02 \nend \nrblade.Transparency = 0 \nlblade.Transparency = 0 \nelseif key == \"c\" then \nwait() \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nend \nif key == \"e\" then \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nwait() \nright.C1 = CFrame.new(-1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nwait(.5) \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nelseif key == \"q\" then \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nleft.C1 = CFrame.new(1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait(.5) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nelseif key == \"r\" then \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nleft.C1 = CFrame.new(1.42,0.62,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*.3)) \nwait() \nleft.C1 = CFrame.new(1.29,0.84,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*.35)) \nwait() \nleft.C1 = CFrame.new(1.16,1.06,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*.4)) \nwait() \nleft.C1 = CFrame.new(1.03,1.28,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*.45)) \nwait() \nleft.C1 = CFrame.new(0.9,1.5,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*.5)) \nwait(.2) \nleft.C1 = CFrame.new(0.9,1.5,-0.15)*CFrame.Angles((math.pi*-.15),(math.pi*0),(math.pi*.5)) \nwait() \nleft.C1 = CFrame.new(0.9,1.5,-0.30)*CFrame.Angles((math.pi*-.30),(math.pi*0),(math.pi*.5)) \nwait() \nleft.C1 = CFrame.new(0.9,1.5,-0.45)*CFrame.Angles((math.pi*-.45),(math.pi*0),(math.pi*.5)) \nwait() \nleft.C1 = CFrame.new(0.9,1.5,-0.60)*CFrame.Angles((math.pi*-.60),(math.pi*0),(math.pi*.5)) \nwait() \nleft.C1 = CFrame.new(0.9,1.5,-0.75)*CFrame.Angles((math.pi*-.75),(math.pi*0),(math.pi*.5)) \nwait(.1) \nleft.C1 = CFrame.new(1.03,1.28,0)*CFrame.Angles((math.pi*-.60),(math.pi*0),(math.pi*.45)) \nwait() \nleft.C1 = CFrame.new(1.16,1.06,0)*CFrame.Angles((math.pi*-.45),(math.pi*0),(math.pi*.4)) \nwait() \nleft.C1 = CFrame.new(1.29,0.84,0)*CFrame.Angles((math.pi*-.30),(math.pi*0),(math.pi*.35)) \nwait() \nleft.C1 = CFrame.new(1.42,0.62,0)*CFrame.Angles((math.pi*-.15),(math.pi*0),(math.pi*.3)) \nwait() \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nelseif key == \"t\" then \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nwait() \nright.C1 = CFrame.new(-1.42,0.62,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*-.3)) \nwait() \nright.C1 = CFrame.new(-1.29,0.84,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*-.35)) \nwait() \nright.C1 = CFrame.new(-1.16,1.06,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*-.4)) \nwait() \nright.C1 = CFrame.new(-1.03,1.28,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*-.45)) \nwait() \nright.C1 = CFrame.new(-0.9,1.5,0)*CFrame.Angles((math.pi*0),(math.pi*0),(math.pi*-.5)) \nwait(.2) \nright.C1 = CFrame.new(-0.9,1.5,-0.15)*CFrame.Angles((math.pi*-.15),(math.pi*0),(math.pi*-.5)) \nwait() \nright.C1 = CFrame.new(-0.9,1.5,-0.30)*CFrame.Angles((math.pi*-.30),(math.pi*0),(math.pi*-.5)) \nwait() \nright.C1 = CFrame.new(-0.9,1.5,-0.45)*CFrame.Angles((math.pi*-.45),(math.pi*0),(math.pi*-.5)) \nwait() \nright.C1 = CFrame.new(-0.9,1.5,-0.60)*CFrame.Angles((math.pi*-.60),(math.pi*0),(math.pi*-.5)) \nwait() \nright.C1 = CFrame.new(-0.9,1.5,-0.75)*CFrame.Angles((math.pi*-.75),(math.pi*0),(math.pi*-.5)) \nwait(.1) \nright.C1 = CFrame.new(-1.03,1.28,0)*CFrame.Angles((math.pi*-.60),(math.pi*0),(math.pi*-.45)) \nwait() \nright.C1 = CFrame.new(-1.16,1.06,0)*CFrame.Angles((math.pi*-.45),(math.pi*0),(math.pi*-.4)) \nwait() \nright.C1 = CFrame.new(-1.29,0.84,0)*CFrame.Angles((math.pi*-.30),(math.pi*0),(math.pi*-.35)) \nwait() \nright.C1 = CFrame.new(-1.42,0.62,0)*CFrame.Angles((math.pi*-.15),(math.pi*0),(math.pi*-.3)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nend \n--abilities \nif key == \"b\" then \nlocal a = player:GetChildren() \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nfor x = 1, 5 do \nwait() \na.Transparency = a.Transparency +.2 \nend \nelseif a.className == \"Hat\" then \nfor x = 1, 5 do \nwait() \na.Handle.Transparency = a.Handle.Transparency +.2 \nend \nend \nend \nplayer.Torso.CFrame = mouse.Hit + Vector3.new(0,4,0) \nwait() \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nfor x = 1, 5 do \nwait() \na.Transparency = a.Transparency -.2 \nend \nelseif a.className == \"Hat\" then \nfor x = 1, 5 do \nwait() \na.Handle.Transparency = a.Handle.Transparency -.2 \nend \nend \nend \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nwait() \na.Transparency = 0 \nelseif a.className == \"Hat\" then \nwait() \na.Handle.Transparency = 0 \nend \nend \nend \nif key == \"v\" then \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait(.2) \nwait(.45) \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nend \nif key == \"f\" then \nlocal tar = mouse.Target \nif tar.Parent:findFirstChild(\"Humanoid\") ~= nil then \nlocal float = Instance.new(\"BodyPosition\") \nfloat.Parent = tar.Parent.Torso \nfloat.maxForce = Vector3.new(math.huge,math.huge,math.huge) \nfloat.position = tar.Parent.Torso.Position + Vector3.new(0,10,0) \nwait(1) \nplayer.Humanoid.MaxHealth = 99999 \nplayer.Humanoid.Health = 99999 \nlocal floatme = Instance.new(\"BodyPosition\") \nfloatme.Parent = player.Torso \nfloatme.maxForce = Vector3.new(math.huge,math.huge,math.huge) \nfloatme.position = tar.Parent.Torso.Position \nwait(1) \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.35,.5,-.25)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.39,.4,-.2)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.43,.3,-.15)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.47,.2,-.1)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.51,.1,-.05)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait(.5) \nplayer.Humanoid.MaxHealth = 100 \nplayer.Humanoid.Health = 100 \nfloat:remove() \nfloatme:remove() \nend \nend \nif key == \"g\" then \n-- \nrblade2 = Instance.new(\"Part\") \nrblade2.BrickColor = BrickColor.new(\"Really black\") \nrblade2.Parent = player \nrblade2.CanCollide = false \nrblade2.Size = Vector3.new(1,6,1) \nrblade2.CFrame = rblade.CFrame \nrblade2.formFactor = \"Symmetric\" \nrblade2.TopSurface = 0 \nrblade2.BottomSurface = 0 \nrblade2.Reflectance = .5 \nrbm2 = Instance.new(\"BlockMesh\") \nrbm2.Parent = rblade2 \nrbm2.Scale = Vector3.new(.21,1,.31) \nrbw2 = Instance.new(\"Weld\") \nrbw2.Parent = rblade \nrbw2.Part0 = rblade \nrbw2.Part1 = rblade2 \nlblade2 = Instance.new(\"Part\") \nlblade2.BrickColor = rblade.BrickColor \nlblade2.Parent = player \nlblade2.CanCollide = false \nlblade2.Size = Vector3.new(1,6,1) \nlblade2.CFrame = lblade.CFrame \nlblade2.formFactor = \"Symmetric\" \nlblade2.TopSurface = 0 \nlblade2.BottomSurface = 0 \nlblade2.Reflectance = .5 \nlbm2 = Instance.new(\"BlockMesh\") \nlbm2.Parent = lblade2 \nlbm2.Scale = Vector3.new(.21,1,.31) \nlbw2 = Instance.new(\"Weld\") \nlbw2.Parent = lblade \nlbw2.Part0 = lblade \nlbw2.Part1 = lblade2 \nrblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - 10 \nend \nend \nend) \nlblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - 10 \nend \nend \nend) \n-- \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-1),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-1),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nlblade2:remove() \nrblade2:remove() \nend \nif key == \"h\" then \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.00,-.5,.5)*CFrame.Angles((math.pi*-.5),(math.pi*-.5),(math.pi*-.00)) \nleft.C1 = CFrame.new(1.00,-.5,.5)*CFrame.Angles((math.pi*-.5),(math.pi*.5),(math.pi*.00)) \nwait() \n-- \nrblade2 = Instance.new(\"Part\") \nrblade2.BrickColor = BrickColor.new(\"Really black\") \nrblade2.Parent = player \nrblade2.CanCollide = false \nrblade2.Size = Vector3.new(1,6,1) \nrblade2.CFrame = rblade.CFrame \nrblade2.formFactor = \"Symmetric\" \nrblade2.TopSurface = 0 \nrblade2.BottomSurface = 0 \nrblade2.Reflectance = .5 \nrbm2 = Instance.new(\"BlockMesh\") \nrbm2.Parent = rblade2 \nrbm2.Scale = Vector3.new(.21,1,.31) \nrbw2 = Instance.new(\"Weld\") \nrbw2.Parent = rblade \nrbw2.Part0 = rblade \nrbw2.Part1 = rblade2 \nlblade2 = Instance.new(\"Part\") \nlblade2.BrickColor = rblade.BrickColor \nlblade2.Parent = player \nlblade2.CanCollide = false \nlblade2.Size = Vector3.new(1,6,1) \nlblade2.CFrame = lblade.CFrame \nlblade2.formFactor = \"Symmetric\" \nlblade2.TopSurface = 0 \nlblade2.BottomSurface = 0 \nlblade2.Reflectance = .5 \nlbm2 = Instance.new(\"BlockMesh\") \nlbm2.Parent = lblade2 \nlbm2.Scale = Vector3.new(.21,1,.31) \nlbw2 = Instance.new(\"Weld\") \nlbw2.Parent = lblade \nlbw2.Part0 = lblade \nlbw2.Part1 = lblade2 \nrblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - 10 \nend \nend \nend) \nlblade.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Health = hit.Parent.Humanoid.Health - 10 \nend \nend \nend) \n-- \nfor i = 1,40 do \nwait() \nlbw2.C1 = CFrame.new(0,0,0) * CFrame.Angles((math.pi*.1*i),0,0) \nrbw2.C1 = CFrame.new(0,0,0) * CFrame.Angles((math.pi*.1*i),0,0) \nend \nright.C1 = CFrame.new(-1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nlblade2:remove() \nrblade2:remove() \nend \nif key == \"j\" then \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.00,-.5,.5)*CFrame.Angles((math.pi*-.5),(math.pi*-.5),(math.pi*-.00)) \nleft.C1 = CFrame.new(1.00,-.5,.5)*CFrame.Angles((math.pi*-.5),(math.pi*.5),(math.pi*.00)) \nwait() \n-- \nrblade2 = Instance.new(\"Part\") \nrblade2.BrickColor = BrickColor.new(\"Really black\") \nrblade2.Parent = player \nrblade2.CanCollide = false \nrblade2.Size = Vector3.new(2,6,3) \nrblade2.CFrame = rblade.CFrame \nrblade2.formFactor = \"Symmetric\" \nrblade2.TopSurface = 0 \nrblade2.BottomSurface = 0 \nrblade2.Reflectance = .5 \nrbm2 = Instance.new(\"BlockMesh\") \nrbm2.Parent = rblade2 \nrbm2.Scale = Vector3.new(.11,1,.11) \nrbw2 = Instance.new(\"Weld\") \nrbw2.Parent = rblade \nrbw2.Part0 = rblade \nrbw2.Part1 = rblade2 \nlblade2 = Instance.new(\"Part\") \nlblade2.BrickColor = rblade.BrickColor \nlblade2.Parent = player \nlblade2.CanCollide = false \nlblade2.Size = Vector3.new(2,6,3) \nlblade2.CFrame = lblade.CFrame \nlblade2.formFactor = \"Symmetric\" \nlblade2.TopSurface = 0 \nlblade2.BottomSurface = 0 \nlblade2.Reflectance = .5 \nlbm2 = Instance.new(\"BlockMesh\") \nlbm2.Parent = lblade2 \nlbm2.Scale = Vector3.new(.11,1,.11) \nlbw2 = Instance.new(\"Weld\") \nlbw2.Parent = lblade \nlbw2.Part0 = lblade \nlbw2.Part1 = lblade2 \nrblade2.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Sit = true \nlocal a = hit.Parent:GetChildren() \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" then \na.Velocity = CFrame.new(rblade2.Position, hit.Position).lookVector * 250 \nend \nend \nend \nend \nend) \nlblade2.Touched:connect(function(hit) \nif hit.Parent:findFirstChild(\"Humanoid\") ~= nil then \nif hit.Parent.Name ~= player.Name then \nhit.Parent.Humanoid.Sit = true \nlocal a = hit.Parent:GetChildren() \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" then \na.Velocity = CFrame.new(lblade2.Position, hit.Position).lookVector * 250 \nend \nend \nend \nend \nend) \n-- \nfor i = 1,40 do \nwait() \nlbw2.C1 = CFrame.new(0,0,0) * CFrame.Angles((math.pi*.1*i),0,0) \nrbw2.C1 = CFrame.new(0,0,0) * CFrame.Angles((math.pi*.1*i),0,0) \nend \nright.C1 = CFrame.new(-1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*-.05)) \nleft.C1 = CFrame.new(1.11,-.4,.4)*CFrame.Angles((math.pi*-.4),(math.pi*.4),(math.pi*.05)) \nwait() \nright.C1 = CFrame.new(-1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*-.1)) \nleft.C1 = CFrame.new(1.22,-.3,.3)*CFrame.Angles((math.pi*-.3),(math.pi*.3),(math.pi*.1)) \nwait() \nright.C1 = CFrame.new(-1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*-.15)) \nleft.C1 = CFrame.new(1.33,.2,.2)*CFrame.Angles((math.pi*-.2),(math.pi*.2),(math.pi*.15)) \nwait() \nright.C1 = CFrame.new(-1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*-.2)) \nleft.C1 = CFrame.new(1.44,.1,.1)*CFrame.Angles((math.pi*-.1),(math.pi*.1),(math.pi*.2)) \nwait() \nright.C1 = CFrame.new(-1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.0,0)*CFrame.Angles((math.pi*-.0),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nlblade2:remove() \nrblade2:remove() \nend \nif key == \"y\" then \nlocal blast = Instance.new(\"Part\") \nblast.formFactor = \"Symmetric\" \nblast.Shape = \"Ball\" \nblast.Size = Vector3.new(1,1,1) \nblast.BrickColor = rblade.BrickColor \nblast.Parent = Workspace \nblast.CFrame = player.Torso.CFrame \ngame:GetService(\"Debris\"):AddItem(blast, 15) \nlocal smoke = Instance.new(\"Smoke\") \nsmoke.Color = Color3.new(0,0,0) \nsmoke.Opacity = 1 \nsmoke.RiseVelocity = 0 \nsmoke.Size = 100 \nsmoke.Parent = blast \nend \nif key == \"u\" then \nlocal blast = Instance.new(\"Part\") \nblast.formFactor = \"Symmetric\" \nblast.Shape = \"Ball\" \nblast.Name = \"keel\" \nblast.Size = Vector3.new(1,1,1) \nblast.BrickColor = rblade.BrickColor \nblast.Parent = Workspace \nblast.CFrame = player.Torso.CFrame \ngame:GetService(\"Debris\"):AddItem(blast, 15) \nwait(2) \nlocal smoke = Instance.new(\"Smoke\") \nsmoke.Color = Color3.new(1,1,1) \nsmoke.Opacity = .5 \nsmoke.RiseVelocity = 0 \nsmoke.Size = 20 \nsmoke.Parent = blast \ncoroutine.resume(coroutine.create(function() stun(blast) end)) \nend \nif key == \"n\" then \nplayer.Humanoid.WalkSpeed = player.Humanoid.WalkSpeed + 8 \nend \nif key == \"m\" then \nplayer.Humanoid.WalkSpeed = player.Humanoid.WalkSpeed - 8 \nend \nif key == \";\" then \nlocal l = player:findFirstChild(\"Left Arm\") \nlocal r = player:findFirstChild(\"Right Arm\") \nrblade.Size = Vector3.new(2, 6 , 2) \nlblade.Size = Vector3.new(2, 6 , 2) \nlocal w = Instance.new(\"Weld\") \nw.Part1 = rblade \nw.Part0 = r \nw.Parent = r \nlocal w = Instance.new(\"Weld\") \nw.Part1 = lblade \nw.Part0 = l \nw.Parent = l \nend \nif key == \"k\" then \nfor i = 1,100 do \nwait() \nlocal p = Instance.new(\"Part\") \np.BrickColor = BrickColor.new(\"Royal purple\") \np.Name =\"check\" \np.Parent = Workspace \np.CanCollide = false \np.Size = Vector3.new(1,3,1) \np.CFrame = player.Torso.CFrame + Vector3.new(math.random(-5,5),math.random(-2,4),math.random(-5,5)) \np.formFactor = \"Symmetric\" \np.TopSurface = 0 \np.BottomSurface = 0 \np.Transparency = .5 \nlocal pm = Instance.new(\"SpecialMesh\") \npm.Parent = p \npm.MeshType = \"Sphere\" \npm.Scale = Vector3.new(.2,.2,.2) \nlocal pbv = Instance.new(\"BodyVelocity\") \npbv.Parent = p \npbv.velocity = Vector3.new(0,10,0) \ngame:GetService(\"Debris\"):AddItem(p, .2) \nplayer.Humanoid.Health = player.Humanoid.Health +2 \nend \nend \n--glider? \nif key == \"p\" then \n-- \nrblade2 = Instance.new(\"Part\") \nrblade2.BrickColor = BrickColor.new(\"Institutional white\") \nrblade2.Parent = player \nrblade2.CanCollide = false \nrblade2.Size = Vector3.new(1,6,1) \nrblade2.CFrame = rblade.CFrame \nrblade2.formFactor = \"Symmetric\" \nrblade2.TopSurface = 0 \nrblade2.BottomSurface = 0 \nrblade2.Reflectance = 0 \nrbm2 = Instance.new(\"BlockMesh\") \nrbm2.Parent = rblade2 \nrbm2.Scale = Vector3.new(2,1,.31) \nrbw2 = Instance.new(\"Weld\") \nrbw2.Parent = rblade \nrbw2.Part0 = rblade \nrbw2.Part1 = rblade2 \nlblade2 = Instance.new(\"Part\") \nlblade2.BrickColor = rblade.BrickColor \nlblade2.Parent = player \nlblade2.CanCollide = false \nlblade2.Size = Vector3.new(1,6,1) \nlblade2.CFrame = lblade.CFrame \nlblade2.formFactor = \"Symmetric\" \nlblade2.TopSurface = 0 \nlblade2.BottomSurface = 0 \nlblade2.Reflectance = 0 \nlbm2 = Instance.new(\"BlockMesh\") \nlbm2.Parent = lblade2 \nlbm2.Scale = Vector3.new(2,1,.31) \nlbw2 = Instance.new(\"Weld\") \nlbw2.Parent = lblade \nlbw2.Part0 = lblade \nlbw2.Part1 = lblade2 \nlocal steer = Instance.new(\"Part\") \nsteer.Transparency = 1 \nsteer.Parent = player.Head \nsteerw= Instance.new(\"Weld\") \nsteerw.Part0 = player.Head \nsteerw.Part1 = steer \nsteerw.Parent = player.Head \nsteerw.C1 = CFrame.new(0,0,0)*CFrame.Angles((math.pi*-.5),0,0) \n-- \nright.C1 = CFrame.new(-.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(.55,.4,0)*CFrame.Angles(0,0,.5) \nwait() \nplayer.Humanoid.PlatformStand = true \nglideg.Parent = steer \nglideg.maxTorque = Vector3.new(math.huge,math.huge,math.huge) \nglidev.Parent = steer \nglidev.maxForce = Vector3.new(math.huge,math.huge,math.huge) \nwhile player.Humanoid.PlatformStand == true do \nwait() \nglideg.cframe = CFrame.new(steer.Position, mouse.Hit.p) \nglidev.velocity = steer.CFrame.lookVector * 75 \nend \nglidev.velocity = steer.CFrame.lookVector * 15 \nwait(3) \nglideg:remove() \nglidev:remove() \nlblade2:remove() \nrblade2:remove() \nsteer:remove() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-1),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-1),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.9),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.8),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.7),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.6),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.5),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.4),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.3),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.2),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*-.25)) \nleft.C1 = CFrame.new(1.55,.5,0)*CFrame.Angles((math.pi*-.1),(math.pi*0),(math.pi*.25)) \nwait() \nright.C1 = CFrame.new(-1.55,.4,0)*CFrame.Angles(0,0,-.5) \nleft.C1 = CFrame.new(1.55,.4,0)*CFrame.Angles(0,0,.5) \nend \nif key == \";\" then \nglideg.Parent = nil \nglideg.maxTorque = Vector3.new(0,0,0) \nglidev.Parent = nil \nglidev.maxForce = Vector3.new(0,0,0) \nend \nif key == \"l\" then \nlocal a = player:GetChildren() \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nfor x = 1, 9 do \nwait() \na.Transparency = a.Transparency +.1 \nend \nelseif a.className == \"Hat\" then \nfor x = 1, 9 do \nwait() \na.Handle.Transparency = a.Handle.Transparency +.1 \nend \nend \nplayer.Head.Transparency = 1 \nend \nwait(10) \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nfor x = 1, 9 do \nwait() \na.Transparency = a.Transparency -.1 \nend \nelseif a.className == \"Hat\" then \nfor x = 1, 9 do \nwait() \na.Handle.Transparency = a.Handle.Transparency -.1 \nend \nend \nend \nfor i = 1,#a do \nwait() \nif a.className == \"Part\" and a.Name ~= \"check\" and a.Name ~= \"checkb\" then \nwait() \na.Transparency = 0 \nelseif a.className == \"Hat\" then \nwait() \na.Handle.Transparency = 0 \nend \nend \nend \nend) \n----end of keys \nend) \n----end of tool \nbin.Deselected:connect(function() \nrblade:remove() \nlblade:remove() \non = 2 \ncoroutine.yield(function() shadow(rblade,lblade) end) \nls.Part1 = larm \nrs.Part1 = rarm \nleft:remove() \nright:remove() \nend)",
 "title": ""
}