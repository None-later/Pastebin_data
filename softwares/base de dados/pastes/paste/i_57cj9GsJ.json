{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en",
  "re_ast1",
  "kw_hack"
 ],
 "key": "57cj9GsJ",
 "pasteDate": "Feb 18, 2018, 2:55:47 PM",
 "relevancy": 2.0,
 "relevant": false,
 "text": "<?php\nnamespace Profimedia\\Caching;\n\nuse Nette;\nuse Nette\\Caching\\Storages\\IJournal;\nuse Nette\\Caching\\Cache;\n\n/**\n * Btree+ based file journal.\n *\n * @author     Jakub Onderka\n * @author\tRadek Dvok <radek.dvorak@profimedia.cz> Memcache hack\n */\nclass MemcachedJournal extends Nette\\Object implements IJournal\n{\n\t/** Filename with journal */\n\tconst FILE = 'btfj.dat';\n\n\t/** 4 bytes file header magic (btfj) */\n\tconst FILE_MAGIC  = 0x6274666A;\n\n\t/** 4 bytes index node magic (inde) */\n\tconst INDEX_MAGIC = 0x696E6465;\n\n\t/** 4 bytes data node magic (data) */\n\tconst DATA_MAGIC  = 0x64617461;\n\n\t/** Node size in bytes */\n\tconst NODE_SIZE = 4096;\n\n\t/** Bit rotation for saving data into nodes. BITROT = log2(NODE_SIZE) */\n\tconst BITROT = 12;\n\n\t/** Header size in bytes */\n\tconst HEADER_SIZE = 4096;\n\n\t/** Size of 32 bit integer in bytes. INT32_SIZE = 32 / 8 :-) */\n\tconst INT32_SIZE  = 4;\n\n\t/** Use json_decode and json_encode instead of unserialize and serialize (JSON is smaller and mostly faster) */\n\tconst USE_JSON = FALSE;\n\n\tconst INFO = 'i',\n\t\tTYPE = 't', // TAGS, PRIORITY or DATA\n\t\tIS_LEAF = 'il', // TRUE or FALSE\n\t\tPREV_NODE = 'p', // Prev node id\n\t\tEND = 'e',\n\t\tMAX = 'm', // Maximal key in node or -1 when is last node\n\t\tINDEX_DATA = 'id',\n\t\tLAST_INDEX = 'l';\n\n\t// Indexes\n\tconst TAGS = 't',\n\t\tPRIORITY = 'p',\n\t\tENTRIES = 'e';\n\n\tconst DATA = 'd',\n\t\tKEY = 'k', // string\n\t\tDELETED = 'd'; // TRUE or FALSE\n\n\t/** Debug mode, only for testing purposes */\n\tpublic static $debug = FALSE;\n\n\t/** @var string */\n\tprivate $file;\n\n\t/** @var resource */\n\tprivate $handle;\n\n\t/** @var int Last complete free node */\n\tprivate $lastNode = 2;\n\n\t/** @var int Last modification time of journal file */\n\tprivate $lastModTime = NULL;\n\n\t/** @var array Cache and uncommited but changed nodes */\n\tprivate $nodeCache = array();\n\n\t/** @var array */\n\tprivate $nodeChanged = array();\n\n\t/** @var array */\n\tprivate $toCommit = array();\n\n\t/** @var array */\n\tprivate $deletedLinks = array();\n\n\t/** @var array Free space in data nodes */\n\tprivate $dataNodeFreeSpace = array();\n\n\t/** @var array */\n\tprivate static $startNode = array(\n\t\tself::TAGS     => 0,\n\t\tself::PRIORITY => 1,\n\t\tself::ENTRIES  => 2,\n\t\tself::DATA     => 3,\n\t);\n\n\tprotected $memcache;\n\tprotected $lock;\n\n\t/**\n\t * @param  string  Directory location with journal file\n\t * @return void\n\t */\n\tpublic function __construct($dir, \\Memcached $memcache)\n\t{\n\t\t$this->file = $dir . '/' . self::FILE;\n\t\t$this->memcache = $memcache;\n\t\t$this->lock = new \\PM\\Cache\\Memcache\\Lock($this->memcache);\n\n\t\t$this->memcache->add($this->file, pack('N2', self::FILE_MAGIC, $this->lastNode));\n\n\t\t$this->handle = $this->openFile($this->file, \"r+b\");\n\n\t\tif (!$this->handle) {\n\t\t\tthrow new \\InvalidStateException(\"Cannot open journal file '$this->file'.\");\n\t\t}\n\t\t$header = stream_get_contents($this->handle, 2 * self::INT32_SIZE, 0);\n\n\t\tlist(, $fileMagic, $this->lastNode) = unpack('N2', $header);\n\n\t\tfclose($this->handle);\n\t\tif ($fileMagic !== self::FILE_MAGIC) {\n\t\t\tthrow new \\InvalidStateException(\"Malformed journal file '$this->file'.\");\n\t\t}\n\t}\n\n\n\n\t/**\n\t * @return void\n\t */\n\tpublic function __destruct()\n\t{\n\t}\n\n\n\n\t/**\n\t * Writes entry information into the journal.\n\t * @param  string\n\t * @param  array\n\t * @return void\n\t */\n\tpublic function write($key, array $dependencies)\n\t{\n\t\t$this->lock->acquireLock($this->file);\n\t\t$casToken = 0;\n\t\t$this->handle = $this->openFile($this->file, \"r+b\", $casToken);\n\n\t\t$this->_write($key, $dependencies);\n\n\t\t$this->headerCommit();\n\n\t\t$casStat = $this->memcache->cas($casToken, $this->file, stream_get_contents($this->handle, -1, 0));\n\t\tfclose($this->handle);\n\t\tif (false === $casStat)\n\t\t{\n\t\t\tthrow new \\InvalidStateException(\"Locking failed, journal data has been modified.\");\n\t\t}\n\n\t\t$this->lock->releaseLock($this->file);\n\t}\n\n\t/**\n\t * Writes entry information into the journal.\n\t * @param  string\n\t * @param  array\n\t * @return void\n\t */\n\tprotected function _write($key, array $dependencies)\n\t{\n\t\t$this->lock();\n\n\t\t$priority = !isset($dependencies[Cache::PRIORITY]) ? FALSE : (int) $dependencies[Cache::PRIORITY];\n\t\t$tags = empty($dependencies[Cache::TAGS]) ? FALSE : (array) $dependencies[Cache::TAGS];\n\n\t\t$exists = FALSE;\n\t\t$keyHash = crc32($key);\n\t\tlist($entriesNodeId, $entriesNode) = $this->findIndexNode(self::ENTRIES, $keyHash);\n\n\t\tif (isset($entriesNode[$keyHash])) {\n\t\t\t$entries = $this->mergeIndexData($entriesNode[$keyHash]);\n\t\t\tforeach ($entries as $link => $foo) {\n\t\t\t\t$dataNode = $this->getNode($link >> self::BITROT);\n\t\t\t\tif ($dataNode[$link][self::KEY] === $key) {\n\t\t\t\t\tif ($dataNode[$link][self::TAGS] == $tags && $dataNode[$link][self::PRIORITY] === $priority)  { // intentionally ==, the order of tags does not matter\n\t\t\t\t\t\tif ($dataNode[$link][self::DELETED]) {\n\t\t\t\t\t\t\t$dataNode[$link][self::DELETED] = FALSE;\n\t\t\t\t\t\t\t$this->saveNode($link >> self::BITROT, $dataNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$exists = TRUE;\n\t\t\t\t\t} else { // Alredy exists, but with other tags or priority\n\t\t\t\t\t\t$toDelete = array();\n\t\t\t\t\t\tforeach ($dataNode[$link][self::TAGS] as $tag) {\n\t\t\t\t\t\t\t$toDelete[self::TAGS][$tag][$link] = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($dataNode[$link][self::PRIORITY] !== FALSE) {\n\t\t\t\t\t\t\t$toDelete[self::PRIORITY][$dataNode[$link][self::PRIORITY]][$link] = TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$toDelete[self::ENTRIES][$keyHash][$link] = TRUE;\n\t\t\t\t\t\t$this->cleanFromIndex($toDelete);\n\t\t\t\t\t\tunset($dataNode[$link]);\n\t\t\t\t\t\t$this->saveNode($link >> self::BITROT, $dataNode);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($exists === FALSE) {\n\t\t\t// Magical constants\n\t\t\tif (self::USE_JSON) {\n\t\t\t\t$requiredSize = strlen($key) + 45 + substr_count($key, '/');\n\t\t\t\tif ($tags) {\n\t\t\t\t\tforeach ($tags as $tag) {\n\t\t\t\t\t\t$requiredSize += strlen($tag) + 3 + substr_count($tag, '/');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$requiredSize += $priority ? strlen($priority) : 5;\n\t\t\t} else {\n\t\t\t\t$requiredSize = strlen($key) + 75;\n\t\t\t\tif ($tags) {\n\t\t\t\t\tforeach ($tags as $tag) {\n\t\t\t\t\t\t$requiredSize += strlen($tag) + 13;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$requiredSize += $priority ? 10 : 1;\n\t\t\t}\n\n\t\t\t$freeDataNode = $this->findFreeDataNode($requiredSize);\n\t\t\t$data = $this->getNode($freeDataNode);\n\n\t\t\tif ($data === FALSE) {\n\t\t\t\t$data = array(\n\t\t\t\t\tself::INFO => array(\n\t\t\t\t\t\tself::LAST_INDEX => ($freeDataNode << self::BITROT),\n\t\t\t\t\t\tself::TYPE => self::DATA,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t$dataNodeKey = ++$data[self::INFO][self::LAST_INDEX];\n\t\t\t$data[$dataNodeKey] = array(\n\t\t\t\tself::KEY => $key,\n\t\t\t\tself::TAGS => $tags ? $tags : array(),\n\t\t\t\tself::PRIORITY => $priority,\n\t\t\t\tself::DELETED => FALSE,\n\t\t\t);\n\n\t\t\t$this->saveNode($freeDataNode, $data);\n\n\t\t\t// Save to entries tree, ...\n\t\t\t$entriesNode[$keyHash][$dataNodeKey] = 1;\n\t\t\t$this->saveNode($entriesNodeId, $entriesNode);\n\n\t\t\t// ...tags tree...\n\t\t\tif ($tags) {\n\t\t\t\tforeach ($tags as $tag) {\n\t\t\t\t\tlist($nodeId, $node) = $this->findIndexNode(self::TAGS, $tag);\n\t\t\t\t\t$node[$tag][$dataNodeKey] = 1;\n\t\t\t\t\t$this->saveNode($nodeId, $node);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ...and priority tree.\n\t\t\tif ($priority) {\n\t\t\t\tlist($nodeId, $node) = $this->findIndexNode(self::PRIORITY, $priority);\n\t\t\t\t$node[$priority][$dataNodeKey] = 1;\n\t\t\t\t$this->saveNode($nodeId, $node);\n\t\t\t}\n\t\t}\n\n\t\t$this->commit();\n\t\t$this->unlock();\n\t}\n\n\n\n\t/**\n\t * Cleans entries from journal.\n\t * @param  array\n\t * @return array of removed items or NULL when performing a full cleanup\n\t */\n\tpublic function clean(array $conditions)\n\t{\n\t\t$this->lock->acquireLock($this->file);\n\t\t$casToken = 0;\n\t\t$this->handle = $this->openFile($this->file, \"r+b\", $casToken);\n\n\t\t$entries = $this->_clean($conditions);\n\n\t\t$this->headerCommit();\n\n\t\tfseek($this->handle, 0);\n\t\t$casStat = $this->memcache->cas($casToken, $this->file, stream_get_contents($this->handle));\n\t\tfclose($this->handle);\n\t\tif (false === $casStat)\n\t\t{\n\t\t\tthrow new \\InvalidStateException(\"Locking failed, journal data modified.\");\n\t\t}\n\n\t\t$this->lock->releaseLock($this->file);\n\t\treturn $entries;\n\t}\n\n\t/**\n\t * Cleans entries from journal.\n\t * @param  array\n\t * @return array of removed items or NULL when performing a full cleanup\n\t */\n\tprotected function _clean(array $conditions)\n\t{\n\t\t$this->lock();\n\n\t\tif (!empty($conditions[Cache::ALL])) {\n\t\t\t$this->nodeCache = $this->nodeChanged = $this->dataNodeFreeSpace = array();\n\t\t\t$this->deleteAll();\n\t\t\t$this->unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t$toDelete = array(\n\t\t\tself::TAGS => array(),\n\t\t\tself::PRIORITY => array(),\n\t\t\tself::ENTRIES => array()\n\t\t);\n\n\t\t$entries = array();\n\n\t\tif (!empty($conditions[Cache::TAGS])) {\n\t\t\t$entries = $this->cleanTags((array) $conditions[Cache::TAGS], $toDelete);\n\t\t}\n\n\t\tif (isset($conditions[Cache::PRIORITY])) {\n\t\t\t$this->arrayAppend($entries, $this->cleanPriority((int) $conditions[Cache::PRIORITY], $toDelete));\n\t\t}\n\n\t\t$this->deletedLinks = array();\n\t\t$this->cleanFromIndex($toDelete);\n\n\t\t$this->commit();\n\t\t$this->unlock();\n\n\t\treturn $entries;\n\t}\n\n\n\n\t/**\n\t * Cleans entries from journal by tags.\n\t * @param  array\n\t * @return array of removed items\n\t */\n\tprivate function cleanTags(array $tags, array &$toDelete)\n\t{\n\t\t$entries = array();\n\n\t\tforeach ($tags as $tag) {\n\t\t\tlist($nodeId, $node) = $this->findIndexNode(self::TAGS, $tag);\n\n\t\t\tif (isset($node[$tag])) {\n\t\t\t\t$ent = $this->cleanLinks($this->mergeIndexData($node[$tag]), $toDelete);\n\t\t\t\t$this->arrayAppend($entries, $ent);\n\t\t\t}\n\t\t}\n\n\t\treturn $entries;\n\t}\n\n\n\n\t/**\n\t * Cleans entries from journal by priority.\n\t * @param  integer\n\t * @param  array\n\t * @return array of removed items\n\t */\n\tprivate function cleanPriority($priority, array &$toDelete)\n\t{\n\t\tlist($nodeId, $node) = $this->findIndexNode(self::PRIORITY, $priority);\n\n\t\tksort($node);\n\n\t\t$allData = array();\n\n\t\tforeach ($node as $prior => $data) {\n\t\t\tif ($prior === self::INFO) {\n\t\t\t\tcontinue;\n\t\t\t} elseif ($prior > $priority) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$this->arrayAppendKeys($allData, $this->mergeIndexData($data));\n\t\t}\n\n\t\t$nodeInfo = $node[self::INFO];\n\t\twhile ($nodeInfo[self::PREV_NODE] !== -1) {\n\t\t\t$nodeId = $nodeInfo[self::PREV_NODE];\n\t\t\t$node = $this->getNode($nodeId);\n\n\t\t\tif ($node === FALSE) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $nodeId.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$nodeInfo = $node[self::INFO];\n\t\t\tunset($node[self::INFO]);\n\n\t\t\tforeach ($node as $prior => $data) {\n\t\t\t\t$this->arrayAppendKeys($allData, $this->mergeIndexData($data));\n\t\t\t}\n\t\t}\n\n\t\treturn $this->cleanLinks($allData, $toDelete);\n\t}\n\n\n\n\t/**\n\t * Cleans links from $data.\n\t * @param  array\n\t * @param  array\n\t * @return array of removed items\n\t */\n\tprivate function cleanLinks(array $data, array &$toDelete)\n\t{\n\t\t$return = array();\n\n\t\t$data = array_keys($data);\n\t\tsort($data);\n\t\t$max = count($data);\n\t\t$data[] = 0;\n\t\t$i = 0;\n\n\t\twhile ($i < $max) {\n\t\t\t$searchLink = $data[$i];\n\n\t\t\tif (isset($this->deletedLinks[$searchLink])) {\n\t\t\t\t++$i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$nodeId = $searchLink >> self::BITROT;\n\t\t\t$node = $this->getNode($nodeId);\n\n\t\t\tif ($node === FALSE) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException('Cannot load node number ' . ($nodeId) . '.');\n\t\t\t\t++$i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\t$link = $data[$i];\n\n\t\t\t\tif (!isset($node[$link])){\n\t\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Link with ID $searchLink is not in node \". ($nodeId) . '.');\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif (isset($this->deletedLinks[$link])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$nodeLink = &$node[$link];\n\t\t\t\tif (!$nodeLink[self::DELETED]) {\n\t\t\t\t\t$nodeLink[self::DELETED] = TRUE;\n\t\t\t\t\t$return[] = $nodeLink[self::KEY];\n\t\t\t\t} else {\n\t\t\t\t\tforeach ($nodeLink[self::TAGS] as $tag) {\n\t\t\t\t\t\t$toDelete[self::TAGS][$tag][$link] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tif ($nodeLink[self::PRIORITY] !== FALSE) {\n\t\t\t\t\t\t$toDelete[self::PRIORITY][$nodeLink[self::PRIORITY]][$link] = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\t$toDelete[self::ENTRIES][crc32($nodeLink[self::KEY])][$link] = TRUE;\n\t\t\t\t\tunset($node[$link]);\n\t\t\t\t\t$this->deletedLinks[$link] = TRUE;\n\t\t\t\t}\n\t\t\t} while (($data[++$i] >> self::BITROT) === $nodeId);\n\n\t\t\t$this->saveNode($nodeId, $node);\n\t\t}\n\n\t\treturn $return;\n\t}\n\n\n\n\t/**\n\t * Remove links to deleted keys from index.\n\t * @param  array\n\t */\n\tprivate function cleanFromIndex(array $toDeleteFromIndex)\n\t{\n\t\tforeach ($toDeleteFromIndex as $type => $toDelete) {\n\t\t\tksort($toDelete);\n\n\t\t\twhile (!empty($toDelete)) {\n\t\t\t\treset($toDelete);\n\t\t\t\t$searchKey = key($toDelete);\n\t\t\t\tlist($masterNodeId, $masterNode) = $this->findIndexNode($type, $searchKey);\n\n\t\t\t\tif (!isset($masterNode[$searchKey])) {\n\t\t\t\t\tif (self::$debug) throw new \\InvalidStateException('Bad index.');\n\t\t\t\t\tunset($toDelete[$searchKey]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach ($toDelete as $key => $links) {\n\t\t\t\t\tif (isset($masterNode[$key])) {\n\t\t\t\t\t\tforeach ($links as $link => $foo) {\n\t\t\t\t\t\t\tif (isset($masterNode[$key][$link])) {\n\t\t\t\t\t\t\t\tunset($masterNode[$key][$link], $links[$link]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!empty($links) && isset($masterNode[$key][self::INDEX_DATA])) {\n\t\t\t\t\t\t\t$this->cleanIndexData($masterNode[$key][self::INDEX_DATA], $links, $masterNode[$key]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (empty($masterNode[$key])) {\n\t\t\t\t\t\t\tunset($masterNode[$key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunset($toDelete[$key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->saveNode($masterNodeId, $masterNode);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Merge data with index data in other nodes.\n\t * @param  array\n\t * @return array of merged items\n\t */\n\tprivate function mergeIndexData(array $data)\n\t{\n\t\twhile (isset($data[self::INDEX_DATA])) {\n\t\t\t$id = $data[self::INDEX_DATA];\n\t\t\tunset($data[self::INDEX_DATA]);\n\t\t\t$childNode = $this->getNode($id);\n\n\t\t\tif ($childNode === FALSE) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $id.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$this->arrayAppendKeys($data, $childNode[self::INDEX_DATA]);\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\n\n\t/**\n\t * Cleans links from other nodes.\n\t * @param  int\n\t * @param  array\n\t * @param  array\n\t * @return void\n\t */\n\tprivate function cleanIndexData($nextNodeId, array $links, &$masterNodeLink)\n\t{\n\t\t$prev = -1;\n\n\t\twhile ($nextNodeId && !empty($links)) {\n\t\t\t$nodeId = $nextNodeId;\n\t\t\t$node = $this->getNode($nodeId);\n\n\t\t\tif ($node === FALSE) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $nodeId.\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tforeach ($links as $link => $foo) {\n\t\t\t\tif (isset($node[self::INDEX_DATA][$link])) {\n\t\t\t\t\tunset($node[self::INDEX_DATA][$link], $links[$link]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isset($node[self::INDEX_DATA][self::INDEX_DATA])) {\n\t\t\t\t$nextNodeId = $node[self::INDEX_DATA][self::INDEX_DATA];\n\t\t\t} else {\n\t\t\t\t$nextNodeId = FALSE;\n\t\t\t}\n\n\t\t\tif (empty($node[self::INDEX_DATA]) || (count($node[self::INDEX_DATA]) === 1 && $nextNodeId)) {\n\t\t\t\tif ($prev === -1) {\n\t\t\t\t\tif ($nextNodeId === FALSE) {\n\t\t\t\t\t\tunset($masterNodeLink[self::INDEX_DATA]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$masterNodeLink[self::INDEX_DATA] = $nextNodeId;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$prevNode = $this->getNode($prev);\n\t\t\t\t\tif ($prevNode === FALSE) {\n\t\t\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $prev.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ($nextNodeId === FALSE) {\n\t\t\t\t\t\t\tunset($prevNode[self::INDEX_DATA][self::INDEX_DATA]);\n\t\t\t\t\t\t\tif (empty($prevNode[self::INDEX_DATA])) {\n\t\t\t\t\t\t\t\tunset($prevNode[self::INDEX_DATA]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$prevNode[self::INDEX_DATA][self::INDEX_DATA] = $nextNodeId;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$this->saveNode($prev, $prevNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunset($node[self::INDEX_DATA]);\n\t\t\t} else {\n\t\t\t\t$prev = $nodeId;\n\t\t\t}\n\n\t\t\t$this->saveNode($nodeId, $node);\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Get node from journal.\n\t * @param  integer\n\t * @return array\n\t */\n\tprivate function getNode($id)\n\t{\n\t\t// Load from cache\n\t\tif (isset($this->nodeCache[$id])) {\n\t\t\treturn $this->nodeCache[$id];\n\t\t}\n\n\t\t$binary = stream_get_contents($this->handle, self::NODE_SIZE, self::HEADER_SIZE + self::NODE_SIZE * $id);\n\n\t\tif (empty($binary)) {\n\t\t\t// empty node, no Exception\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tlist(, $magic, $lenght) = unpack('N2', $binary);\n\t\tif ($magic !== self::INDEX_MAGIC && $magic !== self::DATA_MAGIC) {\n\t\t\tif (!empty($magic)) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Node $id has malformed header.\");\n\t\t\t\t$this->deleteNode($id);\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t$data = substr($binary, 2 * self::INT32_SIZE, $lenght - 2 * self::INT32_SIZE);\n\n\t\tif (self::USE_JSON) {\n\t\t\t$node = @json_decode($data, TRUE); // intentionally @\n\t\t} else {\n\t\t\t$node = @unserialize($data); // intentionally @\n\t\t}\n\n\t\tif ($node === FALSE) {\n\t\t\t$this->deleteNode($id);\n\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot deserialize node number $id.\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t// Save to cache and return\n\t\treturn $this->nodeCache[$id] = $node;\n\t}\n\n\n\n\t/**\n\t * Save node to cache.\n\t * @param  integer\n\t * @param  array\n\t * @return void\n\t */\n\tprivate function saveNode($id, array $node)\n\t{\n\t\tif (count($node) === 1) { // Nod contains only INFO\n\t\t\t$nodeInfo = $node[self::INFO];\n\t\t\tif ($nodeInfo[self::TYPE] !== self::DATA) {\n\n\t\t\t\tif ($nodeInfo[self::END] !== -1) {\n\t\t\t\t\t$this->nodeCache[$id] = $node;\n\t\t\t\t\t$this->nodeChanged[$id] = TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ($nodeInfo[self::MAX] === -1) {\n\t\t\t\t\t$max = PHP_INT_MAX;\n\t\t\t\t} else {\n\t\t\t\t\t$max = $nodeInfo[self::MAX];\n\t\t\t\t}\n\n\t\t\t\tlist(, , $parentId) = $this->findIndexNode($nodeInfo[self::TYPE], $max, $id);\n\t\t\t\tif ($parentId !== -1 && $parentId !== $id) {\n\t\t\t\t\t$parentNode = $this->getNode($parentId);\n\t\t\t\t\tif ($parentNode === FALSE) {\n\t\t\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $parentId.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ($parentNode[self::INFO][self::END] === $id) {\n\t\t\t\t\t\t\tif (count($parentNode) === 1) {\n\t\t\t\t\t\t\t\t$parentNode[self::INFO][self::END] = -1;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tend($parentNode);\n\t\t\t\t\t\t\t\t$lastKey = key($parentNode);\n\t\t\t\t\t\t\t\t$parentNode[self::INFO][self::END] = $parentNode[$lastKey];\n\t\t\t\t\t\t\t\tunset($parentNode[$lastKey]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunset($parentNode[$nodeInfo[self::MAX]]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$this->saveNode($parentId, $parentNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ($nodeInfo[self::TYPE] === self::PRIORITY) { // only priority tree has link to prevNode\n\t\t\t\t\tif ($nodeInfo[self::MAX] === -1) {\n\t\t\t\t\t\tif ($nodeInfo[self::PREV_NODE] !== -1) {\n\t\t\t\t\t\t\t$prevNode = $this->getNode($nodeInfo[self::PREV_NODE]);\n\t\t\t\t\t\t\tif ($prevNode === FALSE) {\n\t\t\t\t\t\t\t\tif (self::$debug) throw new \\InvalidStateException('Cannot load node number ' . $nodeInfo[self::PREV_NODE] . '.');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$prevNode[self::INFO][self::MAX] = -1;\n\t\t\t\t\t\t\t\t$this->saveNode($nodeInfo[self::PREV_NODE], $prevNode);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist($nextId, $nextNode) = $this->findIndexNode($nodeInfo[self::TYPE], $nodeInfo[self::MAX] + 1, NULL, $id);\n\t\t\t\t\t\tif ($nextId !== -1 && $nextId !== $id) {\n\t\t\t\t\t\t\t$nextNode[self::INFO][self::PREV_NODE] = $nodeInfo[self::PREV_NODE];\n\t\t\t\t\t\t\t$this->saveNode($nextId, $nextNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$this->nodeCache[$id] = FALSE;\n\t\t} else {\n\t\t\t$this->nodeCache[$id] = $node;\n\t\t}\n\t\t$this->nodeChanged[$id] = TRUE;\n\t}\n\n\n\n\t/**\n\t * Commit all changed nodes from cache to journal file.\n\t * @return void\n\t */\n\tprivate function commit()\n\t{\n\t\tdo {\n\t\t\tforeach ($this->nodeChanged as $id => $foo) {\n\t\t\t\tif ($this->prepareNode($id, $this->nodeCache[$id])) {\n\t\t\t\t\tunset($this->nodeChanged[$id]);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!empty($this->nodeChanged));\n\n\t\tforeach ($this->toCommit as $node => $str) {\n\t\t\t$this->commitNode($node, $str);\n\t\t}\n\t\t$this->toCommit = array();\n\t}\n\n\n\n\t/**\n\t * Prepare node to journal file structure.\n\t * @param  integer\n\t * @param  array|bool\n\t * @return bool Sucessfully commited\n\t */\n\tprivate function prepareNode($id, $node)\n\t{\n\t\tif ($node === FALSE) {\n\t\t\tif ($id < $this->lastNode) {\n\t\t\t\t$this->lastNode = $id;\n\t\t\t}\n\t\t\tunset($this->nodeCache[$id]);\n\t\t\tunset($this->dataNodeFreeSpace[$id]);\n\t\t\t$this->deleteNode($id);\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tif (self::USE_JSON) {\n\t\t\t$data = json_encode($node);\n\t\t} else {\n\t\t\t$data = serialize($node);\n\t\t}\n\n\t\t$dataSize = strlen($data) + 2 * self::INT32_SIZE;\n\n\t\t$isData = $node[self::INFO][self::TYPE] === self::DATA;\n\t\tif ($dataSize > self::NODE_SIZE) {\n\t\t\tif ($isData) {\n\t\t\t\tthrow new \\InvalidStateException('Saving node is bigger than maximum node size.');\n\t\t\t} else {\n\t\t\t\t$this->bisectNode($id, $node);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n\t\t$this->toCommit[$id] = pack('N2', $isData ? self::DATA_MAGIC : self::INDEX_MAGIC, $dataSize) . $data;\n\n\t\tif ($this->lastNode < $id) {\n\t\t\t$this->lastNode = $id;\n\t\t}\n\t\tif ($isData) {\n\t\t\t$this->dataNodeFreeSpace[$id] = self::NODE_SIZE - $dataSize;\n\t\t}\n\n\t\treturn TRUE;\n\t}\n\n\n\n\t/**\n\t * Commit node string to journal file.\n\t * @param  integer\n\t * @param  string\n\t * @return void\n\t */\n\tprivate function commitNode($id, $str)\n\t{\n\t\tfseek($this->handle, self::HEADER_SIZE + self::NODE_SIZE * $id);\n\t\t$writen = fwrite($this->handle, $str);\n\t\tif ($writen === FALSE) {\n\t\t\tthrow new \\InvalidStateException(\"Cannot write node number $id to journal.\");\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Find right node in B+tree. .\n\t * @param  string Tree type (TAGS, PRIORITY or ENTRIES)\n\t * @param  int    Searched item\n\t * @return array Node\n\t */\n\tprivate function findIndexNode($type, $search, $childId = NULL, $prevId = NULL)\n\t{\n\t\t$nodeId = self::$startNode[$type];\n\n\t\t$parentId = -1;\n\t\twhile (TRUE) {\n\t\t\t$node = $this->getNode($nodeId);\n\n\t\t\tif ($node === FALSE) {\n\t\t\t\treturn array(\n\t\t\t\t\t$nodeId,\n\t\t\t\t\tarray(\n\t\t\t\t\t\tself::INFO => array(\n\t\t\t\t\t\t\tself::TYPE => $type,\n\t\t\t\t\t\t\tself::IS_LEAF => TRUE,\n\t\t\t\t\t\t\tself::PREV_NODE => -1,\n\t\t\t\t\t\t\tself::END => -1,\n\t\t\t\t\t\t\tself::MAX => -1,\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t$parentId,\n\t\t\t\t); // Init empty node\n\t\t\t}\n\n\t\t\tif ($node[self::INFO][self::IS_LEAF] || $nodeId === $childId || $node[self::INFO][self::PREV_NODE] === $prevId) {\n\t\t\t\treturn array($nodeId, $node, $parentId);\n\t\t\t}\n\n\t\t\t$parentId = $nodeId;\n\n\t\t\tif (isset($node[$search])) {\n\t\t\t\t$nodeId = $node[$search];\n\t\t\t} else {\n\t\t\t\tforeach ($node as $key => $childNode) {\n\t\t\t\t\tif ($key > $search and $key !== self::INFO) {\n\t\t\t\t\t\t$nodeId = $childNode;\n\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$nodeId = $node[self::INFO][self::END];\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Find complete free node.\n\t * @param  integer\n\t * @return array|integer Node ID\n\t */\n\tprivate function findFreeNode($count = 1)\n\t{\n\t\t$id = $this->lastNode;\n\t\t$nodesId = array();\n\n\t\tdo {\n\t\t\tif (isset($this->nodeCache[$id])) {\n\t\t\t\t++$id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$offset = self::HEADER_SIZE + self::NODE_SIZE * $id;\n\n\t\t\t$binary = stream_get_contents($this->handle, self::INT32_SIZE, $offset);\n\n\t\t\tif (empty($binary)) {\n\t\t\t\t$nodesId[] = $id;\n\t\t\t} else {\n\t\t\t\tlist(, $magic) = unpack('N', $binary);\n\t\t\t\tif ($magic !== self::INDEX_MAGIC && $magic !== self::DATA_MAGIC) {\n\t\t\t\t\t$nodesId[] = $from;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++$id;\n\t\t} while (count($nodesId) !== $count);\n\n\t\tif ($count === 1) {\n\t\t\treturn $nodesId[0];\n\t\t} else {\n\t\t\treturn $nodesId;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Find free data node that has $size bytes of free space.\n\t * @param  integer size in bytes\n\t * @return integer Node ID\n\t */\n\tprivate function findFreeDataNode($size)\n\t{\n\t\tforeach ($this->dataNodeFreeSpace as $id => $freeSpace) {\n\t\t\tif ($freeSpace > $size) {\n\t\t\t\treturn $id;\n\t\t\t}\n\t\t}\n\n\t\t$id = self::$startNode[self::DATA];\n\t\twhile (TRUE) {\n\t\t\tif (isset($this->dataNodeFreeSpace[$id]) || isset($this->nodeCache[$id])) {\n\t\t\t\t++$id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$offset = self::HEADER_SIZE + self::NODE_SIZE * $id;\n\t\t\t$binary = stream_get_contents($this->handle, 2 * self::INT32_SIZE, $offset);\n\n\t\t\tif (empty($binary)) {\n\t\t\t\t$this->dataNodeFreeSpace[$id] = self::NODE_SIZE;\n\t\t\t\treturn $id;\n\t\t\t}\n\n\t\t\tlist(, $magic, $nodeSize) = unpack('N2', $binary);\n\t\t\tif (empty($magic)) {\n\t\t\t\t$this->dataNodeFreeSpace[$id] = self::NODE_SIZE;\n\t\t\t\treturn $id;\n\t\t\t} elseif ($magic === self::DATA_MAGIC) {\n\t\t\t\t$freeSpace = self::NODE_SIZE - $nodeSize;\n\t\t\t\t$this->dataNodeFreeSpace[$id] = $freeSpace;\n\n\t\t\t\tif ($freeSpace > $size) {\n\t\t\t\t\treturn $id;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++$id;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Bisect node or when has only one key, move part to data node.\n\t * @param  integer Node ID\n\t * @param  array Node\n\t * @return void\n\t */\n\tprivate function bisectNode($id, array $node)\n\t{\n\t\t$nodeInfo = $node[self::INFO];\n\t\tunset($node[self::INFO]);\n\n\t\tif (count($node) === 1) {\n\t\t\t$key = key($node);\n\n\t\t\t$dataId = $this->findFreeDataNode(self::NODE_SIZE);\n\t\t\t$this->saveNode($dataId, array(\n\t\t\t\tself::INDEX_DATA => $node[$key],\n\t\t\t\tself::INFO => array(\n\t\t\t\t\tself::TYPE => self::DATA,\n\t\t\t\t\tself::LAST_INDEX => ($dataId << self::BITROT),\n\t\t\t)));\n\n\t\t\tunset($node[$key]);\n\t\t\t$node[$key][self::INDEX_DATA] = $dataId;\n\t\t\t$node[self::INFO] = $nodeInfo;\n\n\t\t\t$this->saveNode($id, $node);\n\t\t\treturn;\n\t\t}\n\n\t\tksort($node);\n\t\t$halfCount = ceil(count($node) / 2);\n\n\t\tlist($first, $second) = array_chunk($node, $halfCount, TRUE);\n\n\t\tend($first);\n\t\t$halfKey = key($first);\n\n\t\tif ($id <= 2) { // Root\n\t\t\tlist($firstId, $secondId) = $this->findFreeNode(2);\n\n\t\t\t$first[self::INFO] = array(\n\t\t\t\tself::TYPE => $nodeInfo[self::TYPE],\n\t\t\t\tself::IS_LEAF => $nodeInfo[self::IS_LEAF],\n\t\t\t\tself::PREV_NODE => -1,\n\t\t\t\tself::END => -1,\n\t\t\t\tself::MAX => $halfKey,\n\t\t\t);\n\t\t\t$this->saveNode($firstId, $first);\n\n\t\t\t$second[self::INFO] = array(\n\t\t\t\tself::TYPE => $nodeInfo[self::TYPE],\n\t\t\t\tself::IS_LEAF => $nodeInfo[self::IS_LEAF],\n\t\t\t\tself::PREV_NODE => $firstId,\n\t\t\t\tself::END => $nodeInfo[self::END],\n\t\t\t\tself::MAX => -1,\n\t\t\t);\n\t\t\t$this->saveNode($secondId, $second);\n\n\t\t\t$parentNode = array(\n\t\t\t\tself::INFO => array(\n\t\t\t\t\tself::TYPE => $nodeInfo[self::TYPE],\n\t\t\t\t\tself::IS_LEAF => FALSE,\n\t\t\t\t\tself::PREV_NODE => -1,\n\t\t\t\t\tself::END => $secondId,\n\t\t\t\t\tself::MAX => -1,\n\t\t\t\t),\n\t\t\t\t$halfKey => $firstId,\n\t\t\t);\n\t\t\t$this->saveNode($id, $parentNode);\n\t\t} else {\n\t\t\t$firstId = $this->findFreeNode();\n\n\t\t\t$first[self::INFO] = array(\n\t\t\t\tself::TYPE => $nodeInfo[self::TYPE],\n\t\t\t\tself::IS_LEAF => $nodeInfo[self::IS_LEAF],\n\t\t\t\tself::PREV_NODE => $nodeInfo[self::PREV_NODE],\n\t\t\t\tself::END => -1,\n\t\t\t\tself::MAX => $halfKey,\n\t\t\t);\n\t\t\t$this->saveNode($firstId, $first);\n\n\t\t\t$second[self::INFO] = array(\n\t\t\t\tself::TYPE => $nodeInfo[self::TYPE],\n\t\t\t\tself::IS_LEAF => $nodeInfo[self::IS_LEAF],\n\t\t\t\tself::PREV_NODE => $firstId,\n\t\t\t\tself::END => $nodeInfo[self::END],\n\t\t\t\tself::MAX => $nodeInfo[self::MAX],\n\t\t\t);\n\t\t\t$this->saveNode($id, $second);\n\n\t\t\tlist(,, $parent) = $this->findIndexNode($nodeInfo[self::TYPE], $halfKey);\n\t\t\t$parentNode = $this->getNode($parent);\n\t\t\tif ($parentNode === FALSE) {\n\t\t\t\tif (self::$debug) throw new \\InvalidStateException(\"Cannot load node number $parent.\");\n\t\t\t} else {\n\t\t\t\t$parentNode[$halfKey] = $firstId;\n\t\t\t\tksort($parentNode); // Parent index must be always sorted.\n\t\t\t\t$this->saveNode($parent, $parentNode);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Commit header to journal file.\n\t * @return void\n\t */\n\tprivate function headerCommit()\n\t{\n\t\tfseek($this->handle, self::INT32_SIZE);\n\t\t@fwrite($this->handle, pack('N', $this->lastNode));  // intentionally @, save is not necceseary\n\t}\n\n\n\n\t/**\n\t * Remove node from journal file.\n\t * @param  integer\n\t * @return void\n\t */\n\tprivate function deleteNode($id)\n\t{\n\t\tfseek($this->handle, 0, SEEK_END);\n\t\t$end = ftell($this->handle);\n\n\t\tif ($end <= (self::HEADER_SIZE + self::NODE_SIZE * ($id + 1))) {\n\t\t\t$packedNull = pack('N', 0);\n\n\t\t\tdo {\n\t\t\t\t$binary = stream_get_contents($this->handle, self::INT32_SIZE, (self::HEADER_SIZE + self::NODE_SIZE * --$id));\n\t\t\t} while (empty($binary) || $binary === $packedNull);\n\n\t\t\tif (!ftruncate($this->handle, self::HEADER_SIZE + self::NODE_SIZE * ($id + 1))) {\n\t\t\t\tthrow new \\InvalidStateException(\"Cannot truncate journal file.\");\n\t\t\t}\n\t\t} else {\n\t\t\tfseek($this->handle, self::HEADER_SIZE + self::NODE_SIZE * $id);\n\t\t\t$writen = fwrite($this->handle, pack('N', 0));\n\t\t\tif ($writen !== self::INT32_SIZE) {\n\t\t\t\tthrow new \\InvalidStateException(\"Cannot delete node number $id from journal.\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Complete delete all nodes from file.\n\t * @return void\n\t */\n\tprivate function deleteAll()\n\t{\n\t\tif (!ftruncate($this->handle, self::HEADER_SIZE)) {\n\t\t\tthrow new \\InvalidStateException(\"Cannot truncate journal file.\");\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Lock file for writing and reading and delete node cache when file has changed.\n\t * @return void\n\t */\n\tprivate function lock()\n\t{\n\t\t/**\n\t\t * @todo doeit cache\n\t\t */\n\t\t$this->nodeCache = $this->dataNodeFreeSpace = array();\n\t\treturn;\n\t}\n\n\n\n\t/**\n\t * Unlock file and save last modified time.\n\t * @return void\n\t */\n\tprivate function unlock()\n\t{\n\t\tfflush($this->handle);\n\t\treturn;\n\t}\n\n\n\n\t/**\n\t * Append $append to $array\n\t * This function is mutch faster then $array = array_merge($array, $append)\n\t * @param  array\n\t * @param  array\n\t * @return void\n\t */\n\tprivate function arrayAppend(array &$array, array $append)\n\t{\n\t\tforeach ($append as $value) {\n\t\t\t$array[] = $value;\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Append $append to $array with preserve keys\n\t * This function is mutch faster then $array = $array + $append\n\t * @param  array\n\t * @param  array\n\t * @return void\n\t */\n\tprivate function arrayAppendKeys(array &$array, array $append)\n\t{\n\t\tforeach ($append as $key => $value) {\n\t\t\t$array[$key] = $value;\n\t\t}\n\t}\n\n\tprotected function openFile($key, $mode, & $casToken = null)\n\t{\n\t\tif (func_num_args() === 3)\n\t\t{\n\t\t\t$val = $this->memcache->get($key, null, $casToken);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$val = $this->memcache->get($key);\n\t\t}\n\n\t\tif (false === $val)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t$handle = fopen(\"php://memory\", $mode);\n\t\tfwrite($handle, $val);\n\t\tfseek($handle, 0);\n\n\t\treturn $handle;\n\t}\n}\n\n/**\n * Wrapper kolem \\fseek tak, aby seekoval za konec php://memory jako soubory\n *\n * @param type $handle\n * @param type $offset\n * @param type $whence\n */\nfunction fseek($handle, $offset, $whence = SEEK_SET)\n{\n\tif ($whence === SEEK_SET)\n\t{\n\t\t\\fseek($handle, $offset, $whence);\n\t\t$pos = ftell($handle);\n\n\t\t$miss = $offset - $pos;\n\n\t\tif (feof($handle) && $miss > 0)\n\t\t{\n\t\t\tfwrite($handle, str_repeat(\"\\x0\", $miss), $miss);\n\t\t}\n\t}\n\telseif ($whence === SEEK_CUR)\n\t{\n\t\t$pos = ftell($handle);\n\t\t\\fseek($handle, $offset, $whence);\n\n\t\t$miss = $offset - $pos;\n\n\t\tif (feof($handle) && $miss > 0)\n\t\t{\n\t\t\tfwrite($handle, str_repeat(\"\\x0\", $miss), $miss);\n\t\t}\n\t}\n\telseif ($whence === SEEK_END)\n\t{\n\t\t\\fseek($handle, 0, $whence);\n\t\t$pos = ftell($handle);\n\t\t\\fseek($handle, $offset, $whence);\n\n\t\t$miss = $offset - $pos;\n\n\t\tif (feof($handle) && $miss > 0)\n\t\t{\n\t\t\tfwrite($handle, str_repeat(\"\\x0\", $miss), $miss);\n\t\t}\n\t}\n}\n?>",
 "title": ""
}