{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "re_sql",
  "kw_target",
  "lg_en",
  "re_ast1",
  "kw_attack"
 ],
 "key": "YNZ4Psnj",
 "pasteDate": "Feb 20, 2018, 5:34:28 PM",
 "relevancy": 9.0,
 "relevant": false,
 "text": "local ArtificiaLeftHipB = Instance.new(\"BindableEvent\", script)\nArtificiaLeftHipB.Name = \"Heartbeat\"\nscript:WaitForChild(\"Heartbeat\")\nlocal p = game.Players.LocalPlayer\nlocal char = p.Character\nlocal mouse = p:GetMouse()\nlocal larm = char[\"Left Arm\"]\nlocal rarm = char[\"Right Arm\"]\nlocal lleg = char[\"Left Leg\"]\nlocal rleg = char[\"Right Leg\"]\nlocal hed = char.Head\nlocal torso = char.Torso\nlocal hum = char.Humanoid\nlocal cam = game.Workspace.CurrentCamera\nlocal root = char.HumanoidRootPart\nlocal deb = false\nlocal Neck = torso:WaitForChild(\"Neck\")\nlocal shot = 0\nlocal debris=game:service\"Debris\"\nlocal CanAttack = true\nlocal l = game:GetService(\"Lighting\")\nlocal rs = game:GetService(\"RunService\").RenderStepped\nlocal animpose = \"Idle\"\nlocal lastanimpose = \"Idle\"\nlocal stanceToggle = \"Normal\"\nlocal Hood = false\nlocal holy = false --[[ change to true if u want him flying ]]\nlocal Trails = true --[[ change to true for glow trails comming from eyes ]]--\nlocal Shield = false\nlocal eColors = {\"New Yeller\", \"Institutional white\"}\nlocal cf = CFrame.new\nlocal euler = CFrame.fromEulerAnglesXYZ\nlocal vt = Vector3.new\nlocal angles = CFrame.Angles\nlocal attacktype=1\nlocal Melee = true\nptz = {0.8, 0.85, 0.9, 0.95, 1, 1.05, 1.1}\nmath.randomseed(os.time())\n\nRA,LA,RL,LL,H,T = char[\"Right Arm\"],char[\"Left Arm\"],char[\"Right Leg\"],char[\"Left Leg\"],char.Head,char.Torso\nRS,LS,RH,LH,N = T[\"Right Shoulder\"],T[\"Left Shoulder\"],T[\"Right Hip\"],T[\"Left Hip\"],T.Neck\nSettings,Pr0mMode,ArielMode,InternalMode,Heart = {Colors = {BrickColor.new(\"Institutional white\"),BrickColor.new(\"New Yeller\")};ExplosionColors = {BrickColor.new(\"Institutional white\"),BrickColor.new(\"New Yeller\"),BrickColor.new(\"New Yeller\"),BrickColor.new(\"Institutional white\")}},p.Name == \"Fir3bl4ze\",p.Name == \"Paul072\" or p.Name == \"KillBecca62\",p.Name == \"InternalRecursion\" or p.Name == \"RecursionAltInternal\",p.Name == \"heartstar1\"\nDebounces = {\nCanAttack = true;\nCanJoke = true;\nNoIdl = false;\nSlashing = false;\nSlashed = false;\nSlapping = false;\nSlapped = false;\nks = false;\n}\n\nlocal Touche = {char.Name, }\nlocal Character = p.Character\n\n\n\n\n\nlocal Shockwave = function()\n\tlocal rng1 = Instance.new(\"Part\", Character)\n                rng1.Anchored = true\n                rng1.BrickColor = BrickColor.new(\"Institutional white\")\n                rng1.CanCollide = false\n                rng1.FormFactor = 3\n                rng1.Name = \"Ring\"\n                rng1.Size = Vector3.new(1, 1, 1)\n                rng1.Transparency = 0.35\n                rng1.TopSurface = 0\n                rng1.BottomSurface = 0\n                local rngm1 = Instance.new(\"SpecialMesh\", rng1)\n                rngm1.MeshId = \"http://www.roblox.com/asset/?id=3270017\"\n                rngm1.Scale = Vector3.new(10, 10, 1)\n                rng1.CFrame = CFrame.new(0, -2, 0) * CFrame.Angles(0, 0, 0)\n                local Wave = Instance.new(\"Part\", game.Workspace--[[?]])\n                Wave.Name = \"Shockwave\"\n                Wave.BrickColor = BrickColor.new(\"Institutional white\")\n                Wave.Size = Vector3.new(1, 1, 1)\n                Wave.Shape = \"Ball\"\n                Wave.CanCollide = false\n                Wave.Anchored = true\n                Wave.TopSurface = 0\n                Wave.BottomSurface = 0\n                Wave.Touched:connect(function(hit)\n                    if hit.Parent:findFirstChild(\"Humanoid\") and hit.Parent:findFirstChild(\"Torso\") then\n                        local Occlude = true\n                        local NotOccludes = {\n                            Character.Name;\n                            \"Wings\";\n                            \"Scythe\";\n                            \"Thingy\";\n                            \"Thingy2\"; -- put all of the names in a table pls\n                        }\n                        for i,v in pairs(NotOccludes) do\n                            if hit.Parent.Name == v then\n                                Occlude = false\n                            end\n                        end\n                        --if hit.Parent.Name ~= char.Name and hit.Name ~= \"Wings\" and hit.Name ~= \"Scythe\" and hit.Name     ~= \"Thingy\" and hit.Name ~= \"Thingy2\" and hit.Parent.Name ~= \"Wings\" and hit.Parent.Name ~= \"Scythe\" and     hit.Parent.Name ~= \"Thingy\" and hit.Parent.Name ~= \"Thingy2\" then\n                        if Occlude then\n                            hit.Parent:findFirstChild(\"Humanoid\").Health = hit.Parent:findFirstChild(\"Humanoid\").Health - 500000000\n                            hit.Parent:findFirstChild(\"Torso\").Velocity = hit.Parent:findFirstChild(\"Torso\").CFrame.lookVector * 220\n                        end\n                    end\n                end)\n                \n                Instance.new(\"SpecialMesh\", Wave).MeshType = \"Sphere\"\n                \n                coroutine.wrap(function()\n                    for i = 1, 20, 0.2 do\n                        rngm1.Scale = Vector3.new(10 + i*2, 10 + i*2, 1)\n                        rng1.Transparency = i/20\n                    wait()\n                    end\n                    wait()\n                    rng1:Destroy()\n                end)()\n                \n                delay(0, function()\n\n                    if Daytime == false then\n                       for i = 1, 50, 1 do\n                            Wave.Size = Vector3.new(1 + i, 1 + i, 1 + i)\n                            Wave.CFrame = Character.Torso.CFrame\n                            local t = i / 50\n                            Wave.Transparency = t\n                            wait()\n                        end\n                    else\n                        for i = 1, 50, 1 do\n                            Wave.Size = Vector3.new(1 + i, 1 + i, 1 + i)\n                            Wave.CFrame = Character.Torso.CFrame\n                            local t = i / 50\n                            Wave.Transparency = t\n                            wait()\n                        end\n                    end\n                    Wave:Destroy()\n                end)\n                delay(0, function()\n                    while wait() do\n                        if Wave ~= nil then\n                            Wave.CFrame = Character.Torso.CFrame\n                        else\n                            break\n                        end\n                    end\n                end)\n            end\n\n\nfunction Shockwave2()\n\tlocal ENERGY = Instance.new(\"Part\", Character)\n\t\tENERGY.Name = \"ENERGY\"\n\t\tENERGY.CanCollide = false\n\t\tENERGY.Transparency = 0.2\n\t\tENERGY.TopSurface = 0\n\t\tENERGY.BottomSurface = 0\n\t\tENERGY.Anchored = true\n\t\tENERGY.BrickColor = BrickColor.new(\"Institutional white\")\n\t\t ENERGY.Touched:connect(function(hit)\n                    if hit.Parent:findFirstChild(\"Humanoid\") and hit.Parent:findFirstChild(\"Torso\") then\n                        local Occlude = true\n                        local NotOccludes = {\n                            Character.Name;\n                            \"Wings\";\n                            \"Scythe\";\n                            \"Thingy\";\n                            \"Thingy2\"; -- put all of the names in a table pls\n                        }\n                        for i,v in pairs(NotOccludes) do\n                            if hit.Parent.Name == v then\n                                Occlude = false\n                            end\n                        end\n                        --if hit.Parent.Name ~= char.Name and hit.Name ~= \"Wings\" and hit.Name ~= \"Scythe\" and hit.Name     ~= \"Thingy\" and hit.Name ~= \"Thingy2\" and hit.Parent.Name ~= \"Wings\" and hit.Parent.Name ~= \"Scythe\" and     hit.Parent.Name ~= \"Thingy\" and hit.Parent.Name ~= \"Thingy2\" then\n                        if Occlude then\n                            hit.Parent:findFirstChild(\"Humanoid\").Health = hit.Parent:findFirstChild(\"Humanoid\").Health - 50\n                            hit.Parent:findFirstChild(\"Torso\").Velocity = hit.Parent:findFirstChild(\"Torso\").CFrame.lookVector * 220\n                        end\n                    end\n                end)\n\t\tlocal cm = Instance.new(\"CylinderMesh\", ENERGY)\n\t\tcm.Scale = Vector3.new(1, 20, 1)\n\t\tENERGY.Size = Vector3.new(5, 20, 5)\n\t\tENERGY.CFrame = char.Torso.CFrame\n\t\tfor i = 1, 50 do\n\t\t\tENERGY.CFrame = char.Torso.CFrame\n\t\t\tENERGY.Transparency = ENERGY.Transparency + 0.012\n\t\t\tENERGY.Size = ENERGY.Size + Vector3.new(0.2, 0, 0.2)\n\t\t\twait()\n\t\tend\n\t\tENERGY:Destroy()\nend\n\n\n\nlocal RbxUtility = LoadLibrary(\"RbxUtility\")\nlocal Create = RbxUtility.Create\n\nfunction RemoveOutlines(part)\n\tpart.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10\nend\nfunction CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)\n\tlocal Part = Create(\"Part\"){\n\t\tParent = Parent,\n\t\tReflectance = Reflectance,\n\t\tTransparency = Transparency,\n\t\tCanCollide = false,\n\t\tLocked = true,\n\t\tBrickColor = BrickColor.new(tostring(BColor)),\n\t\tName = Name,\n\t\tSize = Size,\n\t\tMaterial = Material,\n\t}\n\tRemoveOutlines(Part)\n\treturn Part\nend\nlocal Effects = {}\n\nfunction CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)\n\tlocal Msh = Create(Mesh){\n\t\tParent = Part,\n\t\tOffset = OffSet,\n\t\tScale = Scale,\n\t}\n\tif Mesh == \"SpecialMesh\" then\n\t\tMsh.MeshType = MeshType\n\t\tMsh.MeshId = MeshId\n\tend\n\treturn Msh\nend\n\nfunction SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)\n\tlocal prt = CreatePart(workspace, \"SmoothPlastic\", 0, 0, brickcolor, \"Effect\", Vector3.new())\n\tprt.Anchored = true\n\tprt.CFrame = cframe\n\tlocal msh = CreateMesh(\"SpecialMesh\", prt, \"Sphere\", \"\", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))\n\tgame:GetService(\"Debris\"):AddItem(prt, 10)\n\ttable.insert(Effects, {\n\t\tprt,\n\t\t\"Cylinder\",\n\t\tdelay,\n\t\tx3,\n\t\ty3,\n\t\tz3,\n\t\tmsh\n\t})\nend\n\nfunction RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)\n\tlocal prt = CreatePart(workspace, \"SmoothPlastic\", 0, 0, brickcolor, \"Effect\", Vector3.new(0.5, 0.5, 0.5))\n\tprt.Anchored = true\n\tprt.CFrame = cframe * CFrame.new(x1, y1, z1)\n\tlocal msh = CreateMesh(\"SpecialMesh\", prt, \"FileMesh\", \"rbxassetid://3270017\", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))\n\tgame:GetService(\"Debris\"):AddItem(prt, 10)\n\ttable.insert(Effects, {\n\t\tprt,\n\t\t\"Cylinder\",\n\t\tdelay,\n\t\tx3,\n\t\ty3,\n\t\tz3,\n\t\tmsh\n\t})\nend\n\n\nfunction WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)\n\tlocal prt = CreatePart(workspace, \"SmoothPlastic\", 0, 0, brickcolor, \"Effect\", Vector3.new())\n\tprt.Anchored = true\n\tprt.CFrame = cframe\n\tlocal msh = CreateMesh(\"SpecialMesh\", prt, \"FileMesh\", \"rbxassetid://20329976\", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))\n\tgame:GetService(\"Debris\"):AddItem(prt, 10)\n\ttable.insert(Effects, {\n\t\tprt,\n\t\t\"Cylinder\",\n\t\tdelay,\n\t\tx3,\n\t\ty3,\n\t\tz3,\n\t\tmsh\n\t})\nend\n\nfunction rayCast(Position, Direction, Range, Ignore)\n\treturn game:service(\"Workspace\"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) \nend\nz = Instance.new(\"Sound\",char)\nz.SoundId = \"rbxassetid://736980589\"--..SIDz[math.random(1,#SIDz)]\nz.Looped = true\nz.Volume = 3\nz.Pitch = 1\nwait(1)\nz:Play()\nlocal Transformation = function()\n\t\t\n\t\thum.WalkSpeed = 0\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(0.6,0,0)\n\t\twait(0.7)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(-0.9,0,0)\n\t\tl.TimeOfDay = 24\n\t\twait(0.1)\n\t\tl.TimeOfDay = 14\n        Shockwave2()\n\t\twait(2)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(0.6,0,0)\n\t\twait(2.4)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(-0.6,0,0)\n\t\tl.TimeOfDay = 24\n\t\twait(0.1)\n\t\tl.TimeOfDay = 14\n\t\tShockwave2()\n\t\twait(0.3)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(0.6,0,0)\n\t\twait(0.6)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(-0.6,0,0)\n\t\tl.TimeOfDay = 24\n\t\twait(0.1)\n\t\tl.TimeOfDay = 14\n\t\tShockwave2()\n\t\twait(0.2)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(0.6,0,0)\n\t\twait(2)\n\t\tNeck.C0 = Neck.C0 * CFrame.Angles(-0.3,0,0)\n\t\tlocal TBlast, TBMesh = Instance.new(\"Part\"), Instance.new(\"SpecialMesh\")\n\tTBlast.BrickColor = BrickColor.new(\"New Yeller\")\n\tTBlast.Transparency = 1\n\tTBlast.Anchored = true\n\tTBlast.CanCollide = false\n\tTBlast.CFrame = root.CFrame\n\tTBlast.Size = Vector3.new(2,2,2)\n\tTBMesh.Parent = TBlast\n\tTBMesh.MeshType = \"Sphere\"\n\tgame.Lighting.Brightness = 0\n\t\tgame.Lighting.OutdoorAmbient = TBlast.BrickColor.Color\n\t\tgame.Lighting.TimeOfDay = 0.1\n\t\tgame.Lighting.FogEnd = 1000\n\t\tgame.Lighting.FogColor = TBlast.BrickColor.Color\n\tlocal hit, pos = rayCast(root.Position, (CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0))).lookVector, 6, Character)\n\tif hit ~= nil then\n\t\tlocal Color = hit.BrickColor\n\t\tlocal refpart = CreatePart(workspace, \"SmoothPlastic\", 0, 1, \"Institutional white\", \"Effect\", Vector3.new())\n\t\trefpart.Anchored = true\n\t\trefpart.CFrame = CFrame.new(pos)\n\t\tgame:GetService(\"Debris\"):AddItem(refpart, 1)\n\t\tfor i = 1, 5 do\n\t\t\tlocal Color = hit.BrickColor\n\t\t\tlocal Materials = hit.Material\n\t\t\tlocal groundpart = CreatePart(workspace, \"SmoothPlastic\", 0, 0, Color, \"Ground\", Vector3.new(math.random(500, 1000) / 1000, math.random(500, 1000) / 1000, math.random(500, 1000) / 1000))\n\t\t\tgroundpart.Anchored = false\n\t\t\tgroundpart.Material = Materials\n\t\t\tgroundpart.CanCollide = true\n\t\t\tgroundpart.Friction = 0.1\n\t\t\tgroundpart.Velocity = Vector3.new(math.random(-50, 50), math.random(25, 50), math.random(-50, 50))\n\t\t\tgroundpart.CFrame = CFrame.new(pos) * CFrame.new(math.random(-250, 250) / 100, 0.5, math.random(-250, 250) / 100) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))\n\t\t\tgame:GetService(\"Debris\"):AddItem(groundpart, 10)\n\t\tend\n\t\tfor i = 1, 6 do\n\t\t\tlocal Color = hit.BrickColor\n\t\t\tlocal Materials = hit.Material\n\t\t\tlocal actualgroundpart = CreatePart(workspace, \"SmoothPlastic\", 0, 0, Color, \"Ground\", Vector3.new(math.random(1000, 2000) / 1000, math.random(1000, 2000) / 1000, math.random(1000, 2000) / 1000))\n\t\t\tactualgroundpart.Anchored = true\n\t\t\tactualgroundpart.Material = Materials\n\t\t\tactualgroundpart.CanCollide = true\n\t\t\tactualgroundpart.Friction = 1\n\t\t\tactualgroundpart.CFrame = CFrame.new(pos) * CFrame.new(math.random(-500, 500) / 100, 0, math.random(-500, 500) / 100) * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))\n\t\t\tgame:GetService(\"Debris\"):AddItem(actualgroundpart, 10)\n\t\tend \n\t\tWaveEffect(hit.BrickColor, refpart.CFrame, .2, .2, .2, .5, .5, .5, .04)\n\t\tSphereEffect(hit.BrickColor, refpart.CFrame, .2, .2, .2, 3, 3, 3, .04)\n\t\tRingEffect(hit.BrickColor, refpart.CFrame * CFrame.Angles(math.random(5, 6), math.random(2, 7), math.random(3, 6)), .2, .2, .2, 1, 1, 1, .05)\n\tend\n\tShockwave()\nend\nTransformation()\n\t\n\t\nfor i,v in pairs(game.Players:GetChildren()) do\n       if v.Name ~= p then\ngame:GetService(\"Chat\"):Chat(v.Character.Head, \"The God Of Destruction Has Awakened\", Enum.ChatColor.Red)\nend\t\nend\npartic2 = Instance.new(\"ParticleEmitter\",torso)\npartic2.Color = ColorSequence.new(Color3.new(255/225,255/255,255/255),Color3.new(255/255,255/255,255/255))\npartic2.LightEmission = .95\npartic2.VelocityInheritance = 0.2\npartic2.Rate = 300\npartic2.Texture = \"rbxasset://textures/particles/explosion01_implosion_main.dds\" \npartic2.Lifetime = NumberRange.new(0.1,0.2)\npartic2.RotSpeed = NumberRange.new(100,100)\npartic2.Speed = NumberRange.new(2,6)\npartic2.Enabled = false\npartic2.LockedToPart = false \n\nfunction swait(num)\n    if num==0 or num==nil then\n    game:service'RunService'.Stepped:wait(0)\n    else\n    for i=0,num do\n    game:service'RunService'.Stepped:wait(0)\n    end\n    end\nend\n\nso = function(id,par,vol,pit)\n\tcoroutine.resume(coroutine.create(function()\nlocal sou = Instance.new(\"Sound\",par or workspace)\nsou.Volume=vol\nsou.Pitch=pit or 1\nsou.SoundId=id\nswait() \nsou:play() \ngame:GetService(\"Debris\"):AddItem(sou,6)\nend))\nend \n\n\np:ClearCharacterAppearance()\nwait(0.1)\np.Character.Head.BrickColor = BrickColor.new(\"Institutional white\")\np.Character.Torso.BrickColor = BrickColor.new(\"Institutional white\")\np.Character[\"Right Arm\"].BrickColor = BrickColor.new(\"Institutional white\")\np.Character[\"Right Leg\"].BrickColor = BrickColor.new(\"Institutional white\")\np.Character[\"Left Leg\"].BrickColor = BrickColor.new(\"Institutional white\")\np.Character[\"Left Arm\"].BrickColor = BrickColor.new(\"Institutional white\")\np.Character.Head.face:Destroy()\np.Character.Head.Material = \"Granite\"\np.Character.Torso.Material = \"Granite\"\np.Character[\"Right Arm\"].Material = \"Granite\"\np.Character[\"Right Leg\"].Material = \"Granite\"\np.Character[\"Left Leg\"].Material = \"Granite\"\np.Character[\"Left Arm\"].Material = \"Granite\"\nFl = Instance.new('Fire',larm); FR = Instance.new('Fire',rarm); Ft = Instance.new('Fire',torso)\nFt.Size = 0.8\nFl.Size = 0.8\nFR.Size = 0.8\nFl.Color = Color3.new(255,255,255)\nFR.Color = Color3.new(255,255,255)\nFt.Color = Color3.new(255,255,255)\nFl.SecondaryColor = Color3.new(255,255,255)\nFR.SecondaryColor = Color3.new(255,255,255)\nFt.SecondaryColor = Color3.new(255,255,255)\nSR = Instance.new('Smoke',rleg)\nSR.Color = Color3.new(255,255,255)\nSR.Size = 0.6\nSR.RiseVelocity = 0.7\nhum.WalkSpeed = 200\nhum.MaxHealth = math.huge\nwait(0.1)\nhum.Health = math.huge\nlocal TBlast, TBMesh = Instance.new(\"Part\"), Instance.new(\"SpecialMesh\")\n\tTBlast.BrickColor = BrickColor.new(\"New Yeller\")\n\tTBlast.Transparency = 1\n\tTBlast.Anchored = true\n\tTBlast.CanCollide = false\n\tTBlast.CFrame = root.CFrame\n\tTBlast.Size = Vector3.new(2,2,2)\n\tTBMesh.Parent = TBlast\n\tTBMesh.MeshType = \"Sphere\"\n\tgame.Lighting.Brightness = 0\n\t\tgame.Lighting.OutdoorAmbient = TBlast.BrickColor.Color\n\t\tgame.Lighting.TimeOfDay = 0.1\n\t\tgame.Lighting.FogEnd = 1000\n\t\tgame.Lighting.FogColor = TBlast.BrickColor.Color\n----------------------------------------------------\n\nnewWeld = function(wp0, wp1, wc0x, wc0y, wc0z)\nlocal wld = Instance.new(\"Weld\", wp1)\nwld.Part0 = wp0\nwld.Part1 = wp1\nwld.C0 = CFrame.new(wc0x, wc0y, wc0z)\nend\n----------------------------------------------------\nnewWeld(torso, larm, -1.5, 0.5, 0)\nlarm.Weld.C1 = CFrame.new(0, 0.5, 0)\nnewWeld(torso, rarm, 1.5, 0.5, 0)\nrarm.Weld.C1 = CFrame.new(0, 0.5, 0)\nnewWeld(torso, hed, 0, 1.5, 0)\nnewWeld(torso, lleg, -0.5, -1, 0)\nlleg.Weld.C1 = CFrame.new(0, 1, 0)\nnewWeld(torso, rleg, 0.5, -1, 0)\nrleg.Weld.C1 = CFrame.new(0, 1, 0)\nnewWeld(root, torso, 0, -1, 0)\ntorso.Weld.C1 = CFrame.new(0, -1, 0)\n----------------------------------------------------\nfunction Lerp(c1,c2,al)\nlocal com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}\nlocal com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}\nfor i,v in pairs(com1) do \ncom1[i] = v+(com2[i]-v)*al\nend\nreturn CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))\nend\n------------------------------------------------------\nlocal Orbd = Instance.new(\"Part\", char)\nOrbd.Name = \"Orbd\"\nOrbd.Shape = Enum.PartType.Ball\nOrbd.CanCollide = false\nOrbd.BrickColor = BrickColor.new(\"New Yeller\")\nOrbd.Transparency = 0\nOrbd.Material = \"Neon\"\nOrbd.Size = Vector3.new(0.1, 0.1, 0.1)\nOrbd.TopSurface = Enum.SurfaceType.Smooth\nOrbd.BottomSurface = Enum.SurfaceType.Smooth\n\nlocal Weld = Instance.new(\"Weld\", Orbd)\nWeld.Part0 = char.Head\nWeld.Part1 = Orbd\nWeld.C1 = CFrame.new(-0.2, -0.2, 0.5)\nlocal glov = Instance.new(\"PointLight\", Orbd)\nglov.Brightness = 3000\nglov.Range = 20\nglov.Color = Color3.new(225, 255, 255)\n\n--------------------------------------------------------\nlocal Orbvc = Instance.new(\"Part\", char)\nOrbvc.Name = \"Orbvc\"\nOrbvc.Shape = Enum.PartType.Ball\nOrbvc.CanCollide = false\nOrbvc.BrickColor = BrickColor.new(\"New Yeller\")\nOrbvc.Transparency = 0\nOrbvc.Material = \"Neon\"\nOrbvc.Size = Vector3.new(0.1, 0.1, 0.1)\nOrbvc.TopSurface = Enum.SurfaceType.Smooth\nOrbvc.BottomSurface = Enum.SurfaceType.Smooth\n\nlocal Weld = Instance.new(\"Weld\", Orbvc)\nWeld.Part0 = char.Head\nWeld.Part1 = Orbvc\nWeld.C1 = CFrame.new(0.2, -0.2, 0.5)\nlocal glo = Instance.new(\"PointLight\", Orbvc)\nglo.Brightness = 3000\nglo.Range = 20\nglo.Color = Color3.new(225, 255, 255)\nbs = Instance.new(\"Sound\", char)\nbs.SoundId = \"http://www.roblox.com/asset/?id = 141606337\"\nbs.Looped = false\nbs.Volume = 12\n\nlocal DestructionHands = true\n\nGroundWave = function()\n\tlocal HandCF = CFrame.new(root.Position - Vector3.new(0,3,0)) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))\n\tlocal Colors = {\"New Yeller\", \"Institutional white\"}\n\t\tlocal wave = Instance.new(\"Part\", torso)\n\t\twave.BrickColor = BrickColor.new(Colors[math.random(1,#Colors)])\n\t\twave.Anchored = true\n\t\twave.CanCollide = false\n\t\twave.Locked = true\n\t\twave.Size = Vector3.new(1, 1, 1)\n\t\twave.TopSurface = \"Smooth\"\n\t\twave.BottomSurface = \"Smooth\"\n\t\twave.Transparency = 0.35\n\t\twave.CFrame = HandCF\n\t\twm = Instance.new(\"SpecialMesh\", wave)\n\t\twm.MeshId = \"rbxassetid://3270017\"\n\t\tcoroutine.wrap(function()\n\t\tfor i = 1, 14, 1 do\n\t\twm.Scale = Vector3.new(1 + i*1.1, 1 + i*1.1, 1)\n\t\twave.Size = wm.Scale\n\t\twave.CFrame = HandCF\n\t\twave.Transparency = i/14\n\t\twait()\n\t\tend\n\t\twait()\n\t\twave:Destroy()\n\tend)()\nend\n\n\n\nlocal player = game.Players.LocalPlayer\nlocal pchar = player.Character\nlocal mouse = player:GetMouse()\nlocal cam = workspace.CurrentCamera\n\nlocal rad = math.rad\n\nlocal keysDown = {}\nlocal flySpeed = 0\nlocal MAX_FLY_SPEED = 150\n\nlocal canFly = false\nlocal flyToggled = false\n\nlocal forward, side = 0, 0\nlocal lastForward, lastSide = 0, 0\n\nlocal floatBP = Instance.new(\"BodyPosition\")\nfloatBP.maxForce = Vector3.new(0, math.huge, 0)\nlocal flyBV = Instance.new(\"BodyVelocity\")\nflyBV.maxForce = Vector3.new(9e9, 9e9, 9e9)\nlocal turnBG = Instance.new(\"BodyGyro\")\nturnBG.maxTorque = Vector3.new(math.huge, math.huge, math.huge)\n\nmouse.KeyDown:connect(function(key)\n\tkeysDown[key] = true\n\t\n\tif key == \"f\" then\n\t\tflyToggled = not flyToggled\n\t\t\n\tif not flyToggled then\n\t\tstanceToggle = \"Normal\"\n\t\tfloatBP.Parent = nil\n\t\tflyBV.Parent = nil\n\t\tturnBG.Parent = nil\n\t\troot.Velocity = Vector3.new()\n\t\tpchar.Humanoid.PlatformStand = false\n\tend\nend\n\t\nend)\nmouse.KeyUp:connect(function(key)\n\tkeysDown[key] = nil\nend)\n\nlocal function updateFly()\n\n\tif not flyToggled then return end\n\t\n\tlastForward = forward\n\tlastSide = side\n\t\n\tforward = 0\n\tside = 0\n\t\n\tif keysDown.w then\n\t\tforward = forward + 1\n\tend\n\tif keysDown.s then\n\t\tforward = forward - 1\n\tend\n\tif keysDown.a then\n\t\tside = side - 1\n\tend\n\tif keysDown.d then\n\t\tside = side + 1\n\tend\n\n\t\n\tcanFly = (forward ~= 0 or side ~= 0)\n\t\n\tif canFly then\n\t\tstanceToggle = \"Floating\"\n\t\tturnBG.Parent = root\n\t\tfloatBP.Parent = nil\n\t\tflyBV.Parent = root\n\t\t\n\t\tflySpeed = flySpeed + 1 + (flySpeed / MAX_FLY_SPEED)\n\t\tif flySpeed > MAX_FLY_SPEED then flySpeed = MAX_FLY_SPEED end\n\telse\n\t\tfloatBP.position = root.Position\n\t\tfloatBP.Parent = root\n\t\t\n\t\tflySpeed = flySpeed - 1\n\t\tif flySpeed < 0 then flySpeed = 0 end\n\tend\n\t\n\tlocal camCF = cam.CoordinateFrame\n\tlocal in_forward = canFly and forward or lastForward\n\tlocal in_side = canFly and side or lastSide\n\t\n\tflyBV.velocity = ((camCF.lookVector * in_forward) + (camCF * CFrame.new(in_side, \nin_forward * 0.2, 0).p) - camCF.p) * flySpeed\n\t\n\tturnBG.cframe = camCF * CFrame.Angles(-rad(forward * (flySpeed / MAX_FLY_SPEED)), 0, \n0)\nend\n\ngame:service'RunService'.RenderStepped:connect(function()\n\tif flyToggled then\n\t\tpchar.Humanoid.PlatformStand = true\n\tend\n\tupdateFly()\nend)\n\nif Trails == true then\n--------------------------------Trail\t\t\nlocal LastCFr = nil\nlocal Trails = Instance.new(\"Model\",char)\nlocal Trail = {}\nlocal Tip = Orbvc\nlocal number = 0\nlocal num2 = 1\ngame:GetService(\"RunService\").RenderStepped:connect(function()\n\tlocal start = nil\n\tfor i = num2,number do\n\t\tlocal v = Trail[i]\n\t\tif v ~= nil then\n\t\t\tlocal cfr = v.CFrame\n\t\t\tlocal Amount = v.Size.Y/3\n\t\t\tv.Size = v.Size-Vector3.new(0,Amount,0)\n\t\t\tv.Transparency = v.Transparency+0.05\n\t\t\tv.CFrame = cfr*CFrame.new(0,Amount/5,0)\n\t\t\tif v.Size.Y <= 0.1 or v.Transparency > 0.3 then\n\t\t\t\tv:Destroy()\n\t\t\t\tTrail[i] = nil\n\t\t\t\tnum2=num2+1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\n\t\tif LastCFr ~= nil and (Tip.Position-LastCFr.p).Magnitude > 0.01 then\n\t\t\tlocal cfr = Tip.CFrame\n\t\t\tlocal T = Instance.new(\"Part\",Trails)\n\t\t\tnumber = number+1\n\t\t\tTrail[number] = T\n\t\t\tT.FormFactor = \"Custom\"\n\t\t\tT.Name = \"Trail\"\n\t\t\tT.Anchored = true\n\t\t\tT.CanCollide = false\n\t\t\tT.Size = Vector3.new(0.3,(LastCFr.p-cfr.p).Magnitude,0.3)\n\t\t\tT.TopSurface = \"SmoothNoOutlines\"\n\t\t\tT.BottomSurface = \"SmoothNoOutlines\"\n\t\t\tT.FrontSurface = \"SmoothNoOutlines\"\n\t\t\tT.BackSurface = \"SmoothNoOutlines\"\n\t\t\tT.LeftSurface = \"SmoothNoOutlines\"\n\t\t\tT.RightSurface = \"SmoothNoOutlines\"\n\t\t\t--[[local m = Instance.new(\"SpecialMesh\",T)\n\t\t\tm.MeshType = \"Head\"\n\t\t\tm.Name = \"Mesh\"]]--\n\t\t\tT.BrickColor = BrickColor.new(\"New Yeller\")\n\t\t\tT.Transparency = 0.4\n\t\t\tT.CFrame = CFrame.new(cfr.p, LastCFr.p)* CFrame.Angles(math.rad(90),0,0) * CFrame.new(0, -(LastCFr.p-cfr.p).Magnitude/2, 0)\n\t\t\tLastCFr = cfr\n\t\telse\n\t\t\tLastCFr = Tip.CFrame\n\t\tend\nend)\n--------------------------------Trail\nlocal LastCFr = nil\nlocal Trails = Instance.new(\"Model\",char)\nlocal Trail = {}\nlocal Tip = Orbd\nlocal number = 0\nlocal num2 = 1\ngame:GetService(\"RunService\").RenderStepped:connect(function()\n\tlocal start = nil\n\tfor i = num2,number do\n\t\tlocal v = Trail[i]\n\t\tif v ~= nil then\n\t\t\tlocal cfr = v.CFrame\n\t\t\tlocal Amount = v.Size.Y/4\n\t\t\tv.Size = v.Size-Vector3.new(0,Amount,0)\n\t\t\tv.Transparency = v.Transparency+0.05\n\t\t\tv.CFrame = cfr*CFrame.new(0,Amount/5,0)\n\t\t\tif v.Size.Y <= 0.1 or v.Transparency > 0.3 then\n\t\t\t\tv:Destroy()\n\t\t\t\tTrail[i] = nil\n\t\t\t\tnum2=num2+1\n\t\t\tend\n\t\t\tbreak\n\t\tend\n\tend\n\t\tif LastCFr ~= nil and (Tip.Position-LastCFr.p).Magnitude > 0.01 then\n\t\t\tlocal cfr = Tip.CFrame\n\t\t\tlocal T = Instance.new(\"Part\",Trails)\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tnumber = number+1\n\t\t\tTrail[number] = T\n\t\t\tT.FormFactor = \"Custom\"\n\t\t\tT.Name = \"Trail\"\n\t\t\tT.Anchored = true\n\t\t\tT.CanCollide = false\n\t\t\tT.Size = Vector3.new(0.3,(LastCFr.p-cfr.p).Magnitude,0.3)\n\t\t\tT.TopSurface = \"SmoothNoOutlines\"\n\t\t\tT.BottomSurface = \"SmoothNoOutlines\"\n\t\t\tT.FrontSurface = \"SmoothNoOutlines\"\n\t\t\tT.BackSurface = \"SmoothNoOutlines\"\n\t\t\tT.LeftSurface = \"SmoothNoOutlines\"\n\t\t\tT.RightSurface = \"SmoothNoOutlines\"\n\t\t\t--[[local m = Instance.new(\"SpecialMesh\",T)\n\t\t\tm.MeshType = \"Head\"\n\t\t\tm.Name = \"Mesh\"]]--\n\t\t\tT.BrickColor = BrickColor.new(\"New Yeller\")\n\t\t\tT.Transparency = 0.4\n\t\t\tT.CFrame = CFrame.new(cfr.p, LastCFr.p)* CFrame.Angles(math.rad(90),0,0) * CFrame.new(0, -(LastCFr.p-cfr.p).Magnitude/2, 0)\n\t\t\tLastCFr = cfr\n\t\telse\n\t\t\tLastCFr = Tip.CFrame\n\t\tend\nend)\nend\n\nMagik = function()\n\tspawn(function()\n\t\tlocal function lerp(a,b,c)\n\t\t\treturn a+(b-a)*c\t\n\t\tend\n\t\tlocal function rndRange(rng)\n\t\t\treturn math.random(-rng*1000,rng*1000)/1000\t\n\t\tend\n\t\tlocal magik = Instance.new(\"Part\", larm)\n\t\tlocal Colors = {\"New Yeller\", \"Institutional white\"}\n\t\tmagik.Anchored = true\n\t\tmagik.Locked = true\n\t\tmagik.Material = \"Neon\"\n\t\tmagik.FormFactor = \"Custom\"\n\t\tmagik.Size = Vector3.new(1.2, 1.2, 1.2)\n\t\tmagik.TopSurface = \"Smooth\"\n\t\tmagik.BottomSurface = \"Smooth\"\n\t\tmagik.Transparency = 0\n\t\tmagik.CanCollide = false\n\t\t\n\t\tif holy == false then\n\t\tmagik.BrickColor = BrickColor.new(Colors[math.random(1,#Colors)])\n\t\tend\n\t\t\n\t\tlocal mr = math.rad\n\t\tlocal rnx,rny,rnz = mr(rndRange(180)),mr(rndRange(180)),mr(rndRange(180))\n\t\tlocal cf = larm.CFrame * CFrame.new(0, -.8, 0) * CFrame.Angles(rnx,rny,rnz)\n\t\tmagik.CFrame = cf\n\t\tfor i = 0, 1, .05 do\n\t\t\tlocal newTrans = lerp(0.5, 1, i)\n\t\t\tlocal ns = lerp(1,1.2,i)\n\t\t\tmagik.Transparency = newTrans\n\t\t\tmagik.Size = Vector3.new(ns,ns,ns)\n\t\t\tmagik.CFrame = cf\n\t\t\trs:wait()\n\t    end\n\t\tmagik:Destroy()\n\t\twait()\n    end)\nend\n----------------------------------------------------\nMagik2 = function()\n\tspawn(function()\n\t\tif stanceToggle == \"Normal\" or stanceToggle == \"Running\" or stanceToggle == \"Melee\" then\n\t\tlocal function lerp(a,b,c)\n\t\t\treturn a+(b-a)*c\t\n\t\tend\n\t\tlocal function rndRange(rng)\n\t\t\treturn math.random(-rng*1000,rng*1000)/1000\t\n\t\tend\n\t\tlocal magik2 = Instance.new(\"Part\", rarm)\n\t\tlocal Colors = {\"New Yeller\", \"Institutional white\"}\n\t\tmagik2.Anchored = true\n\t\tmagik2.Locked = true\n\t\tmagik2.FormFactor = \"Custom\"\n\t\tmagik2.Size = Vector3.new(1.2, 1.2, 1.2)\n\t\tmagik2.TopSurface = \"Smooth\"\n\t\tmagik2.BottomSurface = \"Smooth\"\n\t\tmagik2.Transparency = 0\n\t\tmagik2.Material = \"Neon\"\n\t\tmagik2.CanCollide = false\n\t\t\n\t\tif holy == false then\n\t\tmagik2.BrickColor = BrickColor.new(Colors[math.random(1,#Colors)])\n\t\tend\n\t\t\n\t\tlocal mr = math.rad\n\t\tlocal rnx,rny,rnz = mr(rndRange(180)),mr(rndRange(180)),mr(rndRange(180))\n\t\tlocal cf = rarm.CFrame * CFrame.new(0, -.8, 0) * CFrame.Angles(rnx,rny,rnz)\n\t\tmagik2.CFrame = cf\n\t\tfor i = 0, 1, .05 do\n\t\t\tlocal newTrans = lerp(0.5, 1, i)\n\t\t\tlocal ns = lerp(1,1.2,i)\n\t\t\tmagik2.Transparency = newTrans\n\t\t\tmagik2.Size = Vector3.new(ns,ns,ns)\n\t\t\tmagik2.CFrame = cf\n\t\t\trs:wait()\n\t    end\n\t\tmagik2:Destroy()\n\t\telseif stanceToggle ~= \"Melee\" or stanceToggle == \"Normal\" or stanceToggle == \"Running\" then\n\t\twait()\n\t\tend\n    end)\nend\n\nMesh2 = function(par,num,x,y,z)\n    local msh = _\n    if num == 1 then\n        msh = Instance.new(\"CylinderMesh\",par)\n    elseif num == 2 then\n        msh = Instance.new(\"SpecialMesh\",par)\n        msh.MeshType = 3\n    elseif num == 3 then\n        msh = Instance.new(\"BlockMesh\",par)\n    elseif num == 4 then\n        msh = Instance.new(\"SpecialMesh\",par)\n        msh.MeshType = \"Torso\"\n    elseif type(num) == 'string' then\n        msh = Instance.new(\"SpecialMesh\",par)\n        msh.MeshId = num\n    end \n    msh.Scale = Vector3.new(x,y,z)\n    return msh\nend\n\nfunction nooutline(part)\n\t\tpart.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10\n\tend\n\t\n\tfunction part(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)\n\t\tlocal fp=Instance.new(\"Part\")\n\t\tfp.formFactor=formfactor\n\t\tfp.Parent=parent\n\t\tfp.Reflectance=reflectance\n\t\tfp.Transparency=transparency\n\t\tfp.CanCollide=false\n\t\tfp.Locked=true\n\t\tfp.BrickColor=BrickColor.new(tostring(brickcolor))\n\t\tfp.Name=name\n\t\tfp.Size=size\n\t\tfp.Position=char.Torso.Position\n\t\tnooutline(fp)\n\t\tfp.Material= material\n\t\tfp:BreakJoints()\n\t\treturn fp\n\tend\n\n\nit = Instance.new\n\nPlayer=game:GetService('Players').LocalPlayer\n\tCharacter=Player.Character\n\tMouse=Player:GetMouse()\n\tm=Instance.new('Model',Character)\nfunction part2(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)\n\t\tlocal fp=Instance.new(\"Part\")\n\t\tfp.formFactor=formfactor\n\t\tfp.Parent=parent\n\t\tfp.Reflectance=reflectance\n\t\tfp.Transparency=transparency\n\t\tfp.CanCollide=false\n\t\tfp.Locked=true\n\t\tfp.BrickColor=BrickColor.new(tostring(brickcolor))\n\t\tfp.Name=name\n\t\tfp.Size=size\n\t\tfp.Position=Character.Torso.Position\n\t\tnooutline(fp)\n\t\tfp.Material= \"Neon\"\n\t\tfp:BreakJoints()\n\t\treturn fp\n\tend\nfunction weld(parent,part0,part1,c0,c1)\n\t\tlocal weld=it(\"Weld\")\n\t\tweld.Parent=parent\n\t\tweld.Part0=part0\n\t\tweld.Part1=part1\n\t\tweld.C0=c0\n\t\tweld.C1=c1\n\t\treturn weld\n\tend\nfunction mesh(Mesh,part,meshtype,meshid,offset,scale)\n\t\tlocal mesh=it(Mesh)\n\t\tmesh.Parent=part\n\t\tif Mesh==\"SpecialMesh\" then\n\t\t\tmesh.MeshType=meshtype\n\t\t\tmesh.MeshId=meshid\n\t\tend\n\t\tmesh.Offset=offset\n\t\tmesh.Scale=scale\n\t\treturn mesh\n\tend\n\nPlayer.Character[\"Right Arm\"].Transparency = 1\nPlayer.Character[\"Right Leg\"].Transparency = 1\nMN=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"Handle\",Vector3.new(1.09732866, 2.19465828, 1.09732854))\nMNweld=weld(m,Character[\"Right Arm\"],MN,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.0323486328, -0.0509860516, -0.00120401382, -0.00500982394, 0.00520668458, 0.999973893, -0.00739898486, 0.999958873, -0.00524367485, -0.999960065, -0.00742506143, -0.0049710935))\nTR7=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR7\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nTR7weld=weld(m,MN,TR7,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000442504883, 0.68581605, 0.000279426575, 1.00000381, 0.000690042973, -0.000169841573, 0.000690029934, -0.999999702, -0.000261242967, -0.000170052983, 0.000261111214, -1.00000393))\nmesh(\"SpecialMesh\",TR7,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(0.200000003, 1.02999997, 1.02999997))\nMD9=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD9\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nMD9weld=weld(m,MN,MD9,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0, 0.741846681, 0.199262142, 1.00000405, -6.92205504e-06, 0.000154254027, 4.65649646e-05, 0.965939224, -0.25876984, -0.000147186685, 0.258768767, 0.965943158))\nmesh(\"SpecialMesh\",MD9,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.01999998, 0.411340922, 1.01999998))\nMD1=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD1\",Vector3.new(0.237408489, 0.259352177, 0.518704116))\nMD1weld=weld(m,MN,MD1,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.402763367, -0.974855185, 0.682875633, 0.99988991, -0.0150081124, -0.00168980728, 0.0149988253, 0.999872923, -0.00539785437, 0.00177063467, 0.00537188631, 0.999988079))\nmesh(\"SpecialMesh\",MD1,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD10=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD10\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nMD10weld=weld(m,MN,MD10,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.28881836e-05, -0.960148811, -0.000584125519, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD10,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nMD11=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD11\",Vector3.new(0.266768694, 1.09732914, 0.658397138))\nMD11weld=weld(m,MN,MD11,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.493839264, -0.274354219, 4.24385071e-05, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD11,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.415454358, 1, 1.00999999))\nMD12=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD12\",Vector3.new(0.266768694, 1.09732914, 0.658397138))\nMD12weld=weld(m,MN,MD12,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.493812561, -0.274300575, -0.000376224518, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD12,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.415454358, 1, 1.00999999))\nMD13=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD13\",Vector3.new(1.09732866, 0.822996795, 1.09732854))\nMD13weld=weld(m,MN,MD13,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.90734863e-05, 0.68582201, 0.000464439392, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD13,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nMD14=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD14\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nMD14weld=weld(m,MN,MD14,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.90734863e-05, 0.603547096, 0.000416755676, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD14,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.04999995, 0.411340922, 1.04999995))\nMD15=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD15\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nMD15weld=weld(m,MN,MD15,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-7.62939453e-05, 0.137180567, -4.529953e-05, -1.0000037, -0.000862163957, 0.000179466791, -0.000862103421, 0.999999523, 0.000520790287, -0.000179945491, 0.000520619913, -1.00000381))\nmesh(\"SpecialMesh\",MD15,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nMD16=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD16\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nMD16weld=weld(m,MN,MD16,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-6.86645508e-05, 0.932742357, 0.000658988953, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD16,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.04999995, 0.411340922, 1.04999995))\nMD19=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD19\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nMD19weld=weld(m,MN,MD19,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000442504883, 0.68581605, 0.000279426575, 1.00000381, 0.000690042973, -0.000169841573, 0.000690029934, -0.999999702, -0.000261242967, -0.000170052983, 0.000261111214, -1.00000393))\nmesh(\"SpecialMesh\",MD19,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(0.5, 1.01999998, 1.01999998))\nMD18=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD18\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nMD18weld=weld(m,MN,MD18,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.52587891e-05, -0.246893644, -0.00013256073, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD18,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.01999998, 0.411340922, 1.01999998))\nMD2=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD2\",Vector3.new(0.2574085, 0.259352177, 0.518704116))\nMD2weld=weld(m,MN,MD2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.392555237, -0.573539257, 1.09872949, 0.999886394, -0.0152528733, -0.00162532134, 0.0119883548, 0.710953057, 0.70314008, -0.00956933573, -0.703074038, 0.71105516))\nmesh(\"SpecialMesh\",MD2,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD3=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD3\",Vector3.new(0.247408509, 0.259352177, 0.518704116))\nMD3weld=weld(m,MN,MD3,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.397964478, -0.817667723, 0.487944126, 0.999890864, -0.0149886403, -0.00193861127, 0.0139457425, 0.964460015, -0.263861924, 0.00582473399, 0.26380372, 0.964563668))\nmesh(\"SpecialMesh\",MD3,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD4=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD4\",Vector3.new(0.247408509, 0.259352177, 0.518704116))\nMD4weld=weld(m,MN,MD4,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.422103882, -0.82026124, 0.507567406, 0.999890864, -0.0149886403, -0.00193861127, 0.0139457425, 0.964460015, -0.263861924, 0.00582473399, 0.26380372, 0.964563668))\nmesh(\"SpecialMesh\",MD4,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD5=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD5\",Vector3.new(0.2574085, 0.259352177, 0.518704116))\nMD5weld=weld(m,MN,MD5,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.427509308, -0.557831764, 1.11046171, 0.999886394, -0.0152528733, -0.00162532134, 0.0119883548, 0.710953057, 0.70314008, -0.00956933573, -0.703074038, 0.71105516))\nmesh(\"SpecialMesh\",MD5,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD6=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD6\",Vector3.new(0.237408489, 0.259352177, 0.518704116))\nMD6weld=weld(m,MN,MD6,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.417263031, -0.972257376, 0.702233315, 0.99988991, -0.0150081124, -0.00168980728, 0.0149988253, 0.999872923, -0.00539785437, 0.00177063467, 0.00537188631, 0.999988079))\nmesh(\"SpecialMesh\",MD6,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nMD7=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD7\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nMD7weld=weld(m,MN,MD7,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000442504883, 0.68581605, 0.000279426575, 1.00000381, 0.000690042973, -0.000169841573, 0.000690029934, -0.999999702, -0.000261242967, -0.000170052983, 0.000261111214, -1.00000393))\nmesh(\"SpecialMesh\",MD7,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nMD8=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD8\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nMD8weld=weld(m,MN,MD8,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.28881836e-05, -0.960148811, -0.000584125519, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",MD8,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.5, 1.01999998, 1.01999998))\nTR1=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR1\",Vector3.new(0.266768694, 0.54866457, 0.548664272))\nTR1weld=weld(m,MN,TR1,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.548826218, 0.30154109, 4.57763672e-05, -0.000205519143, -0.0001726388, -1, -4.31765802e-05, 1, -0.00017263052, 1, 4.314119e-05, -0.000205526594))\nmesh(\"SpecialMesh\",TR1,Enum.MeshType.Cylinder,\"\",Vector3.new(0, 0, 0),Vector3.new(0.415454358, 0.700000048, 0.700000048))\nTR2=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR2\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nTR2weld=weld(m,MN,TR2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.28881836e-05, 0.741921067, 0.198978901, 1.00000405, -2.92747281e-05, -1.7457176e-05, 2.37242784e-05, 0.965939343, -0.258769363, 2.44602561e-05, 0.25876832, 0.965943277))\nmesh(\"SpecialMesh\",TR2,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.02999997, 0.0822681859, 1.02999997))\nTR3=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR3\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nTR3weld=weld(m,MN,TR3,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-3.81469727e-05, 0.603546381, 0.000186920166, 1.00000787, -8.63452442e-05, -2.6775524e-07, 8.62879679e-05, 1, -2.05411197e-07, 2.68686563e-07, 2.3024586e-07, 1.00000775))\nmesh(\"SpecialMesh\",TR3,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.05999994, 0.0822681859, 1.05999994))\nTR4=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR4\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nTR4weld=weld(m,MN,TR4,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.000106811523, 0.93274045, 0.000304222107, 1.00000787, -8.63452442e-05, -2.6775524e-07, 8.62879679e-05, 1, -2.05411197e-07, 2.68686563e-07, 2.3024586e-07, 1.00000775))\nmesh(\"SpecialMesh\",TR4,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.05999994, 0.0822681859, 1.05999994))\nTR5=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR5\",Vector3.new(1.09732866, 0.274332285, 1.09732854))\nTR5weld=weld(m,MN,TR5,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(2.28881836e-05, -0.960148811, -0.000584125519, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",TR5,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.200000003, 1.02999997, 1.02999997))\nTR6=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TR6\",Vector3.new(1.09732866, 0.266768783, 1.09732854))\nTR6weld=weld(m,MN,TR6,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.52587891e-05, -0.246893644, -0.00013256073, 1.00000811, -2.88709998e-08, 3.02679837e-08, -2.93366611e-08, 0.99999994, 1.36606104e-08, 3.0733645e-08, 1.3564204e-08, 1.00000799))\nmesh(\"SpecialMesh\",TR6,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.02999997, 0.0822681859, 1.02999997))\nMD21=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"MD21\",Vector3.new(0.266768694, 0.54866457, 0.548664272))\nMD21weld=weld(m,MN,MD21,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.548921585, 0.301375628, 0.000118255615, -0.000262488145, -9.39509191e-05, -1.00000393, -0.000154611655, 1, -9.38984886e-05, 1.00000393, 0.000154557638, -0.000262471847))\nmesh(\"SpecialMesh\",MD21,Enum.MeshType.Cylinder,\"\",Vector3.new(0, 0, 0),Vector3.new(0.411340952, 0.900000036, 0.900000036))\nMN=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"Handle\",Vector3.new(1.03740847, 2.07481742, 1.03740823))\nMNweld=weld(m,Character[\"Right Leg\"],MN,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.00872802734, 0.00284510851, -0.0114479065, 0.000559218752, 0.00461495388, -0.999989212, 0.0116515048, 0.999921441, 0.00462115649, 0.999931991, -0.0116539635, 0.000505403674))\nFB1=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB1\",Vector3.new(0.252201617, 1.03740871, 0.622444928))\nFB1weld=weld(m,MN,FB1,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.466812134, -0.259373605, 4.19616699e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB1,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.415454358, 1, 1.00999999))\nFB10=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB10\",Vector3.new(1.03740847, 0.259352177, 1.03740823))\nFB10weld=weld(m,MN,FB10,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(1.14440918e-05, -0.907726586, -0.0001745224, -1.00000012, -4.3686945e-05, -0.000145533413, -4.37181443e-05, 1, 0.00021532696, 0.000145524042, 0.000215333974, -1))\nmesh(\"SpecialMesh\",FB10,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nFB11=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB11\",Vector3.new(0.518704236, 0.778056443, 0.252201557))\nFB11weld=weld(m,MN,FB11,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-3.81469727e-05, 0.49278298, -0.518682957, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB11,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 0.415454417))\nFB12=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB12\",Vector3.new(1.03740847, 0.778056443, 1.03740823))\nFB12weld=weld(m,MN,FB12,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-1.14440918e-05, 0.648371816, 1.38282776e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB12,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nFB2=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB2\",Vector3.new(1.03740847, 0.252201647, 1.03740823))\nFB2weld=weld(m,MN,FB2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.28881836e-05, 0.726178706, 4.57763672e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB2,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.04999995, 0.415454417, 1.04999995))\nFB3=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB3\",Vector3.new(1.03740847, 0.259352177, 0.518704116))\nFB3weld=weld(m,MN,FB3,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000141143799, -0.907841623, 0.725996017, -1.00000012, -4.3686945e-05, -0.000145533413, -4.37181443e-05, 1, 0.00021532696, 0.000145524042, 0.000215333974, -1))\nmesh(\"SpecialMesh\",FB3,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nFB4=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB4\",Vector3.new(1.03740847, 0.259352177, 0.518704116))\nFB4weld=weld(m,MN,FB4,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000263214111, -0.495628834, 1.08177543, -1, -0.000208274461, -0.000166981248, -2.93208286e-05, 0.707433105, -0.706780434, 0.000265331706, -0.706780314, -0.707433105))\nmesh(\"SpecialMesh\",FB4,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nFB5=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB5\",Vector3.new(1.03740847, 0.252201647, 1.03740823))\nFB5weld=weld(m,MN,FB5,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.67028809e-05, 0.933657289, 6.19888306e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB5,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.04999995, 0.415454417, 1.04999995))\nFB6=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB6\",Vector3.new(1.03740847, 0.259352177, 1.03740823))\nFB6weld=weld(m,MN,FB6,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(3.81469727e-06, 0.129679263, 3.29017639e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB6,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nFB7=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB7\",Vector3.new(0.252201617, 1.03740871, 0.622444928))\nFB7weld=weld(m,MN,FB7,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.466838837, -0.259338915, -8.58306885e-06, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",FB7,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.415454358, 1, 1.00999999))\nFB8=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB8\",Vector3.new(1.03740847, 0.259352177, 0.518704116))\nFB8weld=weld(m,MN,FB8,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(0.000205993652, -0.764207125, 0.546924591, -0.999995053, -0.000121198129, -0.00017335522, -0.000163274352, 0.965882957, 0.258978456, 0.000135882699, 0.258978575, -0.96587801))\nmesh(\"SpecialMesh\",FB8,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1, 1.00999999, 1.00999999))\nFB9=part(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"Institutional white\",\"FB9\",Vector3.new(1.03740847, 0.259352177, 1.03740823))\nFB9weld=weld(m,MN,FB9,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-0.00023651123, 0.648379326, -0.000217437744, -0.99999994, 0.00030120369, -0.00014261005, -0.000301247928, -0.999999821, 0.000302845408, -0.000142518838, 0.000302889268, 1))\nmesh(\"SpecialMesh\",FB9,Enum.MeshType.Wedge,\"\",Vector3.new(0, 0, 0),Vector3.new(1.00999999, 1.00999999, 1.00999999))\nTN1=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TN1\",Vector3.new(1.03740847, 0.252201647, 1.03740823))\nTN1weld=weld(m,MN,TN1,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.67028809e-05, 0.933657289, 6.19888306e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",TN1,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.05999994, 0.205670506, 1.05999994))\nTN2=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TN2\",Vector3.new(0.518704236, 0.778056443, 0.252201557))\nTN2weld=weld(m,MN,TN2,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-3.81469727e-05, 0.49278298, -0.518682957, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",TN2,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(0.899999917, 0.899999917, 0.419567823))\nTN3=part2(Enum.FormFactor.Custom,m,Enum.Material.SmoothPlastic,0,0,\"New Yeller\",\"TN3\",Vector3.new(1.03740847, 0.252201647, 1.03740823))\nTN3weld=weld(m,MN,TN3,CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),CFrame.new(-2.28881836e-05, 0.726178706, 4.57763672e-05, 1, 0, 5.82076609e-11, 0, 1, -2.07592166e-10, 5.82076609e-11, -2.07592166e-10, 1.00000012))\nmesh(\"SpecialMesh\",TN3,Enum.MeshType.Brick,\"\",Vector3.new(0, 0, 0),Vector3.new(1.05999994, 0.205670506, 1.05999994))\n\n\n\n\n\n\nWeld2 = function(p0,p1,x,y,z,rx,ry,rz,par)\n    local w = Instance.new('Motor',par or p0)\n    w.Part0 = p0\n    w.Part1 = p1\n    w.C1 = CFrame.new(x,y,z)*CFrame.Angles(rx,ry,rz)\n    return w\nend\n\n\nlocal acos = math.acos\nlocal sqrt = math.sqrt\nlocal Vec3 = Vector3.new\nlocal fromAxisAngle = CFrame.fromAxisAngle\n\nlocal function toAxisAngle(CFr)\n        local X,Y,Z,R00,R01,R02,R10,R11,R12,R20,R21,R22 = CFr:components()\n        local Angle = math.acos((R00+R11+R22-1)/2)\n        local A = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2\n        A = A == 0 and 0.00001 or A\n        local B = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2\n        B = B == 0 and 0.00001 or B\n        local C = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2\n        C = C == 0 and 0.00001 or C\n        local x = (R21-R12)/sqrt(A)\n        local y = (R02-R20)/sqrt(B)\n        local z = (R10-R01)/sqrt(C)\n        return Vec3(x,y,z),Angle\nend\n\nfunction ApplyTrig(Num,Func)\n        local Min,Max = Func(0),Func(1)\n        local i = Func(Num)\n        return (i-Min)/(Max-Min)\n        --[[if Func == \"sin\" then\n                return (math.sin((1-Num)*math.pi)+1)/2\n        elseif Func == \"cos\" then\n                return (math.cos((1-Num)*math.pi)+1)/2\n        end]]\nend\n\nfunction LerpCFrame(CFrame1,CFrame2,Num)\n        local Vec,Ang = toAxisAngle(CFrame1:inverse()*CFrame2)\n        return CFrame1*fromAxisAngle(Vec,Ang*Num) + (CFrame2.p-CFrame1.p)*Num\nend\n\nfunction Crater(Torso,Radius)\n        Spawn(function()\n        local Ray = Ray.new(Torso.Position,Vector3.new(0,-1,0)*10)\n        local Ignore = {}\n        for i,v in pairs(game:GetService(\"Players\"):GetPlayers()) do\n                if v.Character ~= nil then\n                        Ignore[#Ignore+1] = v.Character\n                end\n        end\n        local Hit,Pos,SurfaceNorm = workspace:FindPartOnRayWithIgnoreList(Ray,Ignore)\n        if Hit == nil then return end\n        local Parts = {}\n        for i = 1,360,10 do\n                local P = Instance.new(\"Part\",Torso.Parent)\n                P.Anchored = true\n                P.FormFactor = \"Custom\"\n                P.BrickColor = Hit.BrickColor\n                P.Material = Hit.Material\n                P.TopSurface = \"Smooth\"\n                P.BottomSurface = \"Smooth\"\n                P.Size = Vector3.new(5,10,10)*(math.random(80,100)/100)\n                P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,7,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))\n                Parts[#Parts+1] = {P,P.CFrame,((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,1,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius)*CFrame.Angles(math.rad(math.random(-50,-20)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),P.Size}\n                if math.random(0,5) == 0 then -- rubble\n                        local P = Instance.new(\"Part\",Torso.Parent)\n                        P.Anchored = true\n                        P.FormFactor = \"Custom\"\n                        P.BrickColor = Hit.BrickColor\n                        P.Material = Hit.Material\n                        P.TopSurface = \"Smooth\"\n                        P.BottomSurface = \"Smooth\"\n                        P.Size = Vector3.new(2,2,2)*(math.random(80,100)/100)\n                        P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,2.5,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))\n                        Parts[#Parts+1] = {P,P.CFrame,(CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius-8)*CFrame.Angles(math.rad(math.random(-90,90)),math.rad(math.random(-90,90)),math.rad(math.random(-90,90))),P.Size}\n                end\n        end\n        for i = 0,1,0.05 do\n                for i2,v in pairs(Parts) do\n                        v[1].CFrame = LerpCFrame(v[2],v[3],ApplyTrig(i,math.cos))\n                end\n                wait(0.02)\n        end\n        for i,v in pairs(Parts) do\n                if v[1].Size.X > 2.1 then\n                        v[1].CFrame = v[1].CFrame+Vector3.new(0,2,0)\n                end\n                v[1].Anchored = false\n        end\n        for i = 0,1,0.05 do\n                for i2,v in pairs(Parts) do\n                        v[1].Transparency = i\n                        if i == 1 then\n                                v[1]:Destroy()\n                        elseif i >= 0.25 then\n                                v[1].CanCollide = false\n                        end\n                end\n                wait(0.02)\n        end\n        Parts = nil\n        end)\nend\n\nfunction Crater2(Torso,Radius)\n\t\t\tspawn(function()\n\t\t\t\tlocal Ray = Ray.new(Torso.Position,Vector3.new(0,-1,0)*10)\n\t\t\t\tlocal Ignore = {}\n\t\t\t\tfor i,v in pairs(game:GetService(\"Players\"):GetPlayers()) do\n\t\t\t\t\tif v.Character ~= nil then\n\t\t\t\t\t\tIgnore[#Ignore+1] = v.Character\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tlocal Hit,Pos,SurfaceNorm = workspace:FindPartOnRayWithIgnoreList(Ray,Ignore)\n\t\t\t\tif Hit == nil then return end\n\t\t\t\t\tlocal Parts = {}\n\t\t\t\t\tfor i = 1,360,10 do\n\t\t\t\t\t\tlocal P = Instance.new(\"Part\",Torso.Parent)\n\t\t\t\t\t\tP.Anchored = true\n\t\t\t\t\t\tP.FormFactor = \"Custom\"\n\t\t\t\t\t\tP.BrickColor = Hit.BrickColor\n\t\t\t\t\t\tP.Material = Hit.Material\n\t\t\t\t\t\tP.TopSurface = \"Smooth\"\n\t\t\t\t\t\tP.BottomSurface = \"Smooth\"\n\t\t\t\t\t\tP.Size = Vector3.new(5,10,10)*(math.random(80,100)/100)\n\t\t\t\t\t\tP.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,7,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))\n\t\t\t\t\t\tParts[#Parts+1] = {P,P.CFrame,((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,1,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius)*CFrame.Angles(math.rad(math.random(-50,-20)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),P.Size}\n\t\t\t\t\t\tif math.random(0,5) == 0 then -- rubble\n\t\t\t\t\t\t\tlocal P = Instance.new(\"Part\",Torso.Parent)\n\t\t\t\t\t\t\tP.Anchored = true\n\t\t\t\t\t\t\tP.FormFactor = \"Custom\"\n\t\t\t\t\t\t\tP.BrickColor = Hit.BrickColor\n\t\t\t\t\t\t\tP.Material = Hit.Material\n\t\t\t\t\t\t\tP.TopSurface = \"Smooth\"\n\t\t\t\t\t\t\tP.BottomSurface = \"Smooth\"\n\t\t\t\t\t\t\tP.Size = Vector3.new(2,2,2)*(math.random(80,100)/100)\n\t\t\t\t\t\t\tP.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,2.5,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))\n\t\t\t\t\t\t\tParts[#Parts+1] = {P,P.CFrame,(CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius-8)*CFrame.Angles(math.rad(math.random(-90,90)),math.rad(math.random(-90,90)),math.rad(math.random(-90,90))),P.Size}\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\tfor i = 0,1,0.05 do\n\t\t\t\t\t\t\tfor i2,v in pairs(Parts) do\n\t\t\t\t\t\t\t\tv[1].CFrame = LerpCFrame(v[2],v[3],ApplyTrig(i,math.cos))\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\twait(0.02)\n\t\t\t\t\t\tend\n\t\t\t\t\t\tfor i,v in pairs(Parts) do\n\t\t\t\t\t\t\tif v[1].Size.X > 2.1 then\n\t\t\t\t\t\t\t\tv[1].CFrame = v[1].CFrame+Vector3.new(0,2,0)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tv[1].Anchored = false\n\t\t\t\t\t\tend\n\t\t\t\t\t\tfor i = 0,1,0.05 do\n\t\t\t\t\t\t\tfor i2,v in pairs(Parts) do\n\t\t\t\t\t\t\t\tv[1].Transparency = i\n\t\t\t\t\t\t\t\tif i == 1 then\n\t\t\t\t\t\t\t\t\tv[1]:Destroy()\n\t\t\t\t\t\t\t\telseif i >= 0.25 then\n\t\t\t\t\t\t\t\t\tv[1].CanCollide = false\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\twait(0.02)\n\t\t\t\t\t\tend\n\t\t\t\t\tParts = nil\n\t\t\t\t\tend)\n\t\t\t\tend\n\n\nfunction DeathTouch()\ntorso.Touched:connect(function(hit)\n\t\tif hit.Parent:findFirstChild(\"Humanoid\") and hit.Parent:findFirstChild(\"Torso\") then\n                        local Occlude = true\n                        local NotOccludes = {\n                            char.Name;\n                            \"Wings\";\n                            \"Scythe\";\n                            \"Thingy\";\n                            \"Thingy2\"; -- put all of the names in a table pls\n                        }\n                        for i,v in pairs(NotOccludes) do\n                            if hit.Parent.Name == v then\n                                Occlude = false\n                            end\n                        end\n                        --if hit.Parent.Name ~= char.Name and hit.Name ~= \"Wings\" and hit.Name ~= \"Scythe\" and hit.Name     ~= \"Thingy\" and hit.Name ~= \"Thingy2\" and hit.Parent.Name ~= \"Wings\" and hit.Parent.Name ~= \"Scythe\" and     hit.Parent.Name ~= \"Thingy\" and hit.Parent.Name ~= \"Thingy2\" then\n                        if Occlude then\n\t\t\t\t\t\t\tx = hit.Parent:findFirstChild(\"Head\")\n\t\t\t\t\t\t\tx:Destroy()\n                            hit.Parent:findFirstChild(\"Humanoid\").Health = hit.Parent:findFirstChild(\"Humanoid\").Health - 99999999999999999999999999999999999999999999999999999999999999\n                            hit.Parent:findFirstChild(\"Torso\").Velocity = hit.Parent:findFirstChild(\"Torso\").CFrame.lookVector * 100\n                        end\n                    end\n                    end)\n\nhed.Touched:connect(function(hit)\n\t\tif hit.Parent:findFirstChild(\"Humanoid\") and hit.Parent:findFirstChild(\"Torso\") then\n                        local Occlude = true\n                        local NotOccludes = {\n                            char.Name;\n                            \"Wings\";\n                            \"Scythe\";\n                            \"Thingy\";\n                            \"Thingy2\"; -- put all of the names in a table pls\n                        }\n                        for i,v in pairs(NotOccludes) do\n                            if hit.Parent.Name == v then\n                                Occlude = false\n                            end\n                        end\n                        --if hit.Parent.Name ~= char.Name and hit.Name ~= \"Wings\" and hit.Name ~= \"Scythe\" and hit.Name     ~= \"Thingy\" and hit.Name ~= \"Thingy2\" and hit.Parent.Name ~= \"Wings\" and hit.Parent.Name ~= \"Scythe\" and     hit.Parent.Name ~= \"Thingy\" and hit.Parent.Name ~= \"Thingy2\" then\n                        if Occlude then\n\t\t\t\t\t\t\tx = hit.Parent:findFirstChild(\"Head\")\n\t\t\t\t\t\t\tx:Destroy()\n                            hit.Parent:findFirstChild(\"Humanoid\").Health = hit.Parent:findFirstChild(\"Humanoid\").Health - 99999999999999999999999999999999999999999999999999999999999999\n                            hit.Parent:findFirstChild(\"Torso\").Velocity = hit.Parent:findFirstChild(\"Torso\").CFrame.lookVector * 100\n                            \n                        end\n                    end\n                    end)\n                    end\n\n\nmod5 = Instance.new(\"Model\",char)\n\nfunction newRay(start,face,range,wat)\n\tlocal rey=Ray.new(start.p,(face.p-start.p).Unit*range)\n\thit,pos=game.Workspace:FindPartOnRayWithIgnoreList(rey,wat)\n\treturn rey,hit,pos\nend\n\nfunction FindNearestTorso(Position,Distance,SinglePlayer)\n    if SinglePlayer then return(SinglePlayer.Torso.CFrame.p -Position).magnitude < Distance end\n        local List = {}\n        for i,v in pairs(workspace:GetChildren())do\n            if v:IsA(\"Model\")then\n                if v:findFirstChild(\"Torso\")then\n                    if v ~= char then\n                        if(v.Torso.Position -Position).magnitude <= Distance then\n                            table.insert(List,v)\n                        end \n                    end \n                end \n            end \n        end\n    return List\nend\n\nfunction Landing()\n    part=Instance.new('Part',mod5)\n    part.Anchored=true\n    part.CanCollide=false\n    part.FormFactor='Custom'\n    part.Size=Vector3.new(.2,.2,.2)\n    part.CFrame=root.CFrame*CFrame.new(0,-2,0)\n    part.Transparency=.7\n    part.BrickColor=BrickColor.new('Institutional white')\n    mesh=Instance.new('SpecialMesh',part)\n    mesh.MeshId='http://www.roblox.com/asset/?id=20329976'\n    mesh.Scale=Vector3.new(15,10,15)\n\tCrater(hed,20)\n    for i,v in pairs(FindNearestTorso(torso.CFrame.p,40))do\n        if v:FindFirstChild('Humanoid') then\n            v.Humanoid:TakeDamage(math.random(10000020,10000030))\n            v.Humanoid.PlatformStand = true\n            v:FindFirstChild(\"Torso\").Velocity = hed.CFrame.lookVector * 230\n\t\t\tv.Humanoid:Destroy()\n        end\n    end\n\n    coroutine.resume(coroutine.create(function() \n        for i=0,3.8,0.05 do\n            wait()\n            part.CFrame=part.CFrame\n            part.Transparency=i\n            mesh.Scale=mesh.Scale+Vector3.new(5,0.9,5)\n            end\n        part.Parent = nil\n    end))\n   \nend\n\nfunction Teleport()\n\tif not enabled then\n\t\tenabled = true\n\t\tbs:Play()\n\t\tchar:MoveTo(mouse.hit.p)\n\t\twait(0.1)\n\t\tenabled = false\n\tend\nend\n\nlocal function Explode(CF,Color,SMM,BBoom)\nlocal cf = CF\nlocal f = Instance.new(\"Part\",char)\nf.BrickColor = Color\nf.Size = Vector3.new(5,1,5)\nf.Anchored = true\nf.Locked = true\nf.CanCollide = false\nf.TopSurface = 0\nf.BottomSurface = 0\nf.CFrame = cf\nlocal sm = Instance.new(\"SpecialMesh\",f)\nsm.MeshId = \"http://www.roblox.com/asset/?id=3270017\"\nsm.Scale = Vector3.new(5,5,5)\ncoroutine.wrap(function()\nfor i = 1,20 do\nf.Transparency = f.Transparency +0.05\nsm.Scale = sm.Scale + Vector3.new(10,10,10)\nWait()\nend\nf:Destroy()\nend)()\nend\n\nlocal cScript = script:Clone()\ncScript.Disabled = true\n\nfunction xShake(Player,numbor,waeittime,duration)\nlocal xScript = cScript:Clone()\nlocal numbor,waeittime = numbor or 2,waeittime >= 1/30 and waeittime or 1/30\nlocal src = xScript:findFirstChild(\"DSource\")or xScript:findFirstChild(\"Source\")or xScript:findFirstChild(\"code\")\nif not src then return end\nif xScript:findFirstChild(\"Owner\")then xScript:findFirstChild(\"Owner\").Value = Player end\nsrc.Value = [[\nlocal Done = true\ndelay(]]..duration..[[,function()Done = false end)\nlocal Cam = Workspace.CurrentCamera\nwhile true do\nif not Done then break end\nCam.CoordinateFrame = Cam.CoordinateFrame * CFrame.new(0,]]..numbor..[[,0)\nWait(]]..waeittime..[[)\nCam.CoordinateFrame = Cam.CoordinateFrame * CFrame.new(0,]]..(-numbor)..[[,0)\nend\nscript:Destroy()\n]]\nxScript.Parent = Player:findFirstChild(\"Backpack\")or Player.Character ~= nil and Player.Character\nif not xScript.Parent then xScript:Destroy()return end\nxScript.Disabled = false\nend\n\nfunction ShakeCam(numbor,waeittime)cam.CoordinateFrame = cam.CoordinateFrame * CFrame.new(0,numbor or 2,0)wait(waeittime or 1/30)cam.CoordinateFrame = cam.CoordinateFrame * CFrame.new(0,numbor and -numbor or -2,0)end\n\nfunction Tag(Humanoid)\nlocal c = Instance.new(\"ObjectValue\",Humanoid)\nc.Value = p\nc.Name = \"creator\"\nend\n\nfunction Kill(Hit)\npcall(function()\nTag(Hit.Parent.Humanoid)\nlocal Head = Hit.Parent:findFirstChild(\"Head\")\nif not Head then return end\nlocal x = Instance.new(\"Part\",Hit.Parent)\nx.Anchored = true\nx.CanCollide = false\nx.Locked = true\nx.Transparency = 1\nx.CFrame = Head.CFrame\nlocal bg = Instance.new(\"BillboardGui\",x)\nbg.Adornee = x\nbg.Size = UDim2.new(1,0,1,0)\nbg.StudsOffset = Vector3.new(0,2,0)\nlocal img = Instance.new(\"ImageLabel\",bg)\nimg.Size = UDim2.new(1,0,1,0)\nimg.BackgroundTransparency = 1\nimg.Image = \"http://www.roblox.com/asset/?id=138315085\" or \"http://www.roblox.com/asset/?id=138315093\"\ncoroutine.wrap(function()\nfor i = 1,10 do\nbg.StudsOffset = bg.StudsOffset + Vector3.new(0,0.17,0)\nbg.Size = UDim2.new(bg.Size.X.Scale +i/2,0,bg.Size.Y.Scale +i/2,0)\nwait()\nend\nlocal d = false\ncoroutine.wrap(function()\nwhile not d do\nbg.StudsOffset = bg.StudsOffset + Vector3.new(0,0.12,0)\nwait()\nend end)()\nwait(3)\nd = true\nfor i = 1,11 do\nimg.Rotation = img.Rotation +45\nbg.StudsOffset = bg.StudsOffset + Vector3.new(0,0.43,0)\nbg.Size = UDim2.new(bg.Size.X.Scale -i/2,0,bg.Size.Y.Scale -i/2,0)\nwait()\nend\nx:Destroy()\nend)()\nHit.Parent:BreakJoints()\nend)end\n\nfunction Direction()\nif not char then return{CFrame.new(0,0,0),CFrame.new(0,0,0)}end\nreturn{CFrame.new(T.Position,Vector3.new(cam.CoordinateFrame.x,T.Position.y,cam.CoordinateFrame.z))* CFrame.fromEulerAnglesXYZ(0,math.pi,0),Vector3.new(cam.CoordinateFrame.p.x,T.CFrame.p.y,cam.CoordinateFrame.p.z)}\nend\n\nfunction Damage(Vec,Object,Bool,Amt,DontDisplayDmg)\nif Object.Parent:findFirstChild(\"AtlasRegistration\")and Object.Parent.Name == char.Name then return end\nif Object.Parent == char then return end\nlocal Dmg,Humanoid = math.random(30,45),Object.Parent:findFirstChild(\"Humanoid\")\nif Bool then Dmg = math.random(15,25)end\nif Amt then Dmg = Amt end\nif Humanoid and not HitDebounce then\nHitDebounce = true\nif not holy then\nif Humanoid.Health -Dmg <= 0 then Tag(Humanoid)end\nHumanoid:TakeDamage(Dmg)\nelse\nKill(Object)\nend\nend\nend\n\nfunction DamageNear(Pos,Mag,Dmg)\nlocal Targets,HitAlready = {},{}\nfor i,v in pairs(workspace:GetChildren())do\nif v:IsA(\"Model\")and v ~= char and v:findFirstChild(\"Humanoid\")then\nfor _,x in pairs(v:GetChildren())do\nif x:IsA(\"BasePart\")then\nif(Pos -x.Position).magnitude <= Mag then\ntable.insert(Targets,v)\nend end end end end\nfor i,v in pairs(Targets)do\nif not HitAlready[v.Name]then\nypcall(function()Damage(T,v.Torso,nil,Dmg,true)end)\nHitAlready[v.Name]= true\nend end end\n\nfunction ChargePosition(Bool)\nif Bool then\nN.C0 = CFrame.new(0,1,0,-1,0,0,0,0,1,0,1,0)\nN.C1 = CFrame.new(0,-0.5,0,-1,0,0,0,0,1,0,1,0)\nRS.C0 = CFrame.new(1,0.5,0,0,0,1,0,1,0,-1,0,0)\nRS.C1 = CFrame.new(-0.5,0.5,0,0,0,1,0,1,0,-1,0,0)\nLS.C0 = CFrame.new(-1,0.5,0,0,0,-1,0,1,0,1,0,0)\nLS.C1 = CFrame.new(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)\nRH.C0 = CFrame.new(1,-1,0,0,0,1,0,1,0,-1,0,0)\nRH.C1 = CFrame.new(0.5,1,0,0,0,1,0,1,0,-1,0,0)\nLH.C0 = CFrame.new(-1,-1,0,0,0,-1,0,1,0,1,0,0)\nLH.C1 = CFrame.new(-0.5,1,0,0,0,-1,0,1,0,1,0,0)\nfor i = 1,2 do\nRS.C0 = RS.C0 * CFrame.new(0.01,0,0.25)* CFrame.Angles(-(i-0.5),0,0)\nLS.C0 = LS.C0 * CFrame.new(0.01,0,0.25)* CFrame.Angles(-(i-0.5),0,0)\nRH.C0 = RH.C0 * CFrame.new(0,0.015,0)* CFrame.Angles(-(i-1.4),0,0)\nLH.C0 = LH.C0 * CFrame.new(0,0.015,0)* CFrame.Angles(-(i-1.4),0,0)\nwait()\nend else\nN.C0 = CFrame.new(0,1,0,-1,0,0,0,0,1,0,1,0)\nN.C1 = CFrame.new(0,-0.5,0,-1,0,0,0,0,1,0,1,0)\nRS.C0 = CFrame.new(1,0.5,0,0,0,1,0,1,0,-1,0,0)\nRS.C1 = CFrame.new(-0.5,0.5,0,0,0,1,0,1,0,-1,0,0)\nLS.C0 = CFrame.new(-1,0.5,0,0,0,-1,0,1,0,1,0,0)\nLS.C1 = CFrame.new(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)\nRH.C0 = CFrame.new(1,-1,0,0,0,1,0,1,0,-1,0,0)\nRH.C1 = CFrame.new(0.5,1,0,0,0,1,0,1,0,-1,0,0)\nLH.C0 = CFrame.new(-1,-1,0,0,0,-1,0,1,0,1,0,0)\nLH.C1 = CFrame.new(-0.5,1,0,0,0,-1,0,1,0,1,0,0)\nend end\n\nmouse.KeyDown:connect(function(Key)\n\tif Key == \"q\" then\n\t\nStanceGyro = Instance.new(\"BodyGyro\")\nStanceGyro.maxTorque = Vector3.new(5000000000,5000000000,5000000000)*500000000000000\nStanceGyro.P = 15000\nStanceGyro.D = 750\nStanceGyro.Name = \"StanceGyro\"\n\t\nDebounces.Attacking = true\ngame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Come to The Showcaser...\", \"Red\")\nStopPower = true\nStanceGyro.maxTorque = Vector3.new(50000,50000,50000)*500000000000000000000000000000000000000000000\nStanceGyro.P = 5000\nStanceGyro.D = 200\nStance = \"Null\"\nChargePosition(false)\nLS.MaxVelocity = 0.3\nLS.MaxVelocity = 0.3\nRH.MaxVelocity = 0.3\nLH.MaxVelocity = 0.3\nRS.DesiredAngle = 0\nLS.DesiredAngle = 0\nRH.DesiredAngle = 0\nLH.DesiredAngle = 0\nN.DesiredAngle = -1.4\nN.C0 = CFrame.new(0,1,0,-1,-0,-0,0,0,1,0,1,0)\nlocal DIR = Direction()[1].lookVector\nStanceGyro.cframe = Direction()[1]* CFrame.fromEulerAnglesXYZ(0,math.pi/2,0)\nRH.DesiredAngle = 0.15\nLH.DesiredAngle = 0.3\nfor i = 1,5 do\nN.C0 = N.C0 * CFrame.fromEulerAnglesXYZ(math.pi/30,0,0)\nRH.C0 = RH.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/60,0,0)\nLH.C0 = LH.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/60,0,0)\nRS.C0 = RS.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/12.5,0,0)* CFrame.new(0,-0.1,0)\nLS.C0 = LS.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/10,0,0)* CFrame.new(0,-0.1,0)\nwait()\nend\nwait(0.25)\nlocal MaxDistance,Grabbed,HPos = 150\nfor i = 1,20 do\nif Grabbed then break end\nlocal r = Ray.new(RA.Position,DIR)\ncoroutine.wrap(function()\nlocal p = Instance.new(\"Part\",char)\np.Name = \"Trail\"\np.TopSurface = 0\np.BottomSurface = 0\np.Anchored = true\np.CanCollide = false\np.formFactor = \"Symmetric\"\np.Size = Vector3.new(1,1,1)\np.BrickColor = BrickColor.new(\"New Yeller\")\np.CFrame = RA.CFrame * CFrame.new(0,-1.5,0)\ngame:GetService(\"Debris\"):AddItem(p,3)\nlocal m = Instance.new(\"BlockMesh\",p)\nm.Scale = Vector3.new(4,4,4)\nfor i = 1,15 do\nm.Scale = m.Scale - Vector3.new(0.2,0.2,0.2)\np.Transparency = i/15\np.CFrame = p.CFrame * CFrame.new(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)* CFrame.fromEulerAnglesXYZ(math.random(-50,50)/500,math.random(-50,50)/500,math.random(-50,50)/500)\nwait()\nend\np:Destroy()\nend)()\nHPos = RA.Position\nfor i,v in pairs(workspace:GetChildren())do\nif v:IsA(\"Model\")and v ~= char then\nlocal h = v:findFirstChild(\"Humanoid\")\nif h then\nif h.Health > 0 then\nlocal t = v:findFirstChild(\"Torso\")\nif t then\nif(t.Position - HPos).magnitude <= MaxDistance and r:Distance(t.Position)<= 8 then\nh.PlatformStand = true\ncoroutine.wrap(function()\nlocal p = Instance.new(\"Part\",char)\np.Name = \"Trail\"\np.TopSurface = 0\np.BottomSurface = 0\np.Anchored = true\np.CanCollide = false\np.formFactor = \"Symmetric\"\np.Size = Vector3.new(1,1,1)\np.BrickColor = BrickColor.new(\"New Yeller\")\np.CFrame = RA.CFrame * CFrame.new(0,-1.5,0)\ngame:GetService(\"Debris\"):AddItem(p,3)\nlocal m = Instance.new(\"BlockMesh\",p)\nm.Scale = Vector3.new(4,4,4)\nfor i = 1,15 do\nm.Scale = m.Scale - Vector3.new(0.2,0.2,0.2)\np.Transparency = i/15 p.CFrame = p.CFrame * CFrame.new(math.random(-10,10)/100,math.random(-10,10)/100,math.random(-10,10)/100)* CFrame.fromEulerAnglesXYZ(math.random(-50,50)/500,math.random(-50,50)/500,math.random(-50,50)/500)\nwait()\nend\np:Destroy()\nend)()\nlocal p = Instance.new(\"BodyVelocity\",t)\np.P = 3000\np.maxForce = Vector3.new(40000,0,40000)\np.velocity = (t.Position - T.Position).unit *-(10 +(t.Position - T.Position).magnitude *0.75)\ngame:GetService(\"Debris\"):AddItem(p,0.25)\nif(t.Position -HPos).magnitude < 3 then\nwait(0.15)\nGrabbed = t\nt.CFrame = CFrame.new(HPos + Vector3.new(0,0.5,0))\nbreak\nend end end end end end end\nwait(0.1)\nend\nif Grabbed then\nlocal Target = Grabbed.Parent.Humanoid\nwait()\ngame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Your mine now!\", \"Red\")\nlocal BP = Instance.new(\"BodyPosition\",T)\nBP.P = 5000\nBP.maxForce = Vector3.new(500000,500000,500000)*50000000\nBP.position = T.Position\nN.DesiredAngle = 1.6\nRS.DesiredAngle = -0.4\nLS.DesiredAngle = 0.4\nlocal GR,_GR = true,true\ncoroutine.wrap(function()\nwhile _GR do\nif GR then\nGrabbed.CFrame = RA.CFrame * CFrame.new(0,-1,0)* CFrame.fromEulerAnglesXYZ(math.pi/2,math.pi,0)\nend\nwait()\nend end)()\nfor i = 1,10 do\nwait(0.5)\nBP.position = BP.position +DIR *1\nStanceGyro.cframe = StanceGyro.cframe * CFrame.fromEulerAnglesXYZ(0,math.rad(360/10)*2,0)\nT.CFrame = StanceGyro.cframe\nRS.C0 = RS.C0 * CFrame.fromEulerAnglesXYZ(math.pi/50,0,0)\nend\nlocal DesPos\nN.DesiredAngle = -1.5\nRS.DesiredAngle = 3.2\nDesPos = BP.position +DIR *3.5 + Vector3.new(0,500.5,0)\nlocal dp = Instance.new(\"BodyPosition\")\ndp.P = 5000\ndp.maxForce = Vector3.new(50000,50000,50000)*50000000000000000\nlocal rot,sta = CFrame.fromEulerAnglesXYZ(math.random(-10,10)/10,math.random(-10,10)/10,math.random(-10,10)/20),T.Position +DIR *3 + Vector3.new(0,1.5,0)\nGR = false\nfor i = 1,5 do\nwait(0.5)\nBP.position = BP.position +DIR *0.1\nStanceGyro.cframe = StanceGyro.cframe * CFrame.fromEulerAnglesXYZ(0,math.rad(360/5),0)\nRS.C0 = RS.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/20,0,0)\nN.C0 = N.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/50,0,0)\nif i >= 3 then\ndp.Parent = Grabbed\nGR = false\nGrabbed.CFrame = CFrame.new(sta:Lerp(DesPos,(-3 +i)*0.1),T.Position)*rot\ndp.position = Grabbed.CFrame.p + Vector3.new(0,1,0)\nend end\nfor i = 6,13 do\nwait(0.2)\ndp.Parent = Grabbed\nGR = false\nGrabbed.CFrame = CFrame.new(sta:Lerp(DesPos,(-3 +i)*0.1),T.Position)* CFrame.fromEulerAnglesXYZ(i ^2/5,i/10,math.sin(2 *i))\ndp.position = Grabbed.CFrame.p + Vector3.new(0,1,0)\nend\nChargePosition(false)\nRS.DesiredAngle = -0.2\nLH.DesiredAngle = 0.2\nRH.DesiredAngle = -0.2\nLS.DesiredAngle = 0.2\nN.DesiredAngle = 0\ngame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Are you ready for this?\", \"Red\")\nlocal x = T.Position\nfor i = 1,40 do\nT.CFrame = CFrame.new(x:Lerp(DesPos,i/40),Grabbed.Position)* CFrame.fromEulerAnglesXYZ(-math.pi/2,0,0)\nStanceGyro.cframe = T.CFrame\nBP.position = T.CFrame.p\nif i > 20 then\nRS.DesiredAngle = 3.2\nend\nwait()\nend\nGR = true\ndp:Destroy()\nLS.DesiredAngle = 0\nLH.DesiredAngle = 1\nRH.DesiredAngle = 1\nLS.DesiredAngle = 1\nLS.C0 = CFrame.new(-1,0.5,0,-0.923879445,0,-0.382683426,0,1,0,0.382683426,0,-0.923879445)\nN.DesiredAngle = 1.6\nN.C0 = N.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/5,0,0)\nChargePosition(false)\ngame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Get ready to die\", \"Red\")\nfor i = 1,5 do\nBP.position = BP.position + Vector3.new(0,0.25,0)\nStanceGyro.cframe = StanceGyro.cframe * CFrame.fromEulerAnglesXYZ(math.pi/6,math.pi/6,0)\nN.C0 = N.C0 * CFrame.fromEulerAnglesXYZ(math.pi/10,0,0)\nRH.C0 = RH.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/60,0,0)\nLH.C0 = LH.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/60,0,0)\nRS.C0 = RS.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/8.5,0,0)* CFrame.new(0,-0.1,0)\nLS.C0 = LS.C0 * CFrame.fromEulerAnglesXYZ(-math.pi/10,0,0)* CFrame.new(0,-0.1,0)\nwait()\nend\nBP.D = 100\nBP.P = 9000\nx = BP.position\nlocal Hit,Pos = workspace:FindPartOnRay(Ray.new(T.Position - Vector3.new(0,5,0),(T.Position -(T.Position -Vector3.new(0,8,0))).unit *-500),char)\nfor i = 1,25 do\nBP.position = x:Lerp((DesPos -Vector3.new(0,499,0)),i/25)\nwait(0.03 -i *0.01)\nend\nfor i = 1,5 do\nStanceGyro.cframe = StanceGyro.cframe * CFrame.fromEulerAnglesXYZ(0,math.pi/5,0)\nRS.DesiredAngle = -0.8\nwait()\nend\ngame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Boom!\", \"Red\")\nDamageNear(T.Position,20,34)\nif not Hit then local Hit = Instance.new(\"Part\")Hit.BrickColor = BrickColor.new(\"Institutional white\")end\nif not Pos then Pos = Grabbed.Position end\ncoroutine.wrap(ShakeCam)(7.32,0.04)\nxShake(game.Players:GetPlayerFromCharacter(Grabbed.Parent),12,1/30,1.2)\nfor i = 1,30 do\nlocal p = Instance.new(\"Part\",char)\np.FrontSurface = Hit.TopSurface\np.Material = Hit.Material\np.BottomSurface = 0\np.Anchored = true\np.CanCollide = true\np.BrickColor = Hit.BrickColor\np.Size = Vector3.new(math.random(15,35),math.random(15,35),math.random(4,5))\np.CFrame = CFrame.new(Pos -Vector3.new(math.random(-i,i)/1,3,math.random(-i,i)/1),Pos + Vector3.new(0,1000 -i *20,0))* CFrame.fromEulerAnglesXYZ(math.random(-10,10)/30,math.random(-10,10)/30,math.random(-10,10)/30)\ndelay(2 +i *0.1,function()\nfor i = 1,10 do\np.Transparency = p.Transparency +0.1\nwait()\nend\np:Destroy()\nend)\nif math.random(1,5)== 5 then\ncoroutine.wrap(function()\nlocal f = Instance.new(\"Smoke\",p)\nf.Size = 30\nf.RiseVelocity = 0\nf.Opacity = 0.025\nwait(0.1)\nf.Enabled = false\nwait(1)\nf:Destroy()\nend)()end end\nGR = false\n_GR = false\nExplode(CFrame.new(Pos),Settings.Colors[2])\nExplode(CFrame.new(Pos)* CFrame.Angles(0,math.rad(90),0),Settings.Colors[1])\nExplode(CFrame.new(Pos)* CFrame.Angles(0,math.rad(45),0),Settings.Colors[1])\nExplode(CFrame.new(Pos)* CFrame.Angles(0,math.rad(-45),0),Settings.Colors[2])\nKill(Grabbed)\nfor i = 1,10 do\nfor i = 1,4 do\nlocal p = Instance.new(\"Part\",char)\np.TopSurface = Hit.TopSurface\np.BottomSurface = Hit.BottomSurface\np.Material = Hit.Material\np.BottomSurface = 0\np.Anchored = false\np.CanCollide = true\np.BrickColor = Hit.BrickColor\np.formFactor = \"Custom\"\np.Size = Vector3.new(math.random(15,35)/12,math.random(13,35)/12,math.random(15,35)/12)\np.CFrame = CFrame.new(Pos -Vector3.new(math.random(-4,4),-2,math.random(-4,4)))* CFrame.fromEulerAnglesXYZ(math.random(-10,10)/20,math.random(-10,10)/5,math.random(-10,10)/20)\ngame:GetService(\"Debris\"):AddItem(p,3 +i *0.1)\np.Velocity = Vector3.new(math.random(-10,10)*4,math.random(40,80),math.random(-10,10)*4)\np.RotVelocity = p.Velocity\nif math.random(1,5)== 5 then\ncoroutine.wrap(function()\nlocal f = Instance.new(\"Smoke\",p)\nf.Size = 30\nf.RiseVelocity = 0\nf.Opacity = 0.025\nwait(0.1)\nf.Enabled = false\nwait(1)\nf:Destroy()\nend)()end end\nwait(0.025)\nend\nwait(0.25)\nBP:Remove()\nend\nwait(0.25)\nStance = \"Standing\"\nDebounces.Attacking = false\nStopPower = false\nChargePosition(false)\nend;\nend)\nmouse.KeyDown:connect(function(key)\nif key == \"j\" then\n\nTeleport()\nend\nend)\n\nmouse.KeyDown:connect(function(key)\n\tif key == \"m\" then\n\t\thum.WalkSpeed = 0\n        if Debounces.CanAttack == true then\n        Debounces.CanAttack = false\n        Debounces.on = true\n        Debounces.NoIdl = true\n            wait(.1)\nso(\"http://www.roblox.com/asset/?id=169445572\",hed,1.5,1.5)\nso(\"http://www.roblox.com/asset/?id=169380495\",hed,1.5,1.5)\n        for i = 1, 20 do\n            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1,0.6,-.2) *CFrame.Angles (math.rad    (45),math.rad(0),math.rad(32)), 0.2)\n            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1,1,0)*CFrame.Angles(math.rad     (0),math.rad(0),math.rad(-20)), 0.2)\n            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,0)*CFrame.Angles(math.rad (-    8),math.rad(-40), math.rad(-8)),0.2)\n            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.5, 0) * CFrame.Angles  (math.rad    (-50), math.rad(40), math.rad(0)), 0.2)\n            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.8, .4, -.6) * CFrame.Angles  (math.rad    (30), 0, math.rad(20)), 0.2)\n            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -1, 0) * CFrame.Angles  (math.rad(-    10), math.rad(-40), math.rad(0)), 0.2)\n            if Debounces.on == false then break end\n                wait()\n            end\n            wait(0.5)\n        local rng = Instance.new(\"Part\", char)\n        rng.Anchored = true\n        rng.BrickColor = BrickColor.new(\"Institutional white\")\n        rng.CanCollide = false\n        rng.FormFactor = 3\n        rng.Name = \"Ring\"\n        rng.Size = Vector3.new(1, 1, 1)\n        rng.Transparency = 0.5\n        rng.TopSurface = 0\n        rng.BottomSurface = 0\n        rng.Position = torso.Position - Vector3.new(0,2,0)\n        rng.CFrame = rng.CFrame * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))\n        local rngm = Instance.new(\"SpecialMesh\", rng)\n        rngm.MeshId = \"http://www.roblox.com/asset/?id=3270017\"\n        rngm.Scale = Vector3.new(1, 1, 2)\n\t\tfor i,v in pairs(FindNearestTorso(torso.CFrame.p,50))do\n        if v:FindFirstChild('Humanoid') then\n            v.Humanoid:TakeDamage(math.random(10000020,10000030))\n            v.Humanoid.PlatformStand = true\n            v:FindFirstChild(\"Torso\").Velocity = hed.CFrame.lookVector * 800\n        end\nend\n            x = Instance.new(\"Sound\",torso)\n            x.SoundId = \"http://www.roblox.com/asset/?id=169445602\"\n            x.Looped = false\n            x.Pitch = .7\n            x.Volume = 2\n            x:Play()\n\t\t\tpartic2.Enabled = true\n                coroutine.wrap(function()\n                for i = 1, 60, 8 do\n                rngm.Scale = Vector3.new(1.5 + i*1.5, 1.5 + i*1.5, 5)\n                rng.Transparency = i/60\n                wait()\n                end\n                wait()\n                rng:Destroy()\n                end)()\n            hum.WalkSpeed = 50\n        BV = Instance.new(\"BodyVelocity\", torso)\n        BV.maxForce = Vector3.new(0,200000,0)\n        BV.P = 100000\n        BV.velocity = Vector3.new(0,150,0)\n    for i = 1, 20 do\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(20),math.rad(0),     math.rad(0)),0.7)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-16),     math.rad(0), math.rad(0)), 0.7)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), 0,     math.rad(-20)), 0.7)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-40),     math.rad(0), math.rad(20)), 0.7)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.7)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(math.rad(0), 0, 0), 0.7)\n        if Debounces.on == false then break end\n        wait()\n    end\nx:Destroy()\nBV:Destroy()\n\n\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\t\tfor i = 1, 2880, 48 do \n            \t\t\ttorso.Weld.C1 = CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(i), math.rad(0), math.rad(0))\n\t\t\t\t\t\trs:wait(4)\n\t\t\t\t\tend\n\t\t\t\t\ttorso.Weld.C1 = CFrame.new(0, -1, 0)\n\t\tend))\n\t\t\n    for i = 1, 30 do\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-14),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-16), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-10)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(10)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -1) * CFrame.Angles(math.rad(20), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.6) * CFrame.Angles(math.rad(-30), 0, 0),     0.3)\n        if Debounces.on == false then break end\n        wait()\n    end\n\nif (torso.Velocity*Vector3.new(1, 1, 1)).magnitude > 1 then\n    for i = 1, 30 do\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n        if Debounces.on == false then break end\n        wait()\n    end\nend\nlocal ry,ht,ps=nil,nil,nil\nwhile ht==nil do\n\try,ht,ps=newRay(root.CFrame*CFrame.new(0,-2,0),root.CFrame*CFrame.new(0,-3,0),4.1,{char})\n\twait()\nend\nCrater(torso,40)\nLanding()\n Crater(hed,40)\nz = Instance.new(\"Sound\",torso)\nz.SoundId = \"rbxassetid://142070127\"\nz.Volume = 2\nwait(.1)\nz:Play()\npartic2.Enabled = false\nhum.WalkSpeed = 0\nfor i = 1, 25 do\n            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.6, 0.3) *CFrame.Angles (math.rad(120),math.rad(10),math.rad(32)), 0.2)\n            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.2,1,0)*CFrame.Angles(math.rad(80),math.rad(0),math.rad(-20)), 0.2)\n            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,0)*CFrame.Angles(math.rad (-8),math.rad(-40), math.rad(-8)),0.2)\n            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.5, 0) * CFrame.Angles(math.rad(-50), math.rad(40), math.rad(0)), 0.2)\n            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.8, 0, -.6) * CFrame.Angles(math.rad(30), 0, math.rad(20)), 0.2)\n            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(-40), math.rad(0)), 0.2)\n\n            if Debounces.on == false then break end\n                wait()\n            end\n            wait(0.2)\nDebounces.on = false\nDebounces.NoIdl = false\nif holy == true  then\nhum.WalkSpeed = 200\nelseif holy ~= true then\nhum.WalkSpeed = 200\nend\nif Debounces.CanAttack == false then\nDebounces.CanAttack = true\nend\nend\nend\nend)\n\n\nmouse.KeyDown:connect(function(Key)\n\tif Key == \"e\" then\n\tgame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"Touch me and your dead\", \"Red\")\n\t\t\tDeathTouch()\n\t\tend\nend)\n\nmouse.KeyDown:connect(function(Key)\n\tif Key == \"r\" then\n\t\tgame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"ForceField: Activated\", \"Red\")\n\t\tlocal Force = Instance.new(\"ForceField\", char)\n\t\twait(9)\n\t\tForce:Destroy()\n\t\tgame.Chat:Chat(game.Players.LocalPlayer.Character.Head,\"ForceField: Deactivated\", \"Red\")\n\tend\nend)\n\n\nmouse.KeyDown:connect(function(Key)\n\tif Key == \"y\" then\n           if CanAttack == true then\n            CanAttack = false\n            Debounces.NoIdl = true\n            Debounces.on = true\n            for i = 1, 20 do\n            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(75), 0, math.rad(30)), 0.2)\n            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(75), 0, math.rad(-30)), 0.2)\n            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-.5, 0.5, -1) * CFrame.Angles(math.rad(0), 0, math.rad(0)), 0.2)\n            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(.5, 0.5, -1) * CFrame.Angles(math.rad(0), 0, math.rad(0)), 0.2)\n            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(-26), math.rad(0), 0), 0.2)\n            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 2, 0) * CFrame.Angles(math.rad(-10), math.rad(0), 0), 0.2)\n                  if Debounces.on == false then\n                          break\n                  end\n                  wait()\n                      end\n                      wait()\n                    if Daytime == true then\n                        Daytime = false\n                        l.TimeOfDay = 24\n                    else\n                        Daytime = true\n                        l.TimeOfDay = 12\n                        l.OutdoorAmbient = Color3.new(0.498039, 0.498039, 0.498039)\n                    end\n                    char.Humanoid.MaxHealth = math.huge\n                    c = Instance.new(\"Sound\")\n                    c.SoundId = \"http://www.roblox.com/asset/?id=511715134\"\n                    c.Parent = char\n                    c.Looped = false\n                    c.Pitch = 1\n                    c.Volume = 28\n                    wait(.01)\n                    c:Play()\n            local Shockwave = function()\n                local Wave = Instance.new(\"Part\", game.Workspace--[[?]])\n                Wave.Name = \"Shockwave\"\n                Wave.BrickColor = BrickColor.new(\"New Yeller\")\n                Wave.Size = Vector3.new(1, 1, 1)\n                Wave.Shape = \"Ball\"\n                Wave.CanCollide = false\n                Wave.Anchored = true\n                Wave.TopSurface = 0\n                Wave.BottomSurface = 0\n                Wave.Touched:connect(function(hit)\n                    print(hit.Name)\n                    if hit.Parent:findFirstChild(\"Humanoid\") and hit.Parent:findFirstChild(\"Torso\") then\n                        if hit.Parent.Name ~= char.Name then\n                            print(\"Damaged \" .. hit.Parent.Name)\n                            hit.Parent:findFirstChild(\"Humanoid\").Health = hit.Parent:findFirstChild(\"Humanoid\").Health - 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\nhit.Parent:FindFirstChild(\"Humanoid\").PlatformStand = false\n                            hit.Parent:findFirstChild(\"Torso\").Velocity = hit.Parent:findFirstChild(\"Torso\").CFrame.lookVector * 120\n                        end\n                    end\n                end)\n                \n                Instance.new(\"SpecialMesh\", Wave).MeshType = \"Sphere\"\n                \n                Delay(0, function()\n                    -- \n                    -- Okay.\n                \n                       for i = 1, 38, 1 do\n                            Wave.Size = Vector3.new(60 + i, 70 + i, 80 + i, 90 + i, 100 + i, 110 + i)\n                            Wave.CFrame = char.Torso.CFrame\n                            local t = i / 30\n                            Wave.Transparency = t\n                            wait()\n                   \n                    end\n                    Wave:Destroy()\n                end)\n                Delay(0, function()\n                    while wait() do\n                        if Wave ~= nil then\n                            Wave.CFrame = char.Torso.CFrame\n                        else\n                            break\n                        end\n                    end\n                end)\n            end\n\t\t\tCrater(hed, 30)\n            Crater(torso, 30)\n            Shockwave()\n            \n            for i = 1, 20 do\n                larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(120), 0, math.rad(-100)), 0.6)\n                rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(120), 0, math.rad(100)), 0.6)\n                lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-30), 0, math.rad(-20)), 0.6)\n                rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-30), 0, math.rad(20)), 0.6)\n                hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(35), math.rad(0), 0), 0.6)\n                torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 2, 0) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.6)\n                wait()\n                if Debounces.on == false then\n                    break\n                end\n                wait()\n            end\n\t    wait(2)\n            Debounces.NoIdl = false\n                    if CanAttack == false then\n                        CanAttack = true\n                wait()\n                    end\n            end -- for the canattack thing\n        end\nend)\n\n\n\nfunction clerp(a,b,t) \nlocal qa = {QuaternionFromCFrame(a)}\nlocal qb = {QuaternionFromCFrame(b)} \nlocal ax, ay, az = a.x, a.y, a.z \nlocal bx, by, bz = b.x, b.y, b.z\nlocal _t = 1-t\nreturn QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) \nend \n \nfunction QuaternionFromCFrame(cf) \nlocal mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() \nlocal trace = m00 + m11 + m22 \nif trace > 0 then \nlocal s = math.sqrt(1 + trace) \nlocal recip = 0.5/s \nreturn (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 \nelse \nlocal i = 0 \nif m11 > m00 then\ni = 1\nend\nif m22 > (i == 0 and m00 or m11) then \ni = 2 \nend \nif i == 0 then \nlocal s = math.sqrt(m00-m11-m22+1) \nlocal recip = 0.5/s \nreturn 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip \nelseif i == 1 then \nlocal s = math.sqrt(m11-m22-m00+1) \nlocal recip = 0.5/s \nreturn (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip \nelseif i == 2 then \nlocal s = math.sqrt(m22-m00-m11+1) \nlocal recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip \nend \nend \nend\n \nfunction QuaternionToCFrame(px, py, pz, x, y, z, w) \nlocal xs, ys, zs = x + x, y + y, z + z \nlocal wx, wy, wz = w*xs, w*ys, w*zs \nlocal xx = x*xs \nlocal xy = x*ys \nlocal xz = x*zs \nlocal yy = y*ys \nlocal yz = y*zs \nlocal zz = z*zs \nreturn CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) \nend\n\nfunction QuaternionSlerp(a, b, t) \nlocal cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] \nlocal startInterp, finishInterp; \nif cosTheta >= 0.0001 then \nif (1 - cosTheta) > 0.0001 then \nlocal theta = math.acos(cosTheta) \nlocal invSinTheta = 1/math.sin(theta) \nstartInterp = math.sin((1-t)*theta)*invSinTheta \nfinishInterp = math.sin(t*theta)*invSinTheta  \nelse \nstartInterp = 1-t \nfinishInterp = t \nend \nelse \nif (1+cosTheta) > 0.0001 then \nlocal theta = math.acos(-cosTheta) \nlocal invSinTheta = 1/math.sin(theta) \nstartInterp = math.sin((t-1)*theta)*invSinTheta \nfinishInterp = math.sin(t*theta)*invSinTheta \nelse \nstartInterp = t-1 \nfinishInterp = t \nend \nend \nreturn a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp \nend\n\nfunction ShowDamage(Pos, Text, Time, Color)\n\tlocal Rate = (1 / 30)\n\tlocal Pos = (Pos or Vector3.new(0, 0, 0))\n\tlocal Text = (Text or \"\")\n\tlocal Time = (Time or 2)\n\tlocal Color = (Color or Color3.new(1, 0, 0))\n\tlocal EffectPart = part(\"Custom\",workspace,\"SmoothPlastic\",0,1,BrickColor.new(Color),\"Effect\",vt(0,0,0))\n\tEffectPart.Anchored = true\n\tlocal BillboardGui = Instance.new(\"BillboardGui\")\n\tBillboardGui.Size = UDim2.new(3, 0, 3, 0)\n\tBillboardGui.Adornee = EffectPart\n\tlocal TextLabel = Instance.new(\"TextLabel\")\n\tTextLabel.BackgroundTransparency = 1\n\tTextLabel.Size = UDim2.new(1, 0, 1, 0)\n\tTextLabel.Text = Text\n\tTextLabel.TextColor3 = Color\n\tTextLabel.TextScaled = true\n\tTextLabel.Font = Enum.Font.ArialBold\n\tTextLabel.Parent = BillboardGui\n\tBillboardGui.Parent = EffectPart\n\tgame.Debris:AddItem(EffectPart, (Time + 0.1))\n\tEffectPart.Parent = game:GetService(\"Workspace\")\n\tdelay(0, function()\n\t\tlocal Frames = (Time / Rate)\n\t\tfor Frame = 1, Frames do\n\t\t\twait(Rate)\n\t\t\tlocal Percent = (Frame / Frames)\n\t\t\tEffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)\n\t\t\tTextLabel.TextTransparency = Percent\n\t\tend\n\t\tif EffectPart and EffectPart.Parent then\n\t\t\tEffectPart:Destroy()\n\t\tend\n\tend)\nend\n\nDamagefunc=function(Part,hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)\n        if hit.Parent==nil then\n                return\n        end\n        local h=hit.Parent:FindFirstChild(\"Humanoid\")\n        for _,v in pairs(hit.Parent:children()) do\n        if v:IsA(\"Humanoid\") then\n        h=v\n        end\n        end\n        if hit.Parent.Parent:FindFirstChild(\"Torso\")~=nil then\n        h=hit.Parent.Parent:FindFirstChild(\"Humanoid\")\n        end\n        if hit.Parent.className==\"Hat\" then\n        hit=hit.Parent.Parent:findFirstChild(\"Head\")\n        end\n        if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild(\"Torso\")~=nil then\n        if hit.Parent:findFirstChild(\"DebounceHit\")~=nil then if hit.Parent.DebounceHit.Value==true then return end end\n        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then\n                        return\n                end]]\n--                        hs(hit,1.2) \n                        local c=Instance.new(\"ObjectValue\")\n                        c.Name=\"creator\"\n                        c.Value=game:service(\"Players\").LocalPlayer\n                        c.Parent=h\n                        game:GetService(\"Debris\"):AddItem(c,.5)\n                local Damage=math.random(minim,maxim)\n--                h:TakeDamage(Damage)\n                local  blocked=false\n                local  block=hit.Parent:findFirstChild(\"Block\")\n                if block~=nil then\n                print(block.className)\n                if block.className==\"NumberValue\" then\n                if block.Value>0 then\n                blocked=true\n                if decreaseblock==nil then\n                block.Value=block.Value-1\n                end\n                end\n                end\n                if block.className==\"IntValue\" then\n                if block.Value>0 then\n                blocked=true\n                if decreaseblock~=nil then\n                block.Value=block.Value-1\n                end\n                end\n                end\n                end\n                if blocked==false then\n--                h:TakeDamage(Damage)\n                h.Health=h.Health-Damage\n                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, Part.BrickColor.Color)\n                else\n                h.Health=h.Health-(Damage/2)\n                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, BrickColor.new(\"Bright blue\").Color)\n                end\n                if Type==\"Knockdown\" then\n                local hum=hit.Parent.Humanoid\nhum.PlatformStand=true\ncoroutine.resume(coroutine.create(function(HHumanoid)\nswait(1)\nHHumanoid.PlatformStand=false\nend),hum)\n                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit\n--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)\nlocal bodvol=Instance.new(\"BodyVelocity\")\nbodvol.velocity=angle*knockback\nbodvol.P=5000\nbodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)\nbodvol.Parent=hit\nlocal rl=Instance.new(\"BodyAngularVelocity\")\nrl.P=3000\nrl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000\nrl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))\nrl.Parent=hit\ngame:GetService(\"Debris\"):AddItem(bodvol,.5)\ngame:GetService(\"Debris\"):AddItem(rl,.5)\n                elseif Type==\"Normal\" then\n                local vp=Instance.new(\"BodyVelocity\")\n                vp.P=500\n                vp.maxForce=Vector3.new(math.huge,0,math.huge)\n--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback\n                if KnockbackType==1 then\n                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05\n                elseif KnockbackType==2 then\n                vp.velocity=Property.CFrame.lookVector*knockback\n                end\n                if knockback>0 then\n                        vp.Parent=hit.Parent.Torso\n                end\n                game:GetService(\"Debris\"):AddItem(vp,.5)\n                elseif Type==\"Up\" then \n                local bodyVelocity=Instance.new(\"BodyVelocity\")\n                bodyVelocity.velocity=Vector3.new(0,60,0)\n                bodyVelocity.P=5000\n                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)\n                bodyVelocity.Parent=hit\n                game:GetService(\"Debris\"):AddItem(bodyVelocity,1)\n                local rl=Instance.new(\"BodyAngularVelocity\")\n                rl.P=3000\n                rl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000\n                rl.angularvelocity=Vector3.new(math.random(-30,30),math.random(-30,30),math.random(-30,30))\n                rl.Parent=hit\n                game:GetService(\"Debris\"):AddItem(rl,.5)\n                elseif Type==\"Snare\" then\n                local bp=Instance.new(\"BodyPosition\")\n                bp.P=2000\n                bp.D=100\n                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)\n                bp.position=hit.Parent.Torso.Position\n                bp.Parent=hit.Parent.Torso\n                game:GetService(\"Debris\"):AddItem(bp,1)\n                elseif Type==\"Target\" then\n\t            local Targetting = false\n                if Targetting==false then\n                ZTarget=hit.Parent.Torso\n                coroutine.resume(coroutine.create(function(Part) \n                so(\"http://www.roblox.com/asset/?id=15666462\",Part,1,1.5) \n                swait(5)\n                so(\"http://www.roblox.com/asset/?id=15666462\",Part,1,1.5) \n                end),ZTarget)\n                local TargHum=ZTarget.Parent:findFirstChild(\"Humanoid\")\n                local  targetgui=Instance.new(\"BillboardGui\")\n                targetgui.Parent=ZTarget\n                targetgui.Size=UDim2.new(10,100,10,100)\n                local targ=Instance.new(\"ImageLabel\")\n                targ.Parent=targetgui\n                targ.BackgroundTransparency=1\n                targ.Image=\"rbxassetid://4834067\"\n                targ.Size=UDim2.new(1,0,1,0)\n                cam.CameraType=\"Scriptable\"\n                cam.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)\n                local dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)\n                workspace.CurrentCamera.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)\n                Targetting=true\n                RocketTarget=ZTarget\n                for i=1,Property do\n                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do\n                if hum.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then\n                swait()\n                end\n                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)\n                cam.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)\n                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)\n                cam.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)\n                end\n                Targetting=false\n                RocketTarget=nil\n                targetgui.Parent=nil\n                cam.CameraType=\"Custom\"\n                end\n                end\n                        local debounce=Instance.new(\"BoolValue\")\n                        debounce.Name=\"DebounceHit\"\n                        debounce.Parent=hit.Parent\n                        debounce.Value=true\n                        game:GetService(\"Debris\"):AddItem(debounce,Delay)\n                        c=Instance.new(\"ObjectValue\")\n                        c.Name=\"creator\"\n                        c.Value=player\n                        c.Parent=h\n                        game:GetService(\"Debris\"):AddItem(c,.5)\n        end\nend\n\n\n\n\n\n\nfunction MagniDamage(Hit,Part,magni,mindam,maxdam,knock,Type)\nfor _,c in pairs(workspace:children()) do\nlocal hum=c:findFirstChild(\"Humanoid\")\nif hum~=nil then\nlocal head=c:findFirstChild(\"Torso\")\nif head~=nil then\nlocal targ=head.Position-Part.Position\nlocal mag=targ.magnitude\nif mag<=magni and c.Name~=player.Name then \nDamagefunc(Hit,head,mindam,maxdam,knock,Type,root,.2,1,3)\nend\nend\nend\nend\nend\n\n\nfunction rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants\nreturn game:service(\"Workspace\"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) \nend \n\n\nfunction mesh(Mesh,part,meshtype,meshid,offset,scale)\n\t\tlocal mesh=Instance.new(Mesh)\n\t\tmesh.Parent=part\n\t\tif Mesh==\"SpecialMesh\" then\n\t\t\tmesh.MeshType=meshtype\n\t\t\tmesh.MeshId=meshid\n\t\tend\n\t\tmesh.Offset=offset\n\t\tmesh.Scale=scale\n\t\treturn mesh\n\tend\n\n\nfunction weld(parent,part0,part1,c0,c1)\n\t\tlocal weld=Instance.new(\"Weld\")\n\t\tweld.Parent=parent\n\t\tweld.Part0=part0\n\t\tweld.Part1=part1\n\t\tweld.C0=c0\n\t\tweld.C1=c1\n\t\treturn weld\nend\n\n\n\n\n\nfunction nooutline(part)\n\t\tpart.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10\n\tend\n\t\n\tfunction parto(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)\n\t\tlocal fp=it(\"Part\")\n\t\tfp.formFactor=formfactor\n\t\tfp.Parent=parent\n\t\tfp.Reflectance=reflectance\n\t\tfp.Transparency=transparency\n\t\tfp.CanCollide=false\n\t\tfp.Locked=true\n\t\tfp.BrickColor=BrickColor.new(tostring(brickcolor))\n\t\tfp.Name=name\n\t\tfp.Size=size\n\t\tfp.Position=Character.Torso.Position\n\t\tnooutline(fp)\n\t\tfp.Material=material\n\t\tfp:BreakJoints()\n\t\treturn fp\n\tend\n\t\n\tfunction mesho(Mesh,part,meshtype,meshid,offset,scale)\n\t\tlocal mesh=it(Mesh)\n\t\tmesh.Parent=part\n\t\tif Mesh==\"SpecialMesh\" then\n\t\t\tmesh.MeshType=meshtype\n\t\t\tmesh.MeshId=meshid\n\t\tend\n\t\tmesh.Offset=offset\n\t\tmesh.Scale=scale\n\t\treturn mesh\n\tend\n\t\n\t\n\t\nlocal fx={}\nlocal Neoncol = {BrickColor.new(\"New Yeller\")}\n\n\n\nDamagefunco=function(Part,hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)\n        if hit.Parent==nil then\n                return\n        end\n        local h=hit.Parent:FindFirstChild(\"Humanoid\")\n        for _,v in pairs(hit.Parent:children()) do\n        if v:IsA(\"Humanoid\") then\n        h=v\n        end\n        end\n        if hit.Parent.Parent:FindFirstChild(\"Torso\")~=nil then\n        h=hit.Parent.Parent:FindFirstChild(\"Humanoid\")\n        end\n        if hit.Parent.className==\"Hat\" then\n        hit=hit.Parent.Parent:findFirstChild(\"Head\")\n        end\n        if h~=nil and hit.Parent.Name~=Character.Name and hit.Parent:FindFirstChild(\"Torso\")~=nil then\n        if hit.Parent:findFirstChild(\"DebounceHit\")~=nil then if hit.Parent.DebounceHit.Value==true then return end end\n        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then\n                        return\n                end]]\n--                        hs(hit,1.2) \n                        local c=Instance.new(\"ObjectValue\")\n                        c.Name=\"creator\"\n                        c.Value=game:service(\"Players\").LocalPlayer\n                        c.Parent=h\n                        game:GetService(\"Debris\"):AddItem(c,.5)\n                local Damage=math.random(minim,maxim)\n--                h:TakeDamage(Damage)\n                local  blocked=false\n                local  block=hit.Parent:findFirstChild(\"Block\")\n                if block~=nil then\n                print(block.className)\n                if block.className==\"NumberValue\" then\n                if block.Value>0 then\n                blocked=true\n                if decreaseblock==nil then\n                block.Value=block.Value-1\n                end\n                end\n                end\n                if block.className==\"IntValue\" then\n                if block.Value>0 then\n                blocked=true\n                if decreaseblock~=nil then\n                block.Value=block.Value-1\n                end\n                end\n                end\n                end\n                if blocked==false then\n--                h:TakeDamage(Damage)\n                h.Health=h.Health-Damage\n                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, Part.BrickColor.Color)\n                else\n                h.Health=h.Health-(Damage/2)\n                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, BrickColor.new(\"Bright blue\").Color)\n                end\n                if Type==\"Knockdown\" then\n                local hum=hit.Parent.Humanoid\nhum.PlatformStand=true\ncoroutine.resume(coroutine.create(function(HHumanoid)\nswait(1)\nHHumanoid.PlatformStand=false\nend),hum)\n                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit\n--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)\nlocal bodvol=Instance.new(\"BodyVelocity\")\nbodvol.velocity=angle*knockback\nbodvol.P=5000\nbodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)\nbodvol.Parent=hit\nlocal rl=Instance.new(\"BodyAngularVelocity\")\nrl.P=3000\nrl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000\nrl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))\nrl.Parent=hit\ngame:GetService(\"Debris\"):AddItem(bodvol,.5)\ngame:GetService(\"Debris\"):AddItem(rl,.5)\n                elseif Type==\"Normal\" then\n                local vp=Instance.new(\"BodyVelocity\")\n                vp.P=500\n                vp.maxForce=Vector3.new(math.huge,0,math.huge)\n--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback\n                if KnockbackType==1 then\n                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05\n                elseif KnockbackType==2 then\n                vp.velocity=Property.CFrame.lookVector*knockback\n                end\n                if knockback>0 then\n                        vp.Parent=hit.Parent.Torso\n                end\n                game:GetService(\"Debris\"):AddItem(vp,.5)\n                elseif Type==\"Up\" then\n                local bodyVelocity=Instance.new(\"BodyVelocity\")\n                bodyVelocity.velocity=vt(0,60,0)\n                bodyVelocity.P=5000\n                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)\n                bodyVelocity.Parent=hit\n                game:GetService(\"Debris\"):AddItem(bodyVelocity,1)\n                local rl=Instance.new(\"BodyAngularVelocity\")\n                rl.P=3000\n                rl.maxTorque=Vector3.new(500000,500000,500000)*50000000000000\n                rl.angularvelocity=Vector3.new(math.random(-30,30),math.random(-30,30),math.random(-30,30))\n                rl.Parent=hit\n                game:GetService(\"Debris\"):AddItem(rl,.5)\n                elseif Type==\"Snare\" then\n                local bp=Instance.new(\"BodyPosition\")\n                bp.P=2000\n                bp.D=100\n                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)\n                bp.position=hit.Parent.Torso.Position\n                bp.Parent=hit.Parent.Torso\n                game:GetService(\"Debris\"):AddItem(bp,1)\n                elseif Type==\"Target\" then\n\t            local Targetting = false\n                if Targetting==false then\n                ZTarget=hit.Parent.Torso\n                coroutine.resume(coroutine.create(function(Part) \n                so(\"http://www.roblox.com/asset/?id=15666462\",Part,1,1.5) \n                swait(5)\n                so(\"http://www.roblox.com/asset/?id=15666462\",Part,1,1.5) \n                end),ZTarget)\n                local TargHum=ZTarget.Parent:findFirstChild(\"Humanoid\")\n                local  targetgui=Instance.new(\"BillboardGui\")\n                targetgui.Parent=ZTarget\n                targetgui.Size=UDim2.new(10,100,10,100)\n                local targ=Instance.new(\"ImageLabel\")\n                targ.Parent=targetgui\n                targ.BackgroundTransparency=1\n                targ.Image=\"rbxassetid://4834067\"\n                targ.Size=UDim2.new(1,0,1,0)\n                cam.CameraType=\"Scriptable\"\n                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)\n                local dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)\n                workspace.CurrentCamera.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)\n                Targetting=true\n                RocketTarget=ZTarget\n                for i=1,Property do\n                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do\n                if hum.Health>0 and Character.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then\n                swait()\n                end\n                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)\n                cam.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)\n                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)\n                cam.CoordinateFrame=CFrame.new(hed.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)\n                end\n                Targetting=false\n                RocketTarget=nil\n                targetgui.Parent=nil\n                cam.CameraType=\"Custom\"\n                end\n                end\n                        local debounce=Instance.new(\"BoolValue\")\n                        debounce.Name=\"DebounceHit\"\n                        debounce.Parent=hit.Parent\n                        debounce.Value=true\n                        game:GetService(\"Debris\"):AddItem(debounce,Delay)\n                        c=Instance.new(\"ObjectValue\")\n                        c.Name=\"creator\"\n                        c.Value=Player\n                        c.Parent=h\n                        game:GetService(\"Debris\"):AddItem(c,.5)\n        end\nend\n\n\nlocal col = 1\n\n\n\nfunction MagicCylinder2o(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)\nlocal prt=parto(3,Character,\"Neon\",0,0,brickcolor,\"Effect\",vt(0.2,0.2,0.2))\nprt.Anchored=true\nprt.CFrame=cframe\nmsh=mesho(\"CylinderMesh\",prt,\"\",\"\",vt(0,0,0),vt(x1,y1,z1))\ngame:GetService(\"Debris\"):AddItem(prt,5)\n--table.insert(fx,{prt,\"Cylinder\",delay,x3,y3,z3})\nfx[#fx+1]={prt,\"Cylinder\",delay,x3,y3,z3} --part, type, delay\n--[[coroutine.resume(coroutine.create(function(Part,Mesh) \nfor i=0,1,delay do\nwait()\nPart.CFrame=Part.CFrame\nPart.Transparency=i\nMesh.Scale=Mesh.Scale+vt(x3,y3,z3)\nend\nPart.Parent=nil\nend),prt,msh)]]\nend\n\nfunction MagniDamageo(Hit,Part,magni,mindam,maxdam,knock,Type)\nfor _,c in pairs(workspace:children()) do\nlocal hum=c:findFirstChild(\"Humanoid\")\nif hum~=nil then\nlocal head=c:findFirstChild(\"Torso\")\nif head~=nil then\nlocal targ=head.Position-Part.Position\nlocal mag=targ.magnitude\nif mag<=magni and c.Name~=p.Name then \nDamagefunco(Hit,head,mindam,maxdam,knock,Type,root,.2,1,3)\nend\nend\nend\nend\nend\n\n\nfunction MagicBlocko(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)\nlocal prt=parto(3,workspace,\"Neon\",0,0,brickcolor,\"Effect\",vt())\nprt.Anchored=true\nprt.CFrame=cframe\nmsh=mesho(\"BlockMesh\",prt,\"\",\"\",vt(0,0,0),vt(x1,y1,z1))\ngame:GetService(\"Debris\"):AddItem(prt,5)\ntable.insert(fx,{prt,\"Block1\",delay,x3,y3,z3}) --part, type, delay\nend\n\nmod=Instance.new('Model',char)\nfunction Burst()\n    part=Instance.new('Part',mod)\n    part.Anchored=true\n    part.CanCollide=false\n    part.FormFactor='Custom'\n    part.Size=Vector3.new(.2,.2,.2)\n    part.CFrame=root.CFrame*CFrame.new(0,1,0)*CFrame.Angles(math.rad(90),0,0)\n    part.Transparency=.7\n    part.BrickColor=BrickColor.new('New Yeller')\n    mesh=Instance.new('SpecialMesh',part)\n    mesh.MeshId='http://www.roblox.com/asset/?id=20329976'\n    mesh.Scale=Vector3.new(10,5,10)\n    part2=part:clone()\n    part2.Parent=mod\n    part2.BrickColor=BrickColor.new('New Yeller')\n    mesh2=mesh:clone()\n    mesh2.Parent=part2\n    mesh2.Scale=Vector3.new(5,2.5,5)\n    coroutine.resume(coroutine.create(function() \n        for i=0,1,0.1 do\n            wait()\n            part.CFrame=part.CFrame\n            part.Transparency=i\n            mesh.Scale=mesh.Scale+Vector3.new(1,1,1)\n            part2.CFrame=part2.CFrame\n            part2.Transparency=i\n            mesh2.Scale=mesh2.Scale+Vector3.new(1,1,1)\n            end\n        part.Parent=nil\n        part2.Parent=nil\n    end))\nend\nCharging = true\ncustommath={25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90,-91,-92,-93,-94,-95,-96,-97,-98,-99,-100}\nfunction FDebris()\n\trepeat\n    local p = Instance.new('Part',torso)\n    p.formFactor = 'Custom'\n    p.Size = Vector3.new(1,1,1)\n    p.BrickColor = workspace.Base.BrickColor\n    p.CanCollide = false\n    p.Transparency = 0\n    p.Anchored = true\n    p.Locked=true\n    p.Material = workspace.Base.Material\n    s = math.random(1,40)/10\n    local m = Instance.new(\"BlockMesh\",p)\n    m.Scale = Vector3.new(s,s,s)\n    p.CFrame = torso.CFrame*CFrame.new(custommath[math.random(1,#custommath)]/10,-math.random(5,7),custommath[math.random(1,#custommath)]/10)*CFrame.Angles(math.random(),math.random(),math.random())\n\t--[[coroutine.wrap(function()\n\t\twait(2)\n\t\twhile Charging == true do\n\t\twait(2)\n\t\tGroundWave1()\n\t\twait(2)\n\t\tend\n\tend)()]]--\n\t\n\tspawn(function()\n        while rs:wait() do\n            if p.Transparency >= 1 then p:Destroy() break end\n            p.CFrame = p.CFrame*CFrame.Angles(math.rad(2),math.rad(2),math.rad(2))+Vector3.new(0,0.2,0)\n            p.Transparency = p.Transparency+0.01\n        end\n    end)\n    wait(.3)\nuntil Charging == false\nend\n\n\n\n\n\nfunction weld5(part0, part1, c0, c1)\n    weeld=Instance.new(\"Weld\", part0)\n    weeld.Part0=part0\n    weeld.Part1=part1\n    weeld.C0=c0\n    weeld.C1=c1\n    return weeld\nend\n\nfunction Slam()\n    part=Instance.new('Part',mod)\n    part.Anchored=true\n    part.CanCollide=false\n    part.FormFactor='Custom'\n    part.Size=Vector3.new(.2,.2,.2)\n    part.CFrame=root.CFrame*CFrame.new(0,-2.8,-1.4)*CFrame.Angles(math.rad(90),0,0)\n    part.Transparency=.7\n    part.BrickColor=BrickColor.new('Institutional white')\n    mesh=Instance.new('SpecialMesh',part)\n    mesh.MeshId='http://www.roblox.com/asset/?id=3270017'\n    mesh.Scale=Vector3.new(3,3,3)\n    part2=Instance.new('Part',mod)\n    part2.Anchored=true\n    part2.CanCollide=false\n    part2.FormFactor='Custom'\n    part2.Size=Vector3.new(.2,.2,.2)\n    part2.CFrame=root.CFrame*CFrame.new(0,-2.4,-1.6)\n    part2.Transparency=.7\n    part2.BrickColor=BrickColor.new('New Yeller')\n\n    mesh2=Instance.new('SpecialMesh',part2)\n    mesh2.MeshId='http://www.roblox.com/asset/?id=20329976'\n    mesh2.Scale=Vector3.new(3,1.5,3)\n\n    wait(.1)\n\t--x:Play()\n    --x1:Play()\n    for i,v in pairs(FindNearestTorso(torso.CFrame.p,4))do\n        if v:FindFirstChild('Humanoid') and holy == true then\n\t\t\t\tholyslamdmg = math.random(99999999999999999999999999999999999999999,999999999999999999999999999999999999999999999999999999999999999999999)\n            v.Humanoid:TakeDamage(holyslamdmg)\n\t\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\t\twait(2)\n\t\t\t\t\tv.Humanoid.PlatformStand = false\n\t\t\t\tend))\n\t\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\t\twait(2)\n\t\t\t\t\tv.Humanoid.PlatformStand = false\n\t\t\t\tend))\n        end\n\tso(\"http://roblox.com/asset/?id=206082327\", torso, 1, 1)\n\tso(\"http://roblox.com/asset/?id=142070127\", torso, 1, 0.7)\n\tso(\"http://roblox.com/asset/?id=263610111\", torso, 1, 1)\n\tso(\"http://roblox.com/asset/?id=263610131\", torso, 1, 1)\n\tso(\"http://roblox.com/asset/?id=166221646\",\ttorso,1,1) \n  \tso(\"http://roblox.com/asset/?id=200632875\", torso, 1, 1)\n    end\n\t\n\n\n    coroutine.resume(coroutine.create(function() \n        for i=0,0.62,0.13 do\n            wait()\n            part.CFrame=part.CFrame\n            part.Transparency=i\n            mesh.Scale=mesh.Scale+Vector3.new(0.4,0.4,0.4)\n            part2.CFrame=part2.CFrame\n            part2.Transparency=i\n            mesh2.Scale=mesh2.Scale+Vector3.new(0.4,0.2,0.4)\n            end\n        part.Parent=nil\n        part2.Parent=nil\n    end)) \nend\n\nGrab = false\nmouse.KeyDown:connect(function(key)\n    if key == \"z\" then\n        Debounces.on = true\n        Debounces.NoIdl = true\n\t\tDebounces.ks = true\n        if Grab == false then\n        gp = nil\n        for i = 1, 20 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(20)), 0.2)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(80),math.rad(0),math.rad(-80)), 0.2)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-10),math.rad(-70),0), 0.2)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(70), 0), 0.2)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(30), math.rad(-20)), 0.2)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(-15), math.rad(20)), 0.2)\n            if Debounces.on == false then break end\n            rs:wait(2)\n        end\n        con1=larm.Touched:connect(function(hit) -- this is grab\n            ht = hit.Parent\n            hum1=ht:FindFirstChild('Humanoid')\n            if hum1 ~= nil then\n\t\t\t    if Debounces.ks==true then\n                z = Instance.new(\"Sound\",hed)\n                z.SoundId = \"rbxassetid://200632821\"\n                z.Volume = 1\n                z:Play()\n                Debounces.ks=false\n\t\t\t\tend\n                hum1.PlatformStand=true\n                gp = ht\n                Grab = true\n                asd=weld5(larm,ht:FindFirstChild(\"Torso\"),CFrame.new(0,-1,1.5),CFrame.new(0,0,0))\n                asd.Parent = larm\n                asd.Name = \"asd\"\n                asd.C0=asd.C0*CFrame.Angles(math.rad(-90),math.rad(180),0)\n\t\t\t\tstanceToggle = \"Grabbed\"\n            --[[elseif hum1 == nil then\n                con1:disconnect()\n                wait() return]]--\n            end\n        end)\n        for i = 1, 20 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(20)), 0.2)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(70),math.rad(0),math.rad(20)), 0.2)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-10),math.rad(30),0), 0.2)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-30), 0), 0.2)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.2)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(-15), math.rad(20)), 0.2)\n            if Debounces.on == false then break end\n            rs:wait(2)\n        end\n    con1:disconnect()\n    Debounces.on = false\n    Debounces.NoIdl = false\n    elseif Grab == true then\n        Grab = false\n\t\t\t--[[for i = 1, 16 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(0),math.rad(50),math.rad(60)), 0.3)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,-.5)*CFrame.Angles(math.rad(130),math.rad(0),math.rad(-60)), 0.3)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(14),math.rad(70),0), 0.3)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-70), 0), 0.3)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.3)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(-15), math.rad(20)), 0.3)\n\t\t\tcor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, math.rad(40), 0), 0.3)\n\t\t\tif Debounces.on == false then end\n\t\t\trs:wait()\n\t\tend]]--\n\t\t\n\t\tSlam()\n\t\tCrater(torso, 10)\t\n\t\t\n\t\tif gp ~= nil then\n\t\t\tfor i,v in pairs(larm:GetChildren()) do\n\t\t\t\tif v.Name == \"asd\" and v:IsA(\"Weld\") then\n\t\t\t\t\tv:Remove()\n\t\t\t\tend\n\t\t\tend\n\t\tfor i = 1, 16 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(20)), 0.3)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,-.4)*CFrame.Angles(math.rad(70),math.rad(0),math.rad(20)), 0.3)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(0),math.rad(20),0), 0.3)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-60), math.rad(-30), 0), 0.3)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(80), math.rad(30), math.rad(-20)), 0.3)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(70), math.rad(-15), math.rad(20)), 0.3)\n\t\t\tif Debounces.on == false then end\n\t\t\trs:wait()\n\t\tend\n\t\t\n\t\t\t\tif gp ~= nil then\n\t\t\tfor i,v in pairs(larm:GetChildren()) do\n\t\t\t\tif v.Name == \"asd\" and v:IsA(\"Weld\") then\n\t\t\t\t\tv:Remove()\n\t\t\t\tend\n\t\t\tend\n\t\t\n\t\tstanceToggle = \"Normal\"\n        --[[bv = Instance.new(\"BodyVelocity\",gp:FindFirstChild(\"Torso\"))\n        bv.maxForce = Vector3.new(400000, 400000, 400000)\n        bv.P = 125000\n        bv.velocity = char.Head.CFrame.lookVector * 200]]--\n        ht=nil\n        Debounces.on = false\n        Debounces.NoIdl = false\n        elseif ht == nil then wait()\n        Grab = false\n        Debounces.on = false\n        Debounces.NoIdl = false\n            end\n        end\n    end\nend\nend)\n\n\n\nfunction Throw()\n\t    if Grab == true then\n        Grab = false\n\tstanceToggle = \"Normal\"\n\t\t\tfor i = 1, 16 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(20)), 0.3)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(140),math.rad(0),math.rad(-50)), 0.3)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(20),math.rad(-60),0), 0.3)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(50), 0), 0.3)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(30), math.rad(-20)), 0.3)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(-15), math.rad(20)), 0.3)\n\t\t\tif Debounces.on == false then end\n\t\t\trs:wait()\n\t\t\tend\n\t\t\t\t\tfor i = 1, 16 do\n\t\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(20),math.rad(0),math.rad(20)), 0.3)\n\t\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,1.5,-.4)*CFrame.Angles(math.rad(-90),math.rad(0),math.rad(20)), 0.3)\n\t\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(0),math.rad(-10),0), 0.3)\n\t\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), 0), 0.3)\n\t\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.3)\n\t\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-15), math.rad(-15), math.rad(20)), 0.3)\n\t\t\tif Debounces.on == false then end\n\t\t\trs:wait()\n\t\tend\n        if gp ~= nil then\n\t\n\t\t\t\tcoroutine.resume(coroutine.create(function()\n\t\t\t\t\ttossed = gp:FindFirstChild(\"Torso\").Parent.Humanoid\n\t\t\t\t\twait(3)\n\t\t\t\t\ttossed.PlatformStand = false\n\t\t\t\tend))\t\n\t\n                                    z3 = Instance.new(\"Sound\",torso)\n                                    z3.SoundId = \"rbxassetid://200632136\"\n\t\t\t\t\t\t\t\t\tz3.Pitch = 0.7\n                                    z3.Volume = 1\n                                    z3:Play()\t\n\t\n        for i,v in pairs(larm:GetChildren()) do\n            if v.Name == \"asd\" and v:IsA(\"Weld\") then\n                v:Remove()\n            end\n        end\n        bv = Instance.new(\"BodyVelocity\",gp:FindFirstChild(\"Torso\"))\n        bv.maxForce = Vector3.new(400000, 400000, 400000)\n        bv.P = 125000\n        bv.velocity = char.Head.CFrame.lookVector * 70\n\n\n\n        for i = 1, 12 do\n            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.6, 0, -.75)*CFrame.Angles(math.rad(120),math.rad(0),math.rad(20)), 0.5)\n            if Debounces.on == false then end\n            wait()\n        end\n        ht=nil\n        spawn(function()\n            wait(0.5)\n            bv:Destroy()\n        end)\n\t\tstanceToggle = \"Normal\"\n        Debounces.on = false\n        Debounces.NoIdl = false\n        elseif ht == nil then wait()\n        Grab = false\n        Debounces.on = false\n        Debounces.NoIdl = false\n            end\n        end\nend\n\nmouse.KeyDown:connect(function(key)\n\n    if key == \"x\" then\n\t\tif Grab ~= true then\n\t\t\tKick()\n\t\telseif Grab == true then\n\t\t\tThrow()\n\t\tend\n\tend\n\nend)\n\t\n\t\nfunction AbsoluteBurn()\n\tif Grab == true then\n\t\tGrab = false\n\t\tstanceToggle = \"Normal\"\n\t\tlocal p = Instance.new(\"Part\", Character)\n\t\t\t\tp.Anchored=true\n\t\t\t\tp.CanCollide=false\n\t\t\t\tp.Transparency=1\n\t\t\t\tp.Size=Vector3.new(.1,.1,.1)\n\t\t\t\tp.Shape = \"Ball\"\n\t\t\t\tp.BrickColor = BrickColor.new(\"Institutional white\")\n\t\t\t\tp.CFrame = torso.CFrame * CFrame.new(-1.5, 0, -2)\n\t\t\t\tgame.Debris:AddItem(p,3)\n\t\t\t\tlocal explosion = Instance.new(\"Sound\", Character)\n\t\t\t\texplosion.Name=\"explosion\"\n\t\t\t\texplosion.SoundId = \"rbxassetid://2248511\"\n\t\t\t\texplosion:Play()\n\t\t\t\tgame.Debris:AddItem(explosion, 10)\n\t\t\t\tlocal forcefield = Instance.new(\"ForceField\", char)\n\t\t\t\tlocal explo = Instance.new(\"Explosion\", workspace)\n\t\t\t\texplo.BlastPressure = 700000\n\t\t\t\texplo.BlastRadius=5\n\t\t\t\texplo.Position=p.Position\n\t\t\t\twait(0.01)\n\t\t\t\tforcefield:Destroy()\n\t\t\t\t\n\t\t\t\tfor i,v in pairs(larm:GetChildren()) do\n            if v.Name == \"asd\" and v:IsA(\"Weld\") then\n                v:Remove()\n\n bv = Instance.new(\"BodyVelocity\",gp:FindFirstChild(\"Torso\"))\n        bv.maxForce = Vector3.new(400000, 400000, 400000)\n        bv.P = 125000\n        bv.velocity = char.Head.CFrame.lookVector * 10\n            end\n        end\n\tend\nend\t\n\nmouse.KeyDown:connect(function(key)\n\n    if key == \"c\" then\n\t\tif Grab ~= true then\n\t\t\tKick()\n\t\telseif Grab == true then\n\t\t\tAbsoluteBurn()\n\t\tend\n\tend\n\nend)\n\t\n\t print(\"The End Is Here\")\n\t\nfunction Drop()\n\tif Grab == true then\n\t\tGrab = false\n\t\tstanceToggle = \"Normal\"\n\t\tgame:GetService(\"Chat\"):Chat(Character.Head,\"You're not even worth killing, weakling..\",2)\n\t\t\n\t\t\t\tif gp ~= nil then\n\t\t\tfor i,v in pairs(larm:GetChildren()) do\n\t\t\t\tif v.Name == \"asd\" and v:IsA(\"Weld\") then\n\t\t\t\t\tv:Remove()\n\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\t\t\tend\n\t\t\t\tend\nend\n\n\nmouse.KeyDown:connect(function(key)\n\n    if key == \"v\" then\n\t\tif Grab ~= true then\n\t\t\tBlast()\n\t\telseif Grab == true then\n\t\t\tDrop()\n\t\tend\n\tend\n\nend)\n\n\n\n\n\n\n\nRootPart=Character.HumanoidRootPart\nRootJoint=RootPart.RootJoint\nRootCF=euler(-1.57,0,3.14)\n\nnecko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)\n\n\n\n\n\n\n\n\n\n\nfunction MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)\nlocal prt=part(3,workspace,\"SmoothPlastic\",0,0,brickcolor,\"Effect\",vt())\nprt.Anchored=true\nprt.CFrame=cframe\nmsh=mesh(\"BlockMesh\",prt,\"\",\"\",vt(0,0,0),vt(x1,y1,z1))\ngame:GetService(\"Debris\"):AddItem(prt,2)\ncoroutine.resume(coroutine.create(function(Part,Mesh) \nfor i=0,1,delay do\nwait()\nPart.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))\nPart.Transparency=i\nMesh.Scale=Mesh.Scale+vt(x3,y3,z3)\nend\nPart.Parent=nil\nend),prt,msh)\nend \n\nfunction MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)\nlocal prt=part(3,workspace,\"SmoothPlastic\",0,0,brickcolor,\"Effect\",vt())\nprt.Anchored=true\nprt.CFrame=cframe\nlocal msh=mesh(\"SpecialMesh\",prt,\"Sphere\",\"\",vt(0,0,0),vt(x1,y1,z1))\ngame:GetService(\"Debris\"):AddItem(prt,2)\ncoroutine.resume(coroutine.create(function(Part,Mesh) \nlocal wld=nil\nfor i=0,1,delay do\nwait()\nPart.CFrame=Part.CFrame\nPart.Transparency=i\nMesh.Scale=Mesh.Scale+vt(x3,y3,z3)\nend\nPart.Parent=nil\nend),prt,msh)\nend \n\nfunction MagicCylinder(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)\nlocal prt=part(3,workspace,\"SmoothPlastic\",0,0,brickcolor,\"Effect\",vt(0.2,0.2,0.2))\nprt.Anchored=true\nprt.CFrame=cframe\nmsh=mesh(\"SpecialMesh\",prt,\"Head\",\"\",vt(0,0,0),vt(x1,y1,z1))\ngame:GetService(\"Debris\"):AddItem(prt,5)\ncoroutine.resume(coroutine.create(function(Part,Mesh) \nfor i=0,1,delay do\nwait()\nPart.CFrame=Part.CFrame\nPart.Transparency=i\nMesh.Scale=Mesh.Scale+vt(x3,y3,z3)\nend\nPart.Parent=nil\nend),prt,msh)\nend \n\n\n\n\n\n\nfunction Blast()\nn=2\nattack = true\ngame:GetService(\"Chat\"):Chat(Character.Head,\"You Will Know Pain...\",2)\nfor i=0,1,0.1 do\nswait()\nRootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0,0)* angles(math.rad(0),math.rad(0),math.rad(-30)),.3)\nNeck.C0 = clerp(Neck.C0,necko *angles(math.rad(-2),math.rad(-2),math.rad(30)),.3)\nRH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)\nLH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-70),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),.3)\nend\nso(\"http://roblox.com/asset/?id=160772554\",torso,1,0.6) \nso(\"http://roblox.com/asset/?id=161006069\",torso,1,0.6) \nlocal charging=true\nfor _,c in pairs(workspace:children()) do\nif c.className==\"Model\" then\nif c:findFirstChild(\"Torso\")~=nil and c:findFirstChild(\"Humanoid\")~=nil and c.Name~=\"Vanta\" then\nprint(c)\nlocal Tors=c:findFirstChild(\"Torso\")\ncoroutine.resume(coroutine.create(function(Part)\nlocal ef=part(3,Character,\"SmoothPlastic\",0,0.5,BrickColor.new(\"Institutional white\"),\"Laser\",vt(0.2,0.2,0.2))\nef.Anchored=true\nlocal emsh=mesh(\"SpecialMesh\",ef,\"Head\",\"\",vt(0,0,0),vt(1,1,1))\ngame:GetService(\"Debris\"):AddItem(ef,5)\nwhile charging==true do\nwait()\nlocal TheHit=Part.Position\nlocal MouseLook=cf((larm.Position+TheHit)/2,TheHit)\nlocal hit,pos = rayCast(larm.Position,MouseLook.lookVector,99999999999,Character)\nlocal mag=(larm.Position-pos).magnitude \nef.CFrame=CFrame.new((larm.Position+pos)/2,pos)*euler(1.57,0,0)\nemsh.Scale=vt(1,mag*5,1)\nend\nef.Parent=nil\nlocal TheHit=Part.Position\nlocal MouseLook=cf((torso.Position+TheHit)/2,TheHit)\nwait()\nlocal hit,pos = rayCast(torso.Position,MouseLook.lookVector,999,Character)\nlocal mag=(torso.Position-pos).magnitude \nif hit~=nil then\nDamagefunc(hit,hit,200,400,500,\"Knockdown\",root,0)\nMagicCircle(BrickColor.new(\"Institutional white\"),cf(pos),50,50,50,60,60,60,0.02)\nMagicBlock(BrickColor.new(\"Institutional white\"),cf(pos),50,50,50,70,70,70,0.02)\nMagicCylinder(BrickColor.new(\"Institutional white\"),CFrame.new((larm.Position+pos)/2,pos)*euler(1.57,0,0),5,mag*5,5,0.5,0,0.5,0.01)\nso(\"http://roblox.com/asset/?id=183763515\",hit,1,1) \nso(\"http://roblox.com/asset/?id=183763512\",hit,1,1)\nlocal explosion = Instance.new(\"Sound\", Character)\n\t\t\t\texplosion.Name=\"explosion\"\n\t\t\t\texplosion.SoundId = \"rbxassetid://165969964\"\n\t\t\t\texplosion.Volume = 10\n\t\t\t\texplosion:Play()\nend\nend),Tors)\nend\nend\nend\nwait(1)\nn=2\n--[[for i=0,1,0.2 do\nwait()\nNeck.C0=cf(0,1,0)*euler(-0.4+0.2*i*n,0,0)\nRW.C0=cf(1+0.5*i*n,0.5,-0.5+0.5*i*n)*euler(1.4+0.17*i*n,0,-1.2+2.77*i*n)\nLW.C0=cf(-1-0.5*i*n,0.5,-0.5+0.5*i*n)*euler(1.6-0.03*i*n,0,1.4-2.97*i*n)\nn=n-0.2\nend]]--\ncharging=false\nwait(1)\nn=2\n--[[for i=0,1,0.1 do\nwait()\nNeck.C0=cf(0,1,0)*euler(-0.2,0,0)\nRW.C0=cf(1.5,0.5,0)*euler(1.57-1.57*i*n,0,1.57-1.37*i*n)\nLW.C0=cf(-1.5,0.5,0)*euler(1.57-1.57*i*n,0,-1.57+1.37*i*n)\nn=n-0.1\nend]]--\nattack = false\nend\n\n\nfunction prop(part, parent, collide, tran, ref, x, y, z, color, anchor, form) \npart.Parent = parent \npart.formFactor = form \npart.CanCollide = collide \npart.Transparency = tran \npart.Reflectance = ref \npart.Size = Vector3.new(x,y,z) \npart.BrickColor = BrickColor.new(color) \npart.TopSurface = 0 \npart.BottomSurface = 0 \npart.Anchored = anchor \npart.Locked = true \npart:BreakJoints() \nend \n\nbg = Instance.new(\"BodyGyro\",nil) \nbg.P = 2000 \nbg.maxTorque = Vector3.new(0,math.huge,0) \ntrail1 = Instance.new(\"Part\") \nprop(trail1,nil,false,0.4,0,0.1,0.1,1,\"New Yeller\",true,\"Custom\") \nlocal t1 = Instance.new(\"SpecialMesh\",trail1) \nt1.MeshType = \"Brick\" \ntrail2 = Instance.new(\"Part\") \nprop(trail2,nil,false,0.4,0,0.1,0.1,1,\"New Yeller\",true,\"Custom\") \nlocal t2 = Instance.new(\"SpecialMesh\",trail2) \nt2.MeshType = \"Brick\" \nlocal fb = Instance.new(\"Part\") \nprop(fb,nil,false,1,0,0.1,0.1,0.1,\"New Yeller\",true,\"Custom\")\nt1p = Vector3.new(-0.3,0.3,-0.55) \nt2p = Vector3.new(0.3,0.3,-0.55) \nfunction getp(path) \nlocal objs = {} \nfor _,v in pairs(path:children()) do \nif v:IsA(\"BasePart\") then \nif v:GetMass() < 30 then \ntable.insert(objs,v) \nend \nend \nfor _,k in pairs(v:children()) do \nif k:IsA(\"BasePart\") then \nif k:GetMass() < 30 then \ntable.insert(objs,k) \nend \nend \nfor _,o in pairs(k:children()) do \nif o:IsA(\"BasePart\") then \nif o:GetMass() < 30 then \ntable.insert(objs,o) \nend \nend \nend \nend \nend \nreturn objs \nend \n\nmouse.Button1Down:connect(function() \nhold = true \nbg.Parent = torso \ntrail1.Parent = char \ntrail2.Parent = char \nfb.Parent = char \nwhile hold do \n\tl = Instance.new(\"Sound\", char)\n\tl.Volume = 5\n\tl.Looped = false\n\tl.SoundId = \"rbxassetid://228343271\"\n\tl:Play()\nlocal p1 = hed.CFrame * CFrame.new(t1p).p \nlocal p2 = hed.CFrame * CFrame.new(t2p).p \nlocal dist1 = (p1 - mouse.Hit.p).magnitude \nlocal dist2 = (p2 - mouse.Hit.p).magnitude \nbg.cframe = CFrame.new(torso.Position, mouse.Hit.p) \ntrail1.CFrame = CFrame.new(p1,mouse.Hit.p) * CFrame.new(0,0,-dist1/2) \ntrail2.CFrame = CFrame.new(p2,mouse.Hit.p) * CFrame.new(0,0,-dist2/2) \nt1.Scale = Vector3.new(1,1,dist1) \nt2.Scale = Vector3.new(1,1,dist2) \nlocal lol1 = CFrame.new(p1,mouse.Hit.p) * CFrame.new(0,0,-dist1) \nfb.CFrame = lol1 \nlocal parts = getp(workspace) \nfor _,v in pairs(parts) do \nif (v.Position - lol1.p).magnitude < 2 then \nif v:findFirstChild(\"LolFire\") == nil then \nlocal f = Instance.new(\"Fire\",v) \nf.Size = 0 \nf.Heat = 5 \nf.Color = Color3.new(0,0,0)\nf.Name = \"LolFire\" \ncoroutine.resume(coroutine.create(function() \nfor i=0,10,0.2 do \nwait(0.1) \nf.Heat = i \nf.Size = i \nlocal lol = math.random(1,2) \nif lol == 1 then \nv.BrickColor = BrickColor.new(\"Institutional white\") \nelse \nv.BrickColor = BrickColor.new(\"Institutional white\") \nend \nend \nv:remove() \nend)) \nend \nend \nend \nwait() \nend \nend) \nmouse.Button1Up:connect(function() \nl:Destroy()\nhold = false \nbg.Parent = nil \ntrail1.Parent = nil \ntrail2.Parent = nil \nfb.Parent = nil \nend)  \n\n\n\nfunction charge()\n\tif not enabled then\n\t\tlocal crown = Instance.new(\"Part\", Character)\n\t\tcrown.Size = Vector3.new(1,1,1)\n\t\tcrown.CFrame = torso.CFrame  * CFrame.new(0,-3,0)\n\t\tcrown.Anchored = true\n\t\tcrown.CanCollide = false\n\t\t\n\t\tlocal crownm = Instance.new(\"SpecialMesh\", crown)\n\t\tcrownm.MeshType = \"FileMesh\"\n\t\tcrownm.MeshId = \"http://www.roblox.com/asset/?id=20329976\"\n\t\tcrownm.Scale = Vector3.new(4,0.9,4)\n\t\t\tcrown.BrickColor = BrickColor.new(\"Institutional white\")\n\t\trepeat\n\t\t\tfor i = 1, 100 do\n\t\t\t\t\n\t\t\t\tcrown.CFrame = crown.CFrame * CFrame.Angles(0,0.1,0)\n\t\t\t\tgame:GetService(\"RunService\").RenderStepped:wait()\n\t\t\t\tend\n\t\t\twait()\n\t\tuntil enabled\n\t\tspawn(function()\n\t\t\t\n\t\t\tfor i = 1,10 do\n\t\t\t\tcrown.Transparency = crown.Transparency + 0.1\t\t\t\t\n\t\t\t\tgame:GetService(\"RunService\").RenderStepped:wait()\n\t\t\tend\n\t\tend)\n\tend\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngame:GetService(\"RunService\").RenderStepped:connect(function()\nif char.Humanoid.Jump == true then\njump = true\nelse\njump = false\nend\nchar.Humanoid.FreeFalling:connect(function(f)\nif f then\nffing = true\nelse\nffing = false\nend\nend)\nif jump == true then\nanimpose = \"Jumping\" \nelseif ffing == true then\nanimpose = \"Freefalling\"\nelseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 2 then\nanimpose = \"Idle\"\nelseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 20 then\nanimpose = \"Walking\"\nelseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude > 20 then\nanimpose = \"Running\"\nend\nif animpose ~= lastanimpose then\nif Debounces.NoIdl == false then\nif stanceToggle == \"Normal\" and holy ~= true then\nfor i = 1, 2 do\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(40)), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-20)), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14),math.rad(50),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-50), 0), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.2)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-15), math.rad(20)), 0.2)\nend\nelseif stanceToggle == \"Sitting\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65+0.1*math.cos(0/30),0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(20+2*math.cos(0/30))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.2, 0.5, -.54) * CFrame.Angles(math.rad(88), 0, math.rad(48)), 0.6)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-20), math.sin(0/60)/3, 0), 0.3)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, 0, -1) * CFrame.Angles(math.rad(-6), 0, 0), 0.3)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -.1) * CFrame.Angles(math.rad(-56), 0, 0), 0.3)\nelseif stanceToggle == \"Floating\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.4)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.4)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(0/14)),math.rad(0),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.4*math.cos(0/14), 0) * CFrame.Angles(0, math.rad(0), math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(-8-2*math.cos(0/14))), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(8+2*math.cos(0/14))), 0.4)\nwait()\nend\nelse\nend\nend\nlastanimpose = animpose\nif Debounces.NoIdl == false then\nif animpose == \"Idle\" then\nif stanceToggle == \"Normal\" and holy ~= true then\nchange = 0.5\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(40+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-20-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(0/14)),math.rad(50),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-50), 0), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.2)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(-15), math.rad(20)), 0.2)\nelseif stanceToggle == \"Normal\" and holy == true then\nchange = 0.8\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.4)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.4)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(0/14)),math.rad(0),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(0, math.rad(0), math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(-8-2*math.cos(0/14))), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(-0.5, 0, math.rad(8+2*math.cos(0/14))), 0.4)\nelseif stanceToggle == \"Melee\" and holy ~= true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(20+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-20+1*math.cos(0/14)),math.rad(0),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(0), 0), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.2)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.2)\nelseif stanceToggle == \"Melee\" and holy == true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.4)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.4)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(0/14)),math.rad(0),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(0, math.rad(0), math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(-8-2*math.cos(0/14))), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(-0.5, 0, math.rad(8+2*math.cos(0/14))), 0.4)\nelseif stanceToggle == \"Sitting\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(20)), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.2, 0.5, -.54) * CFrame.Angles(math.rad(88), 0, math.rad(48)), 0.6)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5-0.06*math.cos(0/25), -.2) * CFrame.Angles(math.rad(0-20*math.cos(0/25)/2), math.sin(0/50)/2.4, 0), 0.3)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, 0, -1) * CFrame.Angles(math.rad(-6), 0, 0), 0.3)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -.1) * CFrame.Angles(math.rad(-56), 0, 0), 0.3)\nelseif stanceToggle == \"Floating\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.4)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.4)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(0/14)),math.rad(0),0), 0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.4*math.cos(0/14), 0) * CFrame.Angles(0, math.rad(0), math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(-8-2*math.cos(0/14))), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(0, 0, math.rad(8+2*math.cos(0/14))), 0.4)\nelseif stanceToggle == \"Grabbed\" and holy ~= true then\ngrab = true\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(40+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65+0.1*math.cos(0/14),-.5)*CFrame.Angles(math.rad(130+4*math.cos(0/14)),math.rad(0),math.rad(-60+4*math.cos(0/14))), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(14+2*math.cos(0/14)),math.rad(70-4*math.cos(0/14)),0), 0.3)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-70), 0), 0.3)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(10), math.rad(30), math.rad(-20)), 0.3)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-10), math.rad(-15), math.rad(20)), 0.3)\nelseif stanceToggle == \"Grabbed\" and holy == true then\ngrab = true\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.65+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(40+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65+0.1*math.cos(0/14),-.5)*CFrame.Angles(math.rad(130+4*math.cos(0/14)),math.rad(0),math.rad(-60+4*math.cos(0/14))), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(14+2*math.cos(0/14)),math.rad(70-4*math.cos(0/14)),0), 0.3)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-8), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(-0.5, 0, math.rad(8+2*math.cos(0/14))), 0.4)\nend\nelseif animpose == \"Walking\" then\nif stanceToggle == \"Normal\" and holy ~= true then\nchange = 1\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.5, 0)*CFrame.Angles(math.rad(-20), math.rad(-20),math.rad(40)), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.6, -math.sin(0/8)/2.8)*CFrame.Angles(math.sin(0/8)/4, -math.sin(0/8)/2, math.rad(-10)), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-8+2*math.cos(0/4)), math.rad(0), math.rad(0)),0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.1*math.cos(0/4), 0) * CFrame.Angles(math.rad(-4+2*math.cos(0/4)), 0, math.rad(0)), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1-0.14*math.cos(0/8)/2.8, -0.05 + math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + -math.sin(0/8)/2.3, 0, 0), .4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1+0.14*math.cos(0/8)/2.8, -0.05 + -math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + math.sin(0/8)/2.3, 0, 0), .4)\nelseif stanceToggle == \"Normal\" and holy == true then\nfor i = 1, 2 do\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-14),0,0), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-8+2*math.cos(0/14)), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-8+2*math.cos(0/14)), 0, math.rad(8)), 0.4)\nend\nelseif stanceToggle == \"Melee\" and holy ~= true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5-.05*math.cos(0/4), math.sin(0/8)/4) * CFrame.Angles(-math.sin(0/8)/2.8, -math.sin(0/8)/3, math.rad(10+2*math.cos(0/4))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5+.05*math.cos(0/4), -math.sin(0/8)/4)*CFrame.Angles(math.sin(0/8)/2.8, -math.sin(0/8)/3, math.rad(-10-2*math.cos(0/4))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-8+2*math.cos(0/4)), math.rad(0), math.rad(0)),0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.07*math.cos(0/4), 0) * CFrame.Angles(math.rad(-4+1*math.cos(0/4)), 0, math.rad(0)), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1-0.14*math.cos(0/8)/2.8, -0.05 + math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + -math.sin(0/8)/2.3, 0, 0), .4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1+0.14*math.cos(0/8)/2.8, -0.05 + -math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + math.sin(0/8)/2.3, 0, 0), .4)\nelseif stanceToggle == \"Melee\" and holy == true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-14),0,0), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-8), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-8), 0, math.rad(8)), 0.4)\nelseif stanceToggle == \"Floating\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-14-4*math.cos(0/14)),0,0), 0.4)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0-8*math.cos(0/14)), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(1-9*math.cos(0/13)), 0, math.rad(8)), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.2*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nelseif stanceToggle == \"Grabbed\" and holy ~= true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.5, 0)*CFrame.Angles(math.rad(-20), math.rad(-20),math.rad(40)), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(120),math.rad(0),math.rad(-30)), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-8+2*math.cos(0/4)), math.rad(0), math.rad(0)),0.2)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.1*math.cos(0/4), 0) * CFrame.Angles(math.rad(-4+2*math.cos(0/4)), 0, math.rad(0)), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1-0.14*math.cos(0/8)/2.8, -0.05 + math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + -math.sin(0/8)/2.3, 0, 0), .4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1+0.14*math.cos(0/8)/2.8, -0.05 + -math.sin(0/8)/3.4) * CFrame.Angles(math.rad(-10) + math.sin(0/8)/2.3, 0, 0), .4)\nelseif stanceToggle == \"Grabbed\" and holy == true then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.5, 0)*CFrame.Angles(math.rad(-20), math.rad(-20),math.rad(40)), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(120),math.rad(0),math.rad(-30)), 0.3)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-14-4*math.cos(0/14)),0,0), 0.4)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0-8*math.cos(0/14)), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(1-9*math.cos(0/13)), 0, math.rad(8)), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nend\nelseif animpose == \"Running\" then\nif stanceToggle == \"Normal\" and holy ~= true then\nchange = 1\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.35,.4)*CFrame.Angles(math.rad(250),math.rad(350),math.rad(-30+2*math.cos(0/14))), 0.2)--cfawm\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.2,0.55,-.4)*CFrame.Angles(math.rad(110),math.rad(0),math.rad(40-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, .2) * CFrame.Angles(math.rad(20),math.rad(10),0), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-40),math.rad(-10), math.rad(0)), 0.2)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, 0, -1.2) * CFrame.Angles(math.rad(-20), math.rad(10), math.rad(0)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-12), math.rad(10), math.rad(0)), 0.4)\nelseif stanceToggle == \"Normal\" and holy == true then\nchange = 1\nhed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0) * CFrame.Angles  (math.rad(44), math.rad (0), math.rad(0)), 0.15)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 1-0.1*math.cos(0/14), -1) * CFrame.Angles(math.rad(-  80),  math.rad(0), 0), 0.15)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad  (0), math.rad(50),  math.rad(-40)), 0.15)\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),   math.rad(-50),  math.rad(40)), 0.15)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(8),   math.rad(0), math.rad(- 10)), .15)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(8),   math.rad(0), math.rad(10)),  .15)\nelseif stanceToggle == \"Floating\" then\nrarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(-12),math.rad(10+2*math.cos(0/14))), 0.2)\nlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+0.1*math.cos(0/14),0)*CFrame.Angles(math.rad(-16),math.rad(12),math.rad(-10-2*math.cos(0/14))), 0.2)\nhed.Weld.C0 = CFrame.new(0,1.5,0)*CFrame.Angles(math.rad(-14-4*math.cos(0/14)),0,0)\nlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10-12*math.cos(0/16)), 0, math.rad(-8)), 0.4)\nrleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-10-12*math.cos(0/16)), 0, math.rad(8)), 0.4)\ntorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.4*math.cos(0/14), -.2) * CFrame.Angles(math.rad(-15),0, math.rad(0)), 0.05)\nend\n\nelseif animpose == \"Jumping\" then --JUMPING ANIM\n\t\nif stanceToggle == \"Normal\" and holy ~= true then\nchange = 0.8\n     \thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-10),math.rad(0),     math.rad(0)),0.7)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-10),     math.rad(0), math.rad(0)), 0.7)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), 0,     math.rad(-20)), 0.7)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-40),     math.rad(0), math.rad(20)), 0.7)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.7)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(math.rad(0), 0, 0), 0.7)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Melee\" and holy ~= true then\n     \thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-10),math.rad(0),     math.rad(0)),0.7)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-10),     math.rad(0), math.rad(0)), 0.7)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), 0,     math.rad(-20)), 0.7)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-40),     math.rad(0), math.rad(20)), 0.7)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.7)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(math.rad(0), 0, 0), 0.7)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Melee\" and holy == true then\n     \thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-10),math.rad(0),     math.rad(0)),0.7)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-10),     math.rad(0), math.rad(0)), 0.7)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(40), 0,     math.rad(-20)), 0.7)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(-40),     math.rad(0), math.rad(20)), 0.7)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-10), 0, 0), 0.7)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, -0.5) * CFrame.Angles(math.rad(0), 0, 0), 0.7)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Grabbed\" and holy ~= true then\n \t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\nelseif stanceToggle == \"Grabbed\" and holy == true then\n\t\trarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.5, 0)*CFrame.Angles(math.rad(-20), math.rad(-20),math.rad(40)), 0.2)\n\t\tlarm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.65,0)*CFrame.Angles(math.rad(120),math.rad(0),math.rad(-30)), 0.3)\n\t\thed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.2) * CFrame.Angles(math.rad(-14-4*math.cos(0/14)),0,0), 0.4)\n\t\tlleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0-8*math.cos(0/14)), 0, math.rad(-8)), 0.4)\n\t\trleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(1-9*math.cos(0/13)), 0, math.rad(8)), 0.4)\n\t\ttorso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 0-0.1*math.cos(0/14), 0) * CFrame.Angles(math.rad(-10),0, math.rad(0)), 0.05)\nend\n\nelseif animpose == \"Freefalling\" then --FF ANIM\n\t\nif stanceToggle == \"Normal\" and holy ~= true then\n  change = 0.8\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\n\t\tend\nelseif stanceToggle == \"Normal\" and holy == true then\nchange = 0.8\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Melee\" and holy ~= true then\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Melee\" and holy == true then\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n\t\t--cor.Weld.C1 = Lerp(cor.Weld.C1, CFrame.new(0, 0, 0) * CFrame.Angles(0, 200, 0), 0.3)\nelseif stanceToggle == \"Grabbed\" and holy ~= true then\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\nelseif stanceToggle == \"Grabbed\" and holy == true then\n        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-18),math.rad(0),     math.rad(0)),0.3)\n        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-13), math.rad    (0), math.rad(0)), 0.3)\n        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-60)), 0.3)\n        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(60)), 0.3)\n        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -0.6) * CFrame.Angles(math.rad(10), 0, 0), 0.3)\n        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.4) * CFrame.Angles(math.rad(-20), 0, 0),     0.3)\n\tend\nend\nend)\n\nspawn(function() \n\twhile wait() do\n\t\tupdateFly()\n\tend\nend)\n\nspawn(function() \n\twhile wait(4) do\n\t\tGroundWave()\n\tend\nend)\n\nspawn(function()\n\twhile wait(.1) do\n\t\tMagik()\t\n\tend\nend)\n\nspawn(function()\n\twhile wait(.1) do\n\t\tMagik2()\t\n\tend\nend)\n\nspawn(function()\n\twhile wait(.1) do\n\t\tFDebris()\t\n\tend\nend)\n\n\n\nfunction Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans) -- Lightning module\n    local magz = (Part0 - Part1).magnitude\n    local curpos = Part0\n    local trz = {-Offset,Offset}\n    for i=1,Times do\n        local li = Instance.new(\"Part\", torso)\n\t\tli.Name = \"Lightning\"\n\t\tli.TopSurface =0\n\t\tli.Material = \"Neon\"\n\t\tli.BottomSurface = 0\n\t\tli.Anchored = true\n\t\tli.Locked = true\n\t\tli.Transparency = Trans or 0.4\n\t\tli.BrickColor = BrickColor.new(Color)\n\t\tli.formFactor = \"Custom\"\n\t\tli.CanCollide = false\n\t\tli.Size = Vector3.new(Thickness,Thickness,magz/Times)\n        local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])\n        local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet\n        if Times == i then\n        local magz2 = (curpos - Part1).magnitude\n        li.Size = Vector3.new(Thickness,Thickness,magz2)\n        li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)\n        else\n        li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)\n        end\n        curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p\n        game.Debris:AddItem(li,.1)\n    end\nend\n\nBodyParts = {} \nfor _, v in pairs(char:GetChildren()) do\n    if v:IsA(\"Part\") and v.Name ~= \"HitBox\" and v.Name ~= \"Thingy\" then\n        table.insert(BodyParts, v)\n    end\nend\n\nBounding = {} -- Calculate the bounding boxes\nfor _, v in pairs(BodyParts) do\n\tlocal temp = {X=nil, Y=nil, Z=nil}\n\ttemp.X = v.Size.X/2 * 10\n\ttemp.Y = v.Size.Y/2 * 10\n\ttemp.Z = v.Size.Z/2 * 10\n\tBounding[v.Name] = temp\nend\n\nwhile wait(lightspeed) do \n\t\t\tlightspeed = math.random(0.1,0.2)\n\tlocal Body1 = BodyParts[math.random(#BodyParts)]\n\tlocal Body2 = BodyParts[math.random(#BodyParts)]\n\tlocal Pos1 = Vector3.new(\n\t\tmath.random(-Bounding[Body1.Name].X, Bounding[Body1.Name].X)/10,\n\t\tmath.random(-Bounding[Body1.Name].Y, Bounding[Body1.Name].Y)/10,\n\t\tmath.random(-Bounding[Body1.Name].Z, Bounding[Body1.Name].Z)/10\n)\n\tlocal Pos2 = Vector3.new(\n\t\tmath.random(-Bounding[Body2.Name].X, Bounding[Body2.Name].X)/10,\n\t\tmath.random(-Bounding[Body2.Name].Y, Bounding[Body2.Name].Y)/10,\n\t\tmath.random(-Bounding[Body2.Name].Z, Bounding[Body2.Name].Z)/10\n)\n\tlocal SPos1 = Body1.Position + Pos1\n\tlocal SPos2 = Body2.Position + Pos2\n\t\n\tLightning(SPos1, SPos2, 4, 3, eColors[math.random(1,#eColors)], .2, .56) \nend",
 "title": "idk"
}