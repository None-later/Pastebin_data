{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "kw_down",
  "lg_en"
 ],
 "key": "26LZjEx5",
 "pasteDate": "Feb 21, 2018, 7:27:11 AM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "Page 66. \"whereas each decision problem is Cook\n-reducible to its complement, some decision problems are not Karp \nreducible to their complement (see Exercises 2.7 and 2.33\"\n\nIntuition: the Cook reduction can query the oracle machine solving a decision problem many times and each time can do whatever to these answers. For example, it can flip the bits of the answer. In this way it can use an oracle for solving SAT to solve a problem in UNSAT. So a machine that uses -la-Cook another NP machine as oracle has the same power of using a co-NP machine.\n\nThe Karp reduction cannot do that. It takes the original input, transform it into the oracle input *and* must return the answer of the oracle as-is.\n\nSo if we concatenate two NP machines -la-Karp: \n\nAn NP machine has the form\n---------------\ninput x1\ny1 = Guess\nIF Verify1(x1,y1) \n\treturn 1\nELSE\n\treturn 0\n----------------\n\nNow if we combine two NP machines as in the picture NP-NP line of lecture 6 slide 6\n---------------\ninput x1\ny1 = Guess\nIF Verify1(x1,y1)\n\tinput y1\n\tx2= Guess\n\tIF Verify2(y1.x2,x1) \n\t\treturn 1\n\tELSE\n\t\treturn 0\nELSE\n\treturn 0\n------------------\n\nthis can be transformed into \n\n-----------------\ninput y1\n(y1;x2) = Guess\nIF verify(x1,y1) && verify(y1.x2;x1) \n\treturn 1\nELSE \n\treturn 0\n------------\n\nand this is still an NP machine as we can replace the AND by \n\nverify1+2(y1.x2,x1) := verify(x1,y1) && verify(y1.x2;x1) \n\nInstead we cannot do this if the second machine is a co-NP machine.\n---------------\ninput x1\ny1 = Guess\nIF Verify1(x1,y1)\n\tCall-Co-NP-Machine(x1,y1)\nELSE\n\treturn 0\n------------------\n\nwe do not know how to translate the Call-Co-NP-Machine(x1,y1) (unless NP=co-NP). \n\nBasically this boils down to the following intuition:\n\nif we make \"single calls\" to the oracle a la Karp then we need to alternate between NP and co-NP to have an alternation. If we can make complex calls a-la-Cook then we can call the same oracle because the cook caller is more powerful and thus can squeeze more information from the callee.\n\nloosely speaking we can say\n\nNP^(single-call-and-no-processing-to-NP) = NP\n\nNP^(multiple-calls-and-processing-to-NP) > NP^(single-call-and-no-processing-to-Co-NP)\n\nThis explains the apparent contradiction between the slides of lecture 8 pag 22 that say to build the hierarchy you must have NP^co-NP^NP alternating and Proposition 3.11 which says that Sigma_k+1 = NP^Sigma_k because this \"^Sigma_k\" is \"multiple-calls-and-processing-to-Sigma_k\".\n\nSince most of the proofs and exercises that are found in the literature around are of the form \nC1^(single-call-and-no-processing-to-C2) it is then important to memorize the fact that C1 and C2 must alternate between X and co-X.",
 "title": ""
}