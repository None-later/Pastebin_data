{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "MBNAY2bf",
 "pasteDate": "Feb 18, 2018, 6:32:02 AM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "/*\n  Some design points:\n  1. IRobot interface is used because of there arn't basic functioanality and I'd like to preffer implementation before inheritance.\n  2. IResult<T> interface to describe returned type and incaplsulate logic in each of IChip type.\n*/\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace HomeTaskRobot\n{\n\tclass Program\n\t{\n\t\t/// <summary>\n\t\t/// Execute chip operation\n\t\t/// </summary>\n\t\tpublic interface IChip\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Chip oparation contracr\n\t\t\t/// </summary>\n\t\t\t/// <typeparam name=\"T\">Custom returned type</typeparam>\n\t\t\t/// <returns></returns>\n\t\t\tIResult<T> Execute<T>();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Generic chip's result\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\tpublic interface IResult<T>\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Generic result\n\t\t\t/// </summary>\n\t\t\tT Result { get; set; }\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Robot interface\n\t\t/// </summary>\n\t\tpublic interface IRobot\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Getting unique chips count\n\t\t\t/// </summary>\n\t\t\tint InstalledChipUniqueTypesCount { get; }\n\n\t\t\t/// <summary>\n\t\t\t/// Set chip for some operation type\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"chip\"></param>\n\t\t\tvoid SetChip(IChip chip);\n\n\t\t\t/// <summary>\n\t\t\t/// Executing installed chip operation\n\t\t\t/// </summary>\n\t\t\t/// <typeparam name=\"T\">Returned type</typeparam>\n\t\t\t/// <returns></returns>\n\t\t\tT Execute<T>();\n\t\t}\n\n\t\tpublic class Robot : IRobot\n\t\t{\n\t\t\tprivate IChip _currentChip;\n\t\t\tprivate readonly object _lockObject = new object();\n\t\t\tprivate readonly HashSet<string> _uniqueChipTypes = new HashSet<string>();\n\n\t\t\t/// <summary>\n\t\t\t/// Get the unique installed chips count \n\t\t\t/// </summary>\n\t\t\tpublic int InstalledChipUniqueTypesCount => _uniqueChipTypes.Count;\n\n\t\t\t/// <summary>\n\t\t\t/// Set current chip\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"chip\"></param>\n\t\t\tpublic void SetChip(IChip chip)\n\t\t\t{\n\t\t\t\tif (chip == null)\n\t\t\t\t\tthrow new ArgumentNullException(\"chip to set hasn't be null\");\n\n\t\t\t\tlock (_lockObject)\n\t\t\t\t{\n\t\t\t\t\t_currentChip = chip;\n\t\t\t\t\t_uniqueChipTypes.Add(chip.GetType().FullName);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Executing installed chip operation\n\t\t\t/// </summary>\n\t\t\t/// <typeparam name=\"T\">Returned type</typeparam>\n\t\t\t/// <returns></returns>\n\t\t\tpublic T Execute<T>()\n\t\t\t{\n\t\t\t\tif (_currentChip == null)\n\t\t\t\t\tthrow new ArgumentNullException(\"current chip isn't setted\");\n\n\t\t\t\treturn _currentChip.Execute<T>().Result;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Chip with sorting implementation\n\t\t/// </summary>\n\t\tpublic class SortableChip : IChip\n\t\t{\n\t\t\tprivate List<int> _list;\n\t\t\tprivate bool _isAsc = true;\n\n\t\t\tpublic SortableChip(List<int> list)\n\t\t\t{\n\t\t\t\tif (list == null)\n\t\t\t\t\tthrow new ArgumentNullException();\n\n\t\t\t\t_list = list;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Execute sortable chip operation\n\t\t\t/// </summary>\n\t\t\t/// <typeparam name=\"T\">Custom returned type</typeparam>\n\t\t\t/// <returns></returns>\n\t\t\tpublic IResult<T> Execute<T>()\n\t\t\t{\n\t\t\t\tif (_isAsc)\n\t\t\t\t\treturn (IResult<T>)new SortableResult { Result = _list.OrderBy(x => x).ToList() };\n\t\t\t\telse\n\t\t\t\t\treturn (IResult<T>)new SortableResult { Result = _list.OrderByDescending(x => x).ToList() };\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Setting sorting tupe operation\n\t\t\t/// </summary>\n\t\t\tpublic void SetAsc()\n\t\t\t{\n\t\t\t\t_isAsc = true;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Setting sorting tupe operation\n\t\t\t/// </summary>\n\t\t\tpublic void SetDesc()\n\t\t\t{\n\t\t\t\t_isAsc = false;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Generic result implementation\n\t\t\t/// </summary>\n\t\t\tpublic class SortableResult : IResult<List<int>>\n\t\t\t{\n\t\t\t\tpublic List<int> Result { get; set; }\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Chip with sorting implementation\n\t\t/// </summary>\n\t\tpublic class SummarableChip : IChip\n\t\t{\n\t\t\tprivate readonly List<int> _list;\n\n\t\t\tpublic SummarableChip(List<int> list)\n\t\t\t{\n\t\t\t\tif (list == null)\n\t\t\t\t\tthrow new ArgumentNullException(\"input list is empty\");\n\n\t\t\t\t_list = list;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Execute sortable chip operation\n\t\t\t/// </summary>\n\t\t\t/// <typeparam name=\"T\">Custom returned type</typeparam>\n\t\t\t/// <returns></returns>\n\t\t\tpublic IResult<T> Execute<T>()\n\t\t\t{\n\t\t\t\tvar res = new SumResult() { Result = _list.Sum() };\n\t\t\t\treturn (IResult<T>)res;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Generic result implementation\n\t\t\t/// </summary>\n\t\t\tpublic class SumResult : IResult<int>\n\t\t\t{\n\t\t\t\tpublic int Result { get; set; }\n\t\t\t}\n\t\t}\n\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar originalList = new List<int> { 1, 7, 5, 2, 25 };\n\n\t\t\tvar robot = new Robot();\n\n\t\t\tvar sortableChip = new SortableChip(originalList);\n\t\t\tsortableChip.SetAsc();\n\n\t\t\trobot.SetChip(sortableChip);\n\t\t\tvar sortResultChipAscResult = robot.Execute<List<int>>();\n\n\t\t\tsortResultChipAscResult.ForEach(i => Console.Write($\" {i}\"));\n\t\t\tConsole.WriteLine();\n\n\t\t\tsortableChip.SetDesc();\n\t\t\trobot.SetChip(sortableChip);\n\t\t\tvar sortResultChipDescResult = robot.Execute<List<int>>();\n\n\t\t\tsortResultChipDescResult.ForEach(i => Console.Write($\" {i}\"));\n\t\t\tConsole.WriteLine();\n\n\n\t\t\tvar summarableChip = new SummarableChip(originalList);\n\t\t\trobot.SetChip(summarableChip);\n\n\t\t\tvar summResult = robot.Execute<int>();\n\n\t\t\tConsole.WriteLine(summResult);\n\n\t\t\tConsole.WriteLine(robot.InstalledChipUniqueTypesCount);\n\n\t\t\t// tests area\n\t\t\tRunRobotTest();\n\t\t\tRunSummarableChipTest();\n\t\t\tRunSortableChipTest();\n\t\t}\n\t\t\n\t\tstatic void RunRobotTest()\n\t\t{\n\t\t\tvar originalList = new List<int> { 1, 7, 5, 2, 25 };\n\t\t\tvar robot = new Robot();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\trobot.SetChip(null);\n\t\t\t\tDebug.Assert(false, \"Robot mustn't be setted with null value\");\n\t\t\t}\n\t\t\tcatch (ArgumentNullException)\n\t\t\t{}\n\n\t\t\trobot.SetChip(new SummarableChip(originalList));\n\t\t\tDebug.Assert(robot.InstalledChipUniqueTypesCount == 1);\n\n\t\t\trobot.SetChip(new SummarableChip(originalList));\n\t\t\tDebug.Assert(robot.InstalledChipUniqueTypesCount == 1);\n\n\t\t\trobot.SetChip(new SortableChip(originalList));\n\t\t\tDebug.Assert(robot.InstalledChipUniqueTypesCount == 2);\n\t\t}\n\n\t\tstatic void RunSummarableChipTest()\n\t\t{\n\t\t\tvar originalList = new List<int> { 1, 7, 5, 2, 25 };\n\t\t\tvar expectedValue = originalList.Sum();\n\n\t\t\tvar summarableChip = new SummarableChip(originalList);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsummarableChip = new SummarableChip(null);\n\t\t\t\tDebug.Assert(false, \"SummarableChip mustn't be setted with null value\");\n\t\t\t}\n\t\t\tcatch (ArgumentNullException)\n\t\t\t{ }\n\n\t\t\tvar result = summarableChip.Execute<int>();\n\t\t\tDebug.Assert(result.Result == expectedValue);\n\t\t}\n\n\t\tstatic void RunSortableChipTest()\n\t\t{\n\t\t\tvar originalList = new List<int> { 1, 7, 5, 2, 25 };\n\t\t\tvar expectedList = new List<int> { 1, 2, 5, 7, 25 };\n\t\t\tvar summarableChip = new SortableChip(originalList);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsummarableChip = new SortableChip(null);\n\t\t\t\tDebug.Assert(false, \"SortableChip mustn't be setted with null value\");\n\t\t\t}\n\t\t\tcatch (ArgumentNullException)\n\t\t\t{ }\n\n\t\t\tsummarableChip.SetAsc();\n\t\t\tvar result = summarableChip.Execute<List<int>>();\n\t\t\tDebug.Assert(result.Result.SequenceEqual(expectedList));\n\t\t}\n\t}\n}",
 "title": ""
}