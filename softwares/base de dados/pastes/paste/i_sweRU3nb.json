{
 "espireDate": "N",
 "format": "cpp",
 "jSonReasons": [
  "lg_hr"
 ],
 "key": "sweRU3nb",
 "pasteDate": "Feb 17, 2018, 7:42:37 PM",
 "relevancy": 0.0,
 "relevant": false,
 "text": "#include<iostream>\n#include<string>\n#include<vector>\n#include<regex>\nusing namespace std;\nclass Datum {\n\tint *_dan, *_mjesec, *_godina;\npublic:\n\tDatum(int dan = 1, int mjesec = 1, int godina = 2000) {\n\t\t_dan = new int(dan);\n\t\t_mjesec = new int(mjesec);\n\t\t_godina = new int(godina);\n\t}\n\tDatum(const Datum &dat) {\n\t\t_dan = new int(*dat._dan);\n\t\t_mjesec = new int(*dat._mjesec);\n\t\t_godina = new int(*dat._godina);\n\t}\n\t~Datum() {\n\t\tdelete _dan; _dan = nullptr;\n\t\tdelete _mjesec; _mjesec = nullptr;\n\t\tdelete _godina; _godina = nullptr;\n\t}\n\tvoid operator = (Datum &dat) {\n\t\t_dan = new int(*dat._dan);\n\t\t_mjesec = new int(*dat._mjesec);\n\t\t_godina = new int(*dat._godina);\n\t}\n\tbool operator == (Datum dat) {\n\t\tif (_dan == dat._dan && _mjesec == dat._mjesec && _godina == dat._godina)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tfriend ostream &operator<<(ostream &COUT, const Datum &obj) {\n\t\tCOUT << *obj._dan << \" \" << *obj._mjesec << \" \" << *obj._godina;\n\t\treturn COUT;\n\t}\n\n};\nclass Izuzetak : public exception {\n\tstring _funkcija;\npublic:\n\tIzuzetak(char * text, string funkcija) :exception(text) {\n\t\t_funkcija = funkcija;\n\t}\n};\n\ntemplate <class T1, class T2>\nclass Kolekcija {\n\tT1 * _elementi1;\n\tT2 * _elementi2;\n\tint _trenutnoElemenata;\n\tbool _omoguciDupliranjeElemenata;\npublic:\n\tKolekcija(bool omoguciDupliranjeElemenata = false) {\n\t\t_trenutnoElemenata = 0;\n\t\t_omoguciDupliranjeElemenata = omoguciDupliranjeElemenata;\n\t\t_elementi1 = nullptr;\n\t\t_elementi2 = nullptr;\n\t}\n\tKolekcija(const Kolekcija<T1, T2> &kol) {\n\t\t_elementi1 = new T1[kol._trenutnoElemenata];\n\t\t_elementi2 = new T2[kol._trenutnoElemenata];\n\t\tfor (int i = 0; i < kol._trenutnoElemenata; i++)\n\t\t{\n\t\t\t_elementi1[i] = kol._elementi1[i];\n\t\t\t_elementi2[i] = kol._elementi2[i];\n\t\t}\n\t\t_trenutnoElemenata = kol._trenutnoElemenata;\n\t\t_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;\n\t}\n\t~Kolekcija() {\n\t\tdelete[]_elementi2; _elementi2 = nullptr;\n\t\tdelete[]_elementi1; _elementi1 = nullptr;\n\t\t_trenutnoElemenata = 0;\n\t}\n\tbool AddElement(T1 e1, T2 e2) {\n\t\tif (!_omoguciDupliranjeElemenata) {\n\t\t\tfor (int i = 0; i < _trenutnoElemenata; i++)\n\t\t\t{\n\t\t\t\tif (_elementi1[i] == e1 && _elementi2[i] == e2)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tT1 *temp1 = new T1[_trenutnoElemenata+1];\n\t\tT2 *temp2 = new T2[_trenutnoElemenata+1];\n\t\tfor (int i = 0; i < _trenutnoElemenata; i++)\n\t\t{\n\t\t\ttemp1[i] = _elementi1[i];\n\t\t\ttemp2[i] = _elementi2[i];\n\t\t}\n\t\ttemp1[_trenutnoElemenata] = e1;\n\t\ttemp2[_trenutnoElemenata] = e2;\n\t\tdelete[] _elementi1;\n\t\tdelete[] _elementi2;\n\t\t_elementi1 = temp1;\n\t\t_elementi2 = temp2;\n\t\t_trenutnoElemenata++;\n\t\treturn true;\n\t}\n\tbool RemoveElement(T1 e1) {\n\t\tT1 *temp1 = new T1[_trenutnoElemenata];\n\t\tT2 *temp2 = new T2[_trenutnoElemenata];\n\t\tfor (int i = 0; i < _trenutnoElemenata; i++)\n\t\t{\n\t\t\tif (_elementi1[i] == e1) {\n\t\t\t\tfor (int j = 0; j < _trenutnoElemenata; j++)\n\t\t\t\t{\n\t\t\t\t\tif (i > j) {\n\t\t\t\t\t\ttemp1[j] = _elementi1[j];\n\t\t\t\t\t\ttemp2[j] = _elementi2[j];\n\t\t\t\t\t}\n\t\t\t\t\tif (i < j) {\n\t\t\t\t\t\ttemp1[j-1] = _elementi1[j];\n\t\t\t\t\t\ttemp2[j-1] = _elementi2[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete[] _elementi1;\n\t\t\t\tdelete[] _elementi2;\n\t\t\t\t_elementi1 = temp1;\n\t\t\t\t_elementi2 = temp2;\n\t\t\t\t_trenutnoElemenata--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n\tint GetTrenutno() const { return _trenutnoElemenata; }\n\tT1& GetElement1(int lokacija) const\n\t{\n\t\tif (lokacija < 0 || lokacija >= _trenutnoElemenata)\n\t\t\tthrow Izuzetak(\"Nepostojeca lokacija\", __FUNCTION__);\n\t\treturn _elementi1[lokacija];\n\t}\n\n\tT2& GetElement2(int lokacija) const\n\t{\n\t\tif (lokacija < 0 || lokacija >= _trenutnoElemenata)\n\t\t\tthrow Izuzetak(\"Nepostojeca lokacija\", __FUNCTION__);\n\t\treturn _elementi2[lokacija];\n\t}\n\n\tvoid operator = (Kolekcija<T1, T2> &kol) {\n\t\t_elementi1 = new T1[kol._trenutnoElemenata];\n\t\t_elementi2 = new T2[kol._trenutnoElemenata];\n\t\tfor (int i = 0; i < kol._trenutnoElemenata; i++)\n\t\t{\n\t\t\t_elementi1[i] = kol._elementi1[i];\n\t\t\t_elementi2[i] = kol._elementi2[i];\n\t\t}\n\t\t_trenutnoElemenata = kol._trenutnoElemenata;\n\t\t_omoguciDupliranjeElemenata = kol._omoguciDupliranjeElemenata;\n\t}\n\tfriend ostream &operator<<(ostream &COUT, const Kolekcija &obj) {\n\t\tfor (size_t i = 0; i < obj.GetTrenutno(); i++)\n\t\t\tCOUT << obj._elementi1[i] << \" \" << obj._elementi2[i] << endl;\n\t\treturn COUT;\n\t}\n};\n\nclass Dogadjaj\n{\n\tDatum _datumOdrzavanja;\n\tKolekcija<string, bool> * _obaveze; //cuva informaciju o obavezama koje je potrebno ispuniti prije samog dogadjaja, string se odnosi na opis, a bool na izvrsenje te obaveze (da li je zavrsena ili ne)\n\n\tchar *_naziv;\n\tint _notificirajPrije; //oznacava broj dana prije samog dogadjaja kada ce krenuti notifikacija/podsjetnik\n\tbool _rekurzivnaNotifikacija; //ako je vrijednost true onda se korisnik notificira svaki dan do _datumaOdrzavanja dogadjaja, a pocevsi prije dogadjaja za _brojDanaZaNotifikaciju\n\npublic:\n\tDogadjaj(Datum datumOdrzavanja, const char *naziv, int brojDana = 1,\n\t\tbool rekurzivnaNotifikacija = false) : _datumOdrzavanja(datumOdrzavanja)\n\t{\n\t\t_naziv = new char[strlen(naziv) + 1];\n\t\tstrcpy_s(_naziv, strlen(naziv) + 1, naziv);\n\n\t\t_notificirajPrije = brojDana;\n\t\t_rekurzivnaNotifikacija = rekurzivnaNotifikacija;\n\t\t_obaveze = new Kolekcija<string, bool>;\n//\t\t_obaveze = nullptr;\n\t}\n\n\tDogadjaj(const Dogadjaj &obj) : _datumOdrzavanja(obj._datumOdrzavanja)\n\t{\n\t\t_naziv = new char[strlen(obj._naziv) + 1];\n\t\tstrcpy_s(_naziv, strlen(obj._naziv) + 1, obj._naziv);\n\n\t\t_notificirajPrije = obj._notificirajPrije;\n\t\t_rekurzivnaNotifikacija = obj._rekurzivnaNotifikacija;\n\t//\t_obaveze = new Kolekcija<string, bool>;\n\t\t_obaveze = obj._obaveze;\n\t}\n\t~Dogadjaj()\n\t{\n\t\tdelete[] _naziv;\n\t\t_naziv = nullptr;\n\t\tdelete _obaveze;\n\t\t_obaveze = nullptr;\n\t}\n\tbool AddObavezu(string obaveza) {\n\t\tfor (int i = 0; i < _obaveze->GetTrenutno(); i++)\n\t\t{\n\t\t\tif (_obaveze->GetElement1(i) == obaveza)\n\t\t\t\treturn false;\n\t\t}\n\t\t_obaveze->AddElement(obaveza, false);\n\t}\n\tchar *GetNaziv() { return _naziv; }\n\tKolekcija<string, bool> *GetObaveze() { return _obaveze; }\n\tbool operator == (Dogadjaj dog) {\n\t\tif (_naziv == dog._naziv && _datumOdrzavanja == dog._datumOdrzavanja)\n\t\t\treturn true;\n\t\telse return false;\n\t}\n};\n\nclass Student\n{\n\tint _indeks;\n\tstring _imePrezime;\n\tvector<Dogadjaj> _dogadjaji;\npublic:\n\n\tStudent(int indeks, string imePrezime) : _indeks(indeks), _imePrezime(imePrezime) {}\n\n\tint GetIndeks() const { return _indeks; }\n\n\tvector<Dogadjaj>& GetDogadjaji() { return _dogadjaji; }\n\n\n\tbool AddDogadjaj(Dogadjaj &dog) {\n\t\tfor (int i = 0; i < _dogadjaji.size(); i++)\n\t\t{\n\t\t\tif (_dogadjaji[i] == dog) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\t_dogadjaji.push_back(dog);\n\t\t\treturn true;\n\t}\n\n\n\tfriend ostream &operator<<(ostream &COUT, const Student &obj)\n\t{\n\t\tCOUT << obj._imePrezime << \" (\" << obj._indeks << \")\" << endl;\n\t\treturn COUT;\n\t}\n};\n\nclass DLWMSReminder\n{\n\tvector<Student> _reminiderList;\n};\n\nvoid main() {\n\n\t/**************************************************************************\n\t1. SVE KLASE TREBAJU POSJEDOVATI ADEKVATAN DESTRUKTOR\n\t2. NAMJERNO IZOSTAVLJANJE KOMPLETNIH I/ILI POJEDINIH DIJELOVA DESTRUKTORA KOJI UZROKUJU RUNTIME ERROR CE BITI OZNACENO KAO \"RE\"\n\t3. SPASAVAJTE PROJEKAT KAKO BI SE SPRIJECILO GUBLJENJE URADJENOG ZADATKA\n\t4. PROGRAMSKI CODE SE TAKODJER NALAZI U FAJLU CODE_ParcijalniII.TXT\n\t5. NAZIVI FUNKCIJA MORAJU BITI IDENTINI ONIMA KOJI SU KORITENI U TESTNOM CODE-U.OSTALE, POMONE FUNKCIJE MOETE IMENOVATI PO ELJI.\n\t****************************************************************************/\n\tchar* crt = \"\\n/**************************************************************************/\\n\";\n#pragma region Datum\n\n\tDatum danas(28, 1, 2018), sutra(29, 1, 2018);\n\tDatum datumIspitaPRIII(30, 1, 2018), datumIspitBPII(31, 1, 2018);\n\tDatum prekosutra(danas);\n\tprekosutra = danas;\n\tcout << danas << endl\n\t\t<< sutra << endl\n\t\t<< prekosutra << crt;\n\n#pragma endregion\n\n#pragma region Kolekcija\n\n\t/*\n\tAddElement :: omogucava dodavanje novog elementa u kolekciju. Ukoliko je moguce, osigurati automatsko prosiranje kolekcije prilikom dodavanja svakog novog elementa, te onemoguciti ponavljanje elemenata\n\tRemoveElement :: na osnovu parametra tipa T1 uklanja elemente iz kolekcije i ukoliko je moguce smanjuje velicinu niza/kolekcije. Prilikom uklanjanja elemenata ocuvati redoslijed njihovog dodavanja\n\t*/\n\tconst int brElemenata = 10;\n\tKolekcija<int, float> kolekcija1;\n\tfor (size_t i = 0; i < brElemenata; i++)\n\t\tif (!kolekcija1.AddElement(i, i + (0.6 * i)))\n\t\t\tcout << \"Elementi \" << i << \" i \" << i + (0.6 * i) << \" nisu dodati u kolekciju\" << endl;\n\n\tcout << kolekcija1.GetElement1(0) << \" \" << kolekcija1.GetElement2(0) << endl;\n\tcout << kolekcija1 << endl;\n\n\tkolekcija1.RemoveElement(1);\n\n\tKolekcija<int, float> kolekcija2;\n\tkolekcija2 = kolekcija1;\n\tcout << kolekcija2 << crt;\n\n\tif (kolekcija1.GetTrenutno() == kolekcija2.GetTrenutno())\n\t\tcout << \"ISTI BROJ ELEMENATA\" << endl;\n\n\tKolekcija<int, float> kolekcija3(kolekcija2);\n\tcout << kolekcija3 << crt;\n\n#pragma endregion\n\n#pragma region Dogadjaj\n\n\tDogadjaj ispitPRIII(datumIspitaPRIII, \"Ispit iz PRIII\", 5, true),\n\t\tispitBPII(datumIspitBPII, \"Ispit iz BPII\", 7, true);\n\t///*po vlasitom izboru definisati listu zabranjenih rijeci koje ce onemoguciti dodavanje odredjene obaveze. Prilikom provjere koristiti regex*/\n\tif (ispitPRIII.AddObavezu(\"Preraditi pdf materijale\"))cout << \"Obaveza dodana!\" << endl;\n\t//onemoguciti dupliranje obaveza\n\tif (!ispitPRIII.AddObavezu(\"Preraditi pdf materijale\"))cout << \"Obaveza nije dodana!\" << endl;\n\tif (ispitPRIII.AddObavezu(\"Pregledati video materijale\"))cout << \"Obaveza dodana!\" << endl;\n\tif (ispitPRIII.AddObavezu(\"Preraditi ispitne zadatke\"))cout << \"Obaveza dodana!\" << endl;\n\tif (ispitPRIII.AddObavezu(\"Samostalno vjezbati\"))cout << \"Obaveza dodana!\" << endl;\n\n\tif (ispitBPII.AddObavezu(\"Preraditi knjigu SQL za 24 h\"))cout << \"Obaveza dodana!\" << endl;\n\tif (ispitBPII.AddObavezu(\"Pregledati video materijale\"))cout << \"Obaveza dodana!\" << endl;\n\tif (ispitBPII.AddObavezu(\"Napraviti bazu za konkretnu aplikaciju\"))cout << \"Obaveza dodana!\" << endl;\n\n\tStudent jasmin(150051, \"Jasmin Azemovic\"), adel(160061, \"Adel Handzic\");\n\n\tif (jasmin.AddDogadjaj(ispitPRIII) && jasmin.AddDogadjaj(ispitBPII))\n\t\tcout << \"Dogadjaj uspjesno dodan!\" << endl;\n\n\tif (adel.AddDogadjaj(ispitPRIII) && adel.AddDogadjaj(ispitBPII))\n\t\tcout << \"Dogadjaj uspjesno dodan!\" << endl;\n\t//onemoguciti dupliranje dogadjaja\n\tif (!adel.AddDogadjaj(ispitPRIII))\n\t\tcout << \"Dogadjaj nije uspjesno dodan!\" << endl;\n\n\t//DLWMSReminder reminder;\n\n\t//try\n\t//{\n\t//\treminder.AddStudent(jasmin);\n\t//\treminder.AddStudent(adel);\n\t//\t//u slucaju dupliranja studenata funkcija baca izuzetak tipa Izuzetak\n\t//\treminder.AddStudent(jasmin);\n\t//}\n\t//catch (exception &err)\n\t//{\n\t//\t//ispisati sve informacije o nastalom izuzetku\n\t//}\n\n\t////da bi bila oznacena kao zavrsena, obaveza mora postojati i mora biti oznacena kao nezavrsena (false)\n\t//if (reminder.OznaciObavezuKaoZavrsenu(150051, \"Ispit iz PRIII\", \"Pregledati video materijale\"))\n\t//\tcout << \"Obaveza oznacena kao zavrsena\" << endl;\n\n\t///*metodi PosaljiNotifikacije se salje trenutni datum na osnovu cega ona pretrazuje sve studente koje treba podsjetiti/notoficirati o dogadjajima koji se priblizavaju.\n\t//Koristeci multithread-ing, svim studentima se salju notifikacije sa sljedecim sadrzajem:\n\t//-------------------------------------------------------------------------\n\t//Postovani Jasmin Azemovic,\n\t//Dogadjaj Ispit iz PRIII je zakazan za 3 dana, a do sada ste obavili 56% obaveza vezanih za ovaj dogadjaj. Neispunjene obaveze su:\n\t//1.Preraditi ispitne zadatke\n\t//2.Samostalno vjezbati\n\t//Predlazemo Vam da ispunite i ostale planirane obaveze.\n\t//FIT Reminder\n\t//-------------------------------------------------------------------------\n\t//Dakle, notifikacije ce biti poslane svim studentima koji su dodali dogadjaj za 30.01.2018. godine i oznacili da zele da budu podsjecani ponovo/rekurzivno najmanje 2 dana prije samog dogadjaja (podaci se odnose na konkretan dogadjaj: Ispit iz PRIII)\n\n\t//*/\n\t//int poslato = 0;\n\t////funkcija vraca broj poslatih podsjetnika/notifikacija\n\t//poslato = reminder.PosaljiNotifikacije(danas);\n\t//cout << \"Za \" << danas << \" poslato ukupno \" << poslato << \" podsjetnika!\" << endl;\n\t//poslato = reminder.PosaljiNotifikacije(sutra);\n\t//cout << \"Za \" << sutra << \" poslato ukupno \" << poslato << \" podsjetnika!\" << endl;\n\n//#pragma endregion\n\n\tsystem(\"pause\");\n}",
 "title": ""
}