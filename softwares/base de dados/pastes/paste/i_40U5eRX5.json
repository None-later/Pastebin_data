{
 "espireDate": "N",
 "format": "text",
 "jSonReasons": [
  "lg_en"
 ],
 "key": "40U5eRX5",
 "pasteDate": "Feb 20, 2018, 2:05:29 PM",
 "relevancy": 2.0,
 "relevant": false,
 "text": "require File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec_helper'))\n\ndef with_adapters(*adapters)\n  adapters = if !adapters.empty?\n    ADAPTERS.only(*adapters)\n  elsif ENV['ADAPTERS'] == 'all'\n    ADAPTERS\n  else\n    ADAPTERS.only(*ENV['ADAPTERS'].strip.downcase.split(/\\s+/))\n  end\n  \n  adapters.each do |adapter, connection_uri|\n    if adapters.length > 1\n      describe \"with #{adapter}\" do\n    \n        before(:each) do\n          DataMapper.setup(:default, connection_uri)\n          DataMapper.auto_migrate!\n        end\n    \n        yield adapter\n      end\n    else\n      before(:each) do\n        DataMapper.setup(:default, connection_uri)\n        DataMapper.auto_migrate!\n      end\n  \n      yield adapter\n    end\n  end\nend\n\ndef with_alternate\n  # This would actually loop through all the alternate\n  # adapters, but I'm too tired to finish it up\n  if @adapter == 'mysql'\n    DataMapper.setup(:alternate, ALTERNATE['postgres'])\n  else\n    DataMapper.setup(:alternate, ALTERNATE['mysql'])\n  end\nend\n\ndescribe DataMapper::Resource do\n  \n  before(:each) do\n    Object.send(:remove_const, :User) if defined?(User)\n    class User\n      include DataMapper::Resource\n\n      property :id,   Integer, :key => true\n      property :name, String\n    end\n\n    # This is a special class that needs to be an exact copy of User\n    Object.send(:remove_const, :Clone) if defined?(Clone)\n    class Clone\n      include DataMapper::Resource\n\n      property :id,   Integer, :key => true\n      property :name, String\n    end\n  end\n  \n  with_adapters do |adapter|\n\n    describe \"#eql?\" do\n      \n      it \"should be true when they are the same objects\" do\n        user = User.new\n        user.should be_eql(user)\n      end\n  \n      it \"should be false when they are instances of different classes\" do\n        User.new(:name => \"John\").should_not    be_eql(Clone.new(:name => \"John\"))\n        User.create(:name => \"John\").should_not be_eql(Clone.create(:name => \"John\"))\n      end\n  \n      it \"should be true when they are instances from the same repository, the keys are the same, and properties are the same\" do\n        user = User.create(:name => \"Bill\", :id => 1)\n        user.should be_eql(User.get(1))\n      end\n  \n      it \"should be true when they are instances from the same repository, the keys are the same, but the attributes differ\" do\n        user = User.create(:name => \"Bill\", :id => 1)\n        user.name = \"John\"\n        user.should be_eql(User.get(1))\n      end\n  \n      with_alternate do\n        it \"should be true when they are instances from different repositories, but the keys and attributes are the same\" do\n          pending\n          user  = User.create(:name => \"Bill\", :id => 5)\n          other = repository(:alternate) { User.create(:name => \"Bill\", :id => 5) }\n          user.should be_eql(other)\n        end\n      end\n  \n      it \"should be true when they are different \" do\n    \n      end\n  \n    end\n  end\nend",
 "title": ""
}